/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/

/***************************************************************
* Wren C3 Bindings
* This file is the C3 bindings for the wren scripting language
****************************************************************/

module buffer{Type} @private @if($feature(WREN_ENABLE));

struct Buffer                                                      
{
  Type* data;
  int count;
  int capacity;
}


module thirdparty::wren @if($feature(WREN_ENABLE));

import buffer @public;

// The Wren semantic version number components.
const int VERSION_MAJOR = 0;
const int VERSION_MINOR = 4;
const int VERSION_PATCH = 0;

// A human-friendly string representation of the version.
const String VERSION_STRING = "0.4.0";

// A monotonically increasing numeric representation of the version number. Use
// this if you want to do range checks over versions.
const int WREN_VERSION_NUMBER = (VERSION_MAJOR * 1000000 +
                                 VERSION_MINOR * 1000 +                   
                                 VERSION_PATCH);

// The maximum number of temporary roots that can be used at once.
const int WREN_MAX_TEMP_ROOTS = 8;
const int MAX_LOCALS = 256;
const int MAX_UPVALUES = 256;
const int MAX_INTERPOLATION_NESTING = 8;

/* in wren_utils.h
// A generic buffer type that can hold any type of data.
DECLARE_BUFFER(Byte, uint8_t);
DECLARE_BUFFER(Int, int);
DECLARE_BUFFER(String, ObjString*);
*/

// A heap-allocated string object.
struct ObjString
{
  Obj obj;
  // Number of bytes in the string, not including the null terminator.
  uint length;
  // The hash value of the string's contents.
  uint hash;
  // Inline array of the string's bytes followed by a null terminator.
  char[*] value;
}

// types used by the VM
typedef Value = inline ulong;
typedef Byte = inline char;

alias MethodBuffer = Buffer{Method};
alias ByteBuffer = Buffer{Byte};
alias ValueBuffer = Buffer{Value};
alias IntBuffer = Buffer{int};
alias StringBuffer = Buffer{ObjString*};
alias SymbolTable = StringBuffer;

// A hash table mapping keys to values.
//
// We use something very simple: open addressing with linear probing. The hash
// table is an array of entries. Each entry is a key-value pair. If the key is
// the special UNDEFINED_VAL, it indicates no value is currently in that slot.
// Otherwise, it's a valid key, and the value is the value associated with it.
//
// When entries are added, the array is dynamically scaled by GROW_FACTOR to
// keep the number of filled slots under MAP_LOAD_PERCENT. Likewise, if the map
// gets empty enough, it will be resized to a smaller array. When this happens,
// all existing entries are rehashed and re-added to the new array.
//
// When an entry is removed, its slot is replaced with a "tombstone". This is an
// entry whose key is UNDEFINED_VAL and whose value is TRUE_VAL. When probing
// for a key, we will continue past tombstones, because the desired key may be
// found after them if the key that was removed was part of a prior collision.
// When the array gets resized, all tombstones are discarded.

struct MapEntry @packed
{
  // The entry's key, or UNDEFINED_VAL if the entry is not in use.
  Value key;
  // The value associated with the key. If the key is UNDEFINED_VAL, this will
  // be false to indicate an open available entry or true to indicate a
  // tombstone -- an entry that was previously in use but was then deleted.
  Value value;
}

struct ObjMap
{
  Obj obj;
  // The number of entries allocated.
  uint capacity;
  // The number of entries in the map.
  uint count;
  // Pointer to a contiguous array of [capacity] entries.
  MapEntry* entries;
}
////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////

// A loaded _module and the top-level variables it defines.
//
// While this is an Obj and is managed by the GC, it never appears as a
// first-class object in Wren.
struct ObjModule
{
  Obj obj;
  // The currently defined top-level variables.
  ValueBuffer variables;
  // Symbol table for the names of all _module variables. Indexes here directly
  // correspond to entries in [variables].
  SymbolTable variableNames;
  // The name of the _module.
  ObjString* name;
}


// TODO: See if it's actually a perf improvement to have this in a separate
// struct instead of in ObjFn.
// Stores debugging information for a function used for things like stack
// traces.
struct FnDebug
{
  // The name of the function. Heap allocated and owned by the FnDebug.
  ZString name;
  // An array of line numbers. There is one element in this array for each
  // bytecode in the function's bytecode array. The value of that element is
  // the line in the source code that generated that instruction.
  IntBuffer sourceLines;
}

// A function object. It wraps and owns the bytecode and other debug information
// for a callable chunk of code.
//
// Function objects are not passed around and invoked directly. Instead, they
// are always referenced by an [ObjClosure] which is the real first-class
// representation of a function. This isn't strictly necessary if they function
// has no upvalues, but lets the rest of the VM assume all called objects will
// be closures.
struct ObjFn
{
  Obj obj;
  
  ByteBuffer code;
  ValueBuffer constants;
  // The _module where this function was defined.
  ObjModule* _module;
  // The maximum number of stack slots this function may use.
  int maxSlots;
  // The number of upvalues this function closes over.
  int numUpvalues;
  // The number of parameters this function expects. Used to ensure that .call
  // handles a mismatch between number of parameters and arguments. This will
  // only be set for fns, and not ObjFns that represent methods or scripts.
  int arity;
  FnDebug* debug;
}

// The type of a primitive function.
//
// Primitives are similar to foreign functions, but have more direct access to
// VM internals. It is passed the arguments in [args]. If it returns a value,
// it places it in `args[0]` and returns `true`. If it causes a runtime error
// or modifies the running fiber, it returns `false`.
alias Primitive = fn bool (WrenVM* vm, Value* args);

enum MethodType : inline int
{
  // A primitive method implemented in C in the VM. Unlike foreign methods,
  // this can directly manipulate the fiber's stack.
	PRIMITIVE,
  // A primitive that handles .call on Fn.
	FUNCTION_CALL,
  // A externally-defined C method.
	FOREIGN,
  // A normal user-defined method.
	BLOCK,
  // No method for the given symbol.
	NONE
}

// Tracks how this fiber has been invoked, aside from the ways that can be
// detected from the state of other fields in the fiber.
enum FiberState : inline int
{
  // The fiber is being run from another fiber using a call to `try()`.
  TRY,
  // The fiber was directly invoked by `runInterpreter()`. This means it's the
  // initial fiber used by a call to `wrenCall()` or `wrenInterpret()`.
  ROOT,
  // The fiber is invoked some other way. If [caller] is `NULL` then the fiber
  // was invoked using `call()`. If [numFrames] is zero, then the fiber has
  // finished running and is done. If [numFrames] is one and that frame's `ip`
  // points to the first byte of code, the fiber has not been started yet.
  OTHER,
}

struct Method
{
  MethodType type;

  // The method function itself. The [type] determines which field of the union
  // is used.
  union as
  {
    Primitive primitive;
    WrenForeignMethodFn foreign;
    ObjClosure* closure;
  }
}

// Identifies which specific type a heap-allocated object is.
enum ObjType : inline int 
{
	CLASS,
	CLOSURE,
	FIBER,
	FN,
	FOREIGN,
	INSTANCE,
	LIST,
	MAP,
	MODULE,
	RANGE,
	STRING,
	UPVALUE
}

struct Obj
{
  ObjType type;
  bool isDark;
  // The object's class.
  ObjClass* classObj;
  // The next object in the linked list of all currently allocated objects.
  Obj* next;
}

struct ObjClass
{
  Obj obj;
  ObjClass* superclass;
  // The number of fields needed for an instance of this class, including all
  // of its superclass fields.
  int numFields;
  // The table of methods that are defined in or inherited by this class.
  // Methods are called by symbol, and the symbol directly maps to an index in
  // this table. This makes method calls fast at the expense of empty cells in
  // the list for methods the class doesn't support.
  //
  // You can think of it as a hash table that never has collisions but has a
  // really low load factor. Since methods are pretty small (just a type and a
  // pointer), this should be a worthwhile trade-off.
  MethodBuffer methods;
  // The name of the class.
  ObjString* name;
  // The ClassAttribute for the class, if any
  Value attributes;
}


// The dynamically allocated data structure for a variable that has been used
// by a closure. Whenever a function accesses a variable declared in an
// enclosing function, it will get to it through this.
//
// An upvalue can be either "closed" or "open". An open upvalue points directly
// to a [Value] that is still stored on the fiber's stack because the local
// variable is still in scope in the function where it's declared.
//
// When that local variable goes out of scope, the upvalue pointing to it will
// be closed. When that happens, the value gets copied off the stack into the
// upvalue itself. That way, it can have a longer lifetime than the stack
// variable.
struct ObjUpvalue
{
  // The object header. Note that upvalues have this because they are garbage
  // collected, but they are not first class Wren objects.
  Obj obj;
  // Pointer to the variable this upvalue is referencing.
  Value* value;
  // If the upvalue is closed (i.e. the local variable it was pointing to has
  // been popped off the stack) then the closed-over value will be hoisted out
  // of the stack into here. [value] will then be changed to point to this.
  Value closed;
  // Open upvalues are stored in a linked list by the fiber. This points to the
  // next upvalue in that list.
  ObjUpvalue* next;
}

// An instance of a first-class function and the environment it has closed over.
// Unlike [ObjFn], this has captured the upvalues that the function accesses.
struct ObjClosure
{
  Obj obj;
  // The function that this closure is an instance of.
  ObjFn* func;
  // The upvalues this function has closed over.
  ObjUpvalue*[*] upvalues;
}

struct CallFrame
{
  // Pointer to the current (really next-to-be-executed) instruction in the
  // function's bytecode.
  CUChar* ip;
  // The closure being executed.
  ObjClosure* closure;
  // Pointer to the first stack slot used by this call frame. This will contain
  // the receiver, followed by the function's parameters, then local variables
  // and temporaries.
  Value* stackStart;
}

struct ObjFiber
{
  Obj obj;
  // The stack of value slots. This is used for holding local variables and
  // temporaries while the fiber is executing. It is heap-allocated and grown
  // as needed.
  Value* stack;
  // A pointer to one past the top-most value on the stack.
  Value* stackTop;
  // The number of allocated slots in the stack array.
  int stackCapacity;
  // The stack of call frames. This is a dynamic array that grows as needed but
  // never shrinks.
  CallFrame* frames;
  // The number of frames currently in use in [frames].
  int numFrames;
  // The number of [frames] allocated.
  int frameCapacity;
  // Pointer to the first node in the linked list of open upvalues that are
  // pointing to values still on the stack. The head of the list will be the
  // upvalue closest to the top of the stack, and then the list works downwards.
  ObjUpvalue* openUpvalues;
  // The fiber that ran this one. If this fiber is yielded, control will resume
  // to this one. May be `NULL`.
  ObjFiber* caller;
  // If the fiber failed because of a runtime error, this will contain the
  // error object. Otherwise, it will be null.
  Value error;
  FiberState state;
}


// A handle to a value, basically just a linked list of extra GC roots.
//
// Note that even non-heap-allocated values can be stored here.
struct WrenHandle
{
  Value value;
  WrenHandle* prev;
  WrenHandle* next;
}

// A single virtual machine for executing Wren code.
//
// Wren has no global state, so all state stored by a running interpreter lives
// here.
alias WrenVM = void*;
/*
struct WrenVM
{
  ObjClass* boolClass;
  ObjClass* classClass;
  ObjClass* fiberClass;
  ObjClass* fnClass;
  ObjClass* listClass;
  ObjClass* mapClass;
  ObjClass* nullClass;
  ObjClass* numClass;
  ObjClass* objectClass;
  ObjClass* rangeClass;
  ObjClass* stringClass;

  // The fiber that is currently running.
  ObjFiber* fiber;

  // The loaded modules. Each key is an ObjString (except for the main _module,
  // whose key is null) for the _module's name and the value is the ObjModule
  // for the _module.
  ObjMap* modules;
  
  // The most recently imported _module. More specifically, the _module whose
  // code has most recently finished executing.
  //
  // Not treated like a GC root since the _module is already in [modules].
  ObjModule* lastModule;

  // Memory management data:

  // The number of bytes that are known to be currently allocated. Includes all
  // memory that was proven live after the last GC, as well as any new bytes
  // that were allocated since then. Does *not* include bytes for objects that
  // were freed since the last GC.
  usz bytesAllocated;

  // The number of total allocated bytes that will trigger the next GC.
  usz nextGC;

  // The first object in the linked list of all currently allocated objects.
  Obj* first;

  // The "gray" set for the garbage collector. This is the stack of unprocessed
  // objects while a garbage collection pass is in process.
  Obj** gray;
  int grayCount;
  int grayCapacity;

  // The list of temporary roots. This is for temporary or new objects that are
  // not otherwise reachable but should not be collected.
  //
  // They are organized as a stack of pointers stored in this array. This
  // implies that temporary roots need to have stack semantics: only the most
  // recently pushed object can be released.
  Obj*[WREN_MAX_TEMP_ROOTS] tempRoots;

  int numTempRoots;
  
  // Pointer to the first node in the linked list of active handles or NULL if
  // there are none.
  WrenHandle* handles;
  
  // Pointer to the bottom of the range of stack slots available for use from
  // the C API. During a foreign method, this will be in the stack of the fiber
  // that is executing a method.
  //
  // If not in a foreign method, this is initially NULL. If the user requests
  // slots by calling wrenEnsureSlots(), a stack is created and this is
  // initialized.
  Value* apiStack;

  WrenConfiguration config;
  
  // Compiler and debugger data:

  // The compiler that is currently compiling code. This is used so that heap
  // allocated objects used by the compiler can be found if a GC is kicked off
  // in the middle of a compile.
  Compiler* compiler;

  // There is a single global symbol table for all method names on all classes.
  // Method calls are dispatched directly by index in this table.
  SymbolTable methodNames;
}
*/

// The different signature syntaxes for different kinds of methods.
enum SignatureType : inline int
{
  // A name followed by a (possibly empty) parenthesized parameter list. Also
  // used for binary operators.
  METHOD,
  // Just a name. Also used for unary operators.
  GETTER,
  // A name followed by "=".
  SETTER,
  // A square bracketed parameter list.
  SUBSCRIPT,
  // A square bracketed parameter list followed by "=".
  SUBSCRIPT_SETTER,
  // A constructor initializer function. This has a distinct signature to
  // prevent it from being invoked directly outside of the constructor on the
  // metaclass.
  INITIALIZER
}

struct Signature
{
  ZString name;
  int length;
  SignatureType type;
  int arity;
}

// Bookkeeping information for compiling a class definition.
struct ClassInfo
{
  // The name of the class.
  ObjString* name;
  
  // Attributes for the class itself
  ObjMap* classAttributes;
  // Attributes for methods in this class
  ObjMap* methodAttributes;

  // Symbol table for the fields of the class.
  SymbolTable fields;

  // Symbols for the methods defined by the class. Used to detect duplicate
  // method definitions.
  IntBuffer methods;
  IntBuffer staticMethods;

  // True if the class being compiled is a foreign class.
  bool isForeign;
  
  // True if the current method being compiled is static.
  bool inStatic;

  // The signature of the method being compiled.
  Signature* signature;
}

///////////////////////////////////// compiler //////////////////////////////////////
struct Compiler
{
  Parser* parser;
  // The compiler for the function enclosing this one, or NULL if it's the
  // top level.
  Compiler* parent;
  // The currently in scope local variables.
  Local[MAX_LOCALS] locals;
  // The number of local variables currently in scope.
  int numLocals;
  // The upvalues that this function has captured from outer scopes. The count
  // of them is stored in [numUpvalues].
  CompilerUpvalue[MAX_UPVALUES] upvalues;

  // The current level of block scope nesting, where zero is no nesting. A -1
  // here means top-level code is being compiled and there is no block scope
  // in effect at all. Any variables declared will be _module-level.
  int scopeDepth;
  
  // The current number of slots (locals and temporaries) in use.
  //
  // We use this and maxSlots to track the maximum number of additional slots
  // a function may need while executing. When the function is called, the
  // fiber will check to ensure its stack has enough room to cover that worst
  // case and grow the stack if needed.
  //
  // This value here doesn't include parameters to the function. Since those
  // are already pushed onto the stack by the caller and tracked there, we
  // don't need to double count them here.
  int numSlots;

  // The current innermost loop being compiled, or NULL if not in a loop.
  Loop* loop;

  // If this is a compiler for a method, keeps track of the class enclosing it.
  ClassInfo* enclosingClass;

  // The function being compiled.
  ObjFn* func;
  
  // The constants for the function being compiled.
  ObjMap* constants;

  // Whether or not the compiler is for a constructor initializer
  bool isInitializer;

  // The number of attributes seen while parsing.
  // We track this separately as compile time attributes
  // are not stored, so we can't rely on attributes->count
  // to enforce an error message when attributes are used
  // anywhere other than methods or classes.
  int numAttributes;
  // Attributes for the next class or method.
  ObjMap* attributes;
}

struct Parser
{
  WrenVM* vm;
  // The _module being parsed.
  ObjModule* _module;

  // The source code being parsed.
  ZString source;
  // The beginning of the currently-being-lexed token in [source].
  ZString tokenStart;
  // The current character being lexed in [source].
  ZString currentChar;
  // The 1-based line number of [currentChar].
  int currentLine;
  // The upcoming token.
  Token next;
  // The most recently lexed token.
  Token current;
  // The most recently consumed/advanced token.
  Token previous;
  // Tracks the lexing state when tokenizing interpolated strings.
  //
  // Interpolated strings make the lexer not strictly regular: we don't know
  // whether a ")" should be treated as a RIGHT_PAREN token or as ending an
  // interpolated expression unless we know whether we are inside a string
  // interpolation and how many unmatched "(" there are. This is particularly
  // complex because interpolation can nest:
  //
  //     " %( " %( inner ) " ) "
  //
  // This tracks that state. The parser maintains a stack of ints, one for each
  // level of current interpolation nesting. Each value is the number of
  // unmatched "(" that are waiting to be closed.
  int[MAX_INTERPOLATION_NESTING] parens;
  int numParens;
  // Whether compile errors should be printed to stderr or discarded.
  bool printErrors;
  // If a syntax or compile error has occurred.
  bool hasError;
}

struct Local
{
  // The name of the local variable. This points directly into the original
  // source code string.
  ZString name;
  // The length of the local variable's name.
  int length;
  // The depth in the scope chain that this variable was declared at. Zero is
  // the outermost scope--parameters for a method, or the first local block in
  // top level code. One is the scope within that, etc.
  int depth;
  // If this local variable is being used as an upvalue.
  bool isUpvalue;
}

struct CompilerUpvalue
{
  // True if this upvalue is capturing a local variable from the enclosing
  // function. False if it's capturing an upvalue.
  bool isLocal;
  // The index of the local or upvalue being captured in the enclosing function.
  int index;
}

// Bookkeeping information for the current loop being compiled.
struct Loop
{
  // Index of the instruction that the loop should jump back to.
  int start;
  // Index of the argument for the CODE_JUMP_IF instruction used to exit the
  // loop. Stored so we can patch it once we know where the loop ends.
  int exitJump;
  // Index of the first instruction of the body of the loop.
  int body;
  // Depth of the scope(s) that need to be exited if a break is hit inside the
  // loop.
  int scopeDepth;
  // The loop enclosing this one, or NULL if this is the outermost loop.
  Loop* enclosing;
}

enum TokenType : inline int
{
	LEFT_PAREN,
	RIGHT_PAREN,
	LEFT_BRACKET,
	RIGHT_BRACKET,
	LEFT_BRACE,
	RIGHT_BRACE,
	COLON,
	DOT,
	DOTDOT,
	DOTDOTDOT,
	COMMA,
	STAR,
	SLASH,
	PERCENT,
	HASH,
	PLUS,
	MINUS,
	LTLT,
	GTGT,
	PIPE,
	PIPEPIPE,
	CARET,
	AMP,
	AMPAMP,
	BANG,
	TILDE,
	QUESTION,
	EQ,
	LT,
	GT,
	LTEQ,
	GTEQ,
	EQEQ,
	BANGEQ,

	BREAK,
	CONTINUE,
	CLASS,
	CONSTRUCT,
	ELSE,
	FALSE,
	FOR,
	FOREIGN,
	IF,
	IMPORT,
	AS,
	IN,
	IS,
	NULL,
	RETURN,
	STATIC,
	SUPER,
	THIS,
	TRUE,
	VAR,
	WHILE,

	FIELD,
	STATIC_FIELD,
	NAME,
	NUMBER,
  
  // A string literal without any interpolation, or the last section of a
  // string following the last interpolated expression.
	STRING,
  
  // A portion of a string literal preceding an interpolated expression. This
  // string:
  //
  //     "a %(b) c %(d) e"
  //
  // is tokenized to:
  //
  //     TOKEN_INTERPOLATION "a "
  //     TOKEN_NAME          b
  //     TOKEN_INTERPOLATION " c "
  //     TOKEN_NAME          d
  //     TOKEN_STRING        " e"
	INTERPOLATION,

	LINE,

	ERROR,
	EOF
}

struct Token
{
  TokenType type;
  // The beginning of the token, pointing directly into the source.
  ZString start;
  // The length of the token in characters.
  int length;
  // The 1-based line where the token appears.
  int line;
  // The parsed value if the token is a literal.
  Value value;
}

// A handle to a Wren object.
//
// This lets code outside of the VM hold a persistent reference to an object.
// After a handle is acquired, and until it is released, this ensures the
// garbage collector will not reclaim the object it references.
//typedef struct WrenHandle WrenHandle;

// A generic allocation function that handles all explicit memory management
// used by Wren. It's used like so:
//
// - To allocate new memory, [memory] is NULL and [newSize] is the desired
//   size. It should return the allocated memory or NULL on failure.
//
// - To attempt to grow an existing allocation, [memory] is the memory, and
//   [newSize] is the desired size. It should return [memory] if it was able to
//   grow it in place, or a new pointer if it had to move it.
//
// - To shrink memory, [memory] and [newSize] are the same as above but it will
//   always return [memory].
//
// - To free memory, [memory] will be the memory to free and [newSize] will be
//   zero. It should return NULL.
alias WrenReallocateFn = fn void* (void* memory, usz newSize, void* userData);

// A function callable from Wren code, but implemented in C3.
alias WrenForeignMethodFn = fn void (WrenVM* vm);

// A finalizer function for freeing resources owned by an instance of a foreign
// class. Unlike most foreign methods, finalizers do not have access to the VM
// and should not interact with it since it's in the middle of a garbage
// collection.
alias WrenFinalizerFn = fn void (void* data);

// Gives the host a chance to canonicalize the imported _module name,
// potentially taking into account the (previously resolved) name of the _module
// that contains the import. Typically, this is used to implement relative
// imports.
alias WrenResolveModuleFn = fn ZString (WrenVM* vm, ZString importer, ZString name);

// Called after loadModuleFn is called for _module [name]. The original returned result
// is handed back to you in this callback, so that you can free memory if appropriate.
alias WrenLoadModuleCompleteFn = fn void (WrenVM* vm, ZString name, WrenLoadModuleResult result);

// The result of a loadModuleFn call. 
// [source] is the source code for the _module, or NULL if the _module is not found.
// [onComplete] an optional callback that will be called once Wren is done with the result.
struct WrenLoadModuleResult
{
  ZString source;
  WrenLoadModuleCompleteFn onComplete;
  void* userData;
}

// Loads and returns the source code for the _module [name].
alias WrenLoadModuleFn = fn WrenLoadModuleResult (WrenVM* vm, ZString name);

// Returns a pointer to a foreign method on [className] in [_module] with
// [signature].
alias WrenBindForeignMethodFn = fn WrenForeignMethodFn (WrenVM* vm,
    ZString _module, ZString className, bool isStatic,
    ZString signature);

// Displays a string of text to the user.
alias WrenWriteFn = fn void (WrenVM* vm, ZString text);

// TODO make this faults?
alias WrenErrorType = int;
  // A syntax or resolution error detected at compile time.
const WrenErrorType ERROR_COMPILE = 0;
  // The error message for a runtime error.
const WrenErrorType ERROR_RUNTIME = 1;
  // One entry of a runtime error's stack trace.
const WrenErrorType ERROR_STACK_TRACE = 2;

// Reports an error to the user.
//
// An error detected during compile time is reported by calling this once with
// [type] `WREN_ERROR_COMPILE`, the resolved name of the [_module] and [line]
// where the error occurs, and the compiler's error [message].
//
// A runtime error is reported by calling this once with [type]
// `WREN_ERROR_RUNTIME`, no [_module] or [line], and the runtime error's
// [message]. After that, a series of [type] `WREN_ERROR_STACK_TRACE` calls are
// made for each line in the stack trace. Each of those has the resolved
// [_module] and [line] where the method or function is defined and [message] is
// the name of the method or function.
alias WrenErrorFn = fn void (WrenVM* vm, WrenErrorType type, ZString _module, int line, ZString message);

struct WrenForeignClassMethods
{
  // The callback invoked when the foreign object is created.
  //
  // This must be provided. Inside the body of this, it must call
  // [wrenSetSlotNewForeign()] exactly once.
  WrenForeignMethodFn allocate;

  // The callback invoked when the garbage collector is about to collect a
  // foreign object's memory.
  //
  // This may be `NULL` if the foreign class does not need to finalize.
  WrenFinalizerFn finalize;
}

// Returns a pair of pointers to the foreign methods used to allocate and
// finalize the data for instances of [className] in resolved [_module].
alias WrenBindForeignClassFn = fn WrenForeignClassMethods (WrenVM* vm, ZString _module, ZString className);

struct WrenConfiguration
{
  // The callback Wren will use to allocate, reallocate, and deallocate memory.
  //
  // If `NULL`, defaults to a built-in function that uses `realloc` and `free`.
  WrenReallocateFn reallocateFn;

  // The callback Wren uses to resolve a _module name.
  //
  // Some host applications may wish to support "relative" imports, where the
  // meaning of an import string depends on the _module that contains it. To
  // support that without baking any policy into Wren itself, the VM gives the
  // host a chance to resolve an import string.
  //
  // Before an import is loaded, it calls this, passing in the name of the
  // _module that contains the import and the import string. The host app can
  // look at both of those and produce a new "canonical" string that uniquely
  // identifies the _module. This string is then used as the name of the _module
  // going forward. It is what is passed to [loadModuleFn], how duplicate
  // imports of the same _module are detected, and how the _module is reported in
  // stack traces.
  //
  // If you leave this function NULL, then the original import string is
  // treated as the resolved string.
  //
  // If an import cannot be resolved by the embedder, it should return NULL and
  // Wren will report that as a runtime error.
  //
  // Wren will take ownership of the string you return and free it for you, so
  // it should be allocated using the same allocation function you provide
  // above.
  WrenResolveModuleFn resolveModuleFn;

  // The callback Wren uses to load a _module.
  //
  // Since Wren does not talk directly to the file system, it relies on the
  // embedder to physically locate and read the source code for a _module. The
  // first time an import appears, Wren will call this and pass in the name of
  // the _module being imported. The method will return a result, which contains
  // the source code for that _module. Memory for the source is owned by the 
  // host application, and can be freed using the onComplete callback.
  //
  // This will only be called once for any given _module name. Wren caches the
  // result internally so subsequent imports of the same _module will use the
  // previous source and not call this.
  //
  // If a _module with the given name could not be found by the embedder, it
  // should return NULL and Wren will report that as a runtime error.
  WrenLoadModuleFn loadModuleFn;

  // The callback Wren uses to find a foreign method and bind it to a class.
  //
  // When a foreign method is declared in a class, this will be called with the
  // foreign method's _module, class, and signature when the class body is
  // executed. It should return a pointer to the foreign function that will be
  // bound to that method.
  //
  // If the foreign function could not be found, this should return NULL and
  // Wren will report it as runtime error.
  WrenBindForeignMethodFn bindForeignMethodFn;

  // The callback Wren uses to find a foreign class and get its foreign methods.
  //
  // When a foreign class is declared, this will be called with the class's
  // _module and name when the class body is executed. It should return the
  // foreign functions uses to allocate and (optionally) finalize the bytes
  // stored in the foreign object when an instance is created.
  WrenBindForeignClassFn bindForeignClassFn;

  // The callback Wren uses to display text when `System.print()` or the other
  // related functions are called.
  //
  // If this is `NULL`, Wren discards any printed text.
  WrenWriteFn writeFn;

  // The callback Wren uses to report errors.
  //
  // When an error occurs, this will be called with the _module name, line
  // number, and an error message. If this is `NULL`, Wren doesn't report any
  // errors.
  WrenErrorFn errorFn;

  // The number of bytes Wren will allocate before triggering the first garbage
  // collection.
  //
  // If zero, defaults to 10MB.
  usz initialHeapSize;

  // After a collection occurs, the threshold for the next collection is
  // determined based on the number of bytes remaining in use. This allows Wren
  // to shrink its memory usage automatically after reclaiming a large amount
  // of memory.
  //
  // This can be used to ensure that the heap does not get too small, which can
  // in turn lead to a large number of collections afterwards as the heap grows
  // back to a usable size.
  //
  // If zero, defaults to 1MB.
  usz minHeapSize;

  // Wren will resize the heap automatically as the number of bytes
  // remaining in use after a collection changes. This number determines the
  // amount of additional memory Wren will use after a collection, as a
  // percentage of the current heap size.
  //
  // For example, say that this is 50. After a garbage collection, when there
  // are 400 bytes of memory still in use, the next collection will be triggered
  // after a total of 600 bytes are allocated (including the 400 already in
  // use.)
  //
  // Setting this to a smaller number wastes less memory, but triggers more
  // frequent garbage collections.
  //
  // If zero, defaults to 50.
  int heapGrowthPercent;

  // User-defined data associated with the VM.
  void* userData;
}

// todo makes this into faults?
typedef WrenInterpretResult = int;
const WrenInterpretResult RESULT_SUCCESS = 0;
const WrenInterpretResult RESULT_COMPILE_ERROR = 1;
const WrenInterpretResult RESULT_RUNTIME_ERROR = 2;

// The type of an object stored in a slot.
//
// This is not necessarily the object's *class*, but instead its low level
// representation type.
enum WrenType : inline int
{
	BOOL,
	NUM,
	FOREIGN,
	LIST,
	MAP,
	NULL,
	STRING,

  // The object is of a type that isn't accessible by the C API.
	UNKNOWN
}

// Get the current wren version number.
//
// Can be used to range checks over versions.
extern fn int getVersionNumber() @extern("wrenGetVersionNumber");

// Initializes [configuration] with all of its default values.
//
// Call this before setting the particular fields you care about.
extern fn  void WrenConfiguration.init(&self) @extern("wrenInitConfiguration");

// Creates a new Wren virtual machine using the given [configuration]. Wren
// will copy the configuration data, so the argument passed to this can be
// freed after calling this. If [configuration] is `NULL`, uses a default
// configuration.
extern fn  WrenVM* WrenConfiguration.newVM(&self) @extern("wrenNewVM");

// Disposes of all resources is use by [vm], which was previously created by a
// call to [wrenNewVM].
extern fn  void WrenVM.free(&self) @extern("wrenFreeVM");

// Immediately run the garbage collector to free unused memory.
extern fn  void WrenVM.collectGarbage(&self) @extern("wrenCollectGarbage");

// Runs [source], a string of Wren source code in a new fiber in [vm] in the
// context of resolved [_module].
extern fn  WrenInterpretResult WrenVM.interpret(&self, ZString _module, ZString source) @extern("wrenInterpret");

// Creates a handle that can be used to invoke a method with [signature] on
// using a receiver and arguments that are set up on the stack.
//
// This handle can be used repeatedly to directly invoke that method from C
// code using [wrenCall].
//
// When you are done with this handle, it must be released using
// [wrenReleaseHandle].
extern fn  WrenHandle* WrenVM.makeCallHandle(&self, ZString signature) @extern("wrenMakeCallHandle");

// Calls [method], using the receiver and arguments previously set up on the
// stack.
//
// [method] must have been created by a call to [wrenMakeCallHandle]. The
// arguments to the method must be already on the stack. The receiver should be
// in slot 0 with the remaining arguments following it, in order. It is an
// error if the number of arguments provided does not match the method's
// signature.
//
// After this returns, you can access the return value from slot 0 on the stack.
extern fn  WrenInterpretResult WrenVM.call(&self, WrenHandle* method) @extern("wrenCall");

// Releases the reference stored in [handle]. After calling this, [handle] can
// no longer be used.
extern fn  void WrenVM.releaseHandle(&self, WrenHandle* handle) @extern("wrenReleaseHandle");

// The following functions are intended to be called from foreign methods or
// finalizers. The interface Wren provides to a foreign method is like a
// register machine: you are given a numbered array of slots that values can be
// read from and written to. Values always live in a slot (unless explicitly
// captured using wrenGetSlotHandle(), which ensures the garbage collector can
// find them.
//
// When your foreign function is called, you are given one slot for the receiver
// and each argument to the method. The receiver is in slot 0 and the arguments
// are in increasingly numbered slots after that. You are free to read and
// write to those slots as you want. If you want more slots to use as scratch
// space, you can call wrenEnsureSlots() to add more.
//
// When your function returns, every slot except slot zero is discarded and the
// value in slot zero is used as the return value of the method. If you don't
// store a return value in that slot yourself, it will retain its previous
// value, the receiver.
//
// While Wren is dynamically typed, C is not. This means the C interface has to
// support the various types of primitive values a Wren variable can hold: bool,
// double, string, etc. If we supported this for every operation in the C API,
// there would be a combinatorial explosion of functions, like "get a
// double-valued element from a list", "insert a string key and double value
// into a map", etc.
//
// To avoid that, the only way to convert to and from a raw C value is by going
// into and out of a slot. All other functions work with values already in a
// slot. So, to add an element to a list, you put the list in one slot, and the
// element in another. Then there is a single API function wrenInsertInList()
// that takes the element out of that slot and puts it into the list.
//
// The goal of this API is to be easy to use while not compromising performance.
// The latter means it does not do type or bounds checking at runtime except
// using assertions which are generally removed from release builds. C is an
// unsafe language, so it's up to you to be careful to use it correctly. In
// return, you get a very fast FFI.

// Returns the number of slots available to the current foreign method.
extern fn  int WrenVM.getSlotCount(WrenVM* vm) @extern("wrenGetSlotCount");

// Ensures that the foreign method stack has at least [numSlots] available for
// use, growing the stack if needed.
//
// Does not shrink the stack if it has more than enough slots.
//
// It is an error to call this from a finalizer.
extern fn  void WrenVM.ensureSlots(WrenVM* vm, int numSlots) @extern("wrenEnsureSlots");

// Gets the type of the object in [slot].
extern fn  WrenType WrenVM.getSlotType(WrenVM* vm, int slot) @extern("wrenGetSlotType");

// Reads a boolean value from [slot].
//
// It is an error to call this if the slot does not contain a boolean value.
extern fn  bool WrenVM.getSlotBool(WrenVM* vm, int slot) @extern("wrenGetSlotBool");

// Reads a byte array from [slot].
//
// The memory for the returned string is owned by Wren. You can inspect it
// while in your foreign method, but cannot keep a pointer to it after the
// function returns, since the garbage collector may reclaim it.
//
// Returns a pointer to the first byte of the array and fill [length] with the
// number of bytes in the array.
//
// It is an error to call this if the slot does not contain a string.
extern fn  ZString WrenVM.getSlotBytes(WrenVM* vm, int slot, int* length) @extern("wrenGetSlotBytes");

// Reads a number from [slot].
//
// It is an error to call this if the slot does not contain a number.
extern fn  double WrenVM.getSlotDouble(WrenVM* vm, int slot) @extern("wrenGetSlotDouble");

// Reads a foreign object from [slot] and returns a pointer to the foreign data
// stored with it.
//
// It is an error to call this if the slot does not contain an instance of a
// foreign class.
extern fn  void* WrenVM.getSlotForeign(WrenVM* vm, int slot) @extern("wrenGetSlotForeign");

// Reads a string from [slot].
//
// The memory for the returned string is owned by Wren. You can inspect it
// while in your foreign method, but cannot keep a pointer to it after the
// function returns, since the garbage collector may reclaim it.
//
// It is an error to call this if the slot does not contain a string.
extern fn  ZString WrenVM.getSlotString(WrenVM* vm, int slot) @extern("wrenGetSlotString");

// Creates a handle for the value stored in [slot].
//
// This will prevent the object that is referred to from being garbage collected
// until the handle is released by calling [wrenReleaseHandle()].
extern fn  WrenHandle* WrenVM.getSlotHandle(WrenVM* vm, int slot) @extern("wrenGetSlotHandle");

// Stores the boolean [value] in [slot].
extern fn  void WrenVM.setSlotBool(WrenVM* vm, int slot, bool value) @extern("wrenSetSlotBool");

// Stores the array [length] of [bytes] in [slot].
//
// The bytes are copied to a new string within Wren's heap, so you can free
// memory used by them after this is called.
extern fn  void WrenVM.setSlotBytes(WrenVM* vm, int slot, ZString bytes, usz length) @extern("wrenSetSlotBytes");

// Stores the numeric [value] in [slot].
extern fn  void WrenVM.setSlotDouble(WrenVM* vm, int slot, double value) @extern("wrenSetSlotDouble");

// Creates a new instance of the foreign class stored in [classSlot] with [size]
// bytes of raw storage and places the resulting object in [slot].
//
// This does not invoke the foreign class's constructor on the new instance. If
// you need that to happen, call the constructor from Wren, which will then
// call the allocator foreign method. In there, call this to create the object
// and then the constructor will be invoked when the allocator returns.
//
// Returns a pointer to the foreign object's data.
extern fn  void* WrenVM.setSlotNewForeign(WrenVM* vm, int slot, int classSlot, usz size) @extern("wrenSetSlotNewForeign");

// Stores a new empty list in [slot].
extern fn  void WrenVM.setSlotNewList(WrenVM* vm, int slot) @extern("wrenSetSlotNewList");

// Stores a new empty map in [slot].
extern fn  void WrenVM.setSlotNewMap(WrenVM* vm, int slot) @extern("wrenSetSlotNewMap");

// Stores null in [slot].
extern fn  void WrenVM.setSlotNull(WrenVM* vm, int slot) @extern("wrenSetSlotNull");

// Stores the string [text] in [slot].
//
// The [text] is copied to a new string within Wren's heap, so you can free
// memory used by it after this is called. The length is calculated using
// [strlen()]. If the string may contain any null bytes in the middle, then you
// should use [wrenSetSlotBytes()] instead.
extern fn  void WrenVM.setSlotString(WrenVM* vm, int slot, ZString text) @extern("wrenSetSlotString");

// Stores the value captured in [handle] in [slot].
//
// This does not release the handle for the value.
extern fn  void WrenVM.setSlotHandle(WrenVM* vm, int slot, WrenHandle* handle) @extern("wrenSetSlotHandle");

// Returns the number of elements in the list stored in [slot].
extern fn  int WrenVM.getListCount(WrenVM* vm, int slot) @extern("wrenGetListCount");

// Reads element [index] from the list in [listSlot] and stores it in
// [elementSlot].
extern fn  void WrenVM.getListElement(WrenVM* vm, int listSlot, int index, int elementSlot) @extern("wrenGetListElement");

// Sets the value stored at [index] in the list at [listSlot], 
// to the value from [elementSlot]. 
extern fn  void WrenVM.setListElement(WrenVM* vm, int listSlot, int index, int elementSlot) @extern("wrenSetListElement");

// Takes the value stored at [elementSlot] and inserts it into the list stored
// at [listSlot] at [index].
//
// As in Wren, negative indexes can be used to insert from the end. To append
// an element, use `-1` for the index.
extern fn  void WrenVM.insertInList(WrenVM* vm, int listSlot, int index, int elementSlot) @extern("wrenInsertInList");

// Returns the number of entries in the map stored in [slot].
extern fn  int WrenVM.getMapCount(WrenVM* vm, int slot) @extern("wrenGetMapCount");

// Returns true if the key in [keySlot] is found in the map placed in [mapSlot].
extern fn  bool WrenVM.getMapContainsKey(WrenVM* vm, int mapSlot, int keySlot) @extern("wrenGetMapContainsKey");

// Retrieves a value with the key in [keySlot] from the map in [mapSlot] and
// stores it in [valueSlot].
extern fn  void WrenVM.getMapValue(WrenVM* vm, int mapSlot, int keySlot, int valueSlot) @extern("wrenGetMapValue");

// Takes the value stored at [valueSlot] and inserts it into the map stored
// at [mapSlot] with key [keySlot].
extern fn  void WrenVM.setMapValue(WrenVM* vm, int mapSlot, int keySlot, int valueSlot) @extern("wrenSetMapValue");

// Removes a value from the map in [mapSlot], with the key from [keySlot],
// and place it in [removedValueSlot]. If not found, [removedValueSlot] is
// set to null, the same behaviour as the Wren Map API.
extern fn  void WrenVM.removeMapValue(WrenVM* vm, int mapSlot, int keySlot,
                        int removedValueSlot) @extern("wrenRemoveMapValue");

// Looks up the top level variable with [name] in resolved [_module] and stores
// it in [slot].
extern fn  void WrenVM.getVariable(WrenVM* vm, ZString _module, ZString name, int slot) @extern("wrenGetVariable");

// Looks up the top level variable with [name] in resolved [_module], 
// returns false if not found. The _module must be imported at the time, 
// use wrenHasModule to ensure that before calling.
extern fn  bool WrenVM.hasVariable(WrenVM* vm, ZString _module, ZString name) @extern("wrenHasVariable");

// Returns true if [_module] has been imported/resolved before, false if not.
extern fn  bool WrenVM.hasModule(WrenVM* vm, ZString _module) @extern("wrenHasModule");

// Sets the current fiber to be aborted, and uses the value in [slot] as the
// runtime error object.
extern fn  void WrenVM.abortFiber(WrenVM* vm, int slot) @extern("wrenAbortFiber");

// Returns the user data associated with the WrenVM.
extern fn  void* WrenVM.getUserData(WrenVM* vm) @extern("wrenGetUserData");

// Sets user data associated with the WrenVM.
extern fn  void WrenVM.setUserData(WrenVM* vm, void* userData) @extern("wrenSetUserData");
