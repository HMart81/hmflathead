/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/



/*
    BASIC DOC:
    
==== Units ====
    Box2D works with floating point numbers and tolerances have to be used to make Box2D perform well. 
    These tolerances have been tuned to work well with meters-kilogram-second (MKS) units. 
    In particular, Box2D has been tuned to work well with moving shapes between 0.1 and 10 meters. 
    So this means objects between soup cans and buses in size should work well. 
    Static shapes may be up to 50 meters long without trouble. If you have a large world, you should split it up into multiple static bodies.

    Being a 2D physics engine, it is tempting to use pixels as your units.
    Unfortunately this will lead to a poor simulation and possibly weird behavior. 
    An object of length 200 pixels would be seen by Box2D as the size of a 45 story building.
    
    ******************************************************************************************
    * â€Caution:                                                                               *
    * - Box2D is tuned for MKS units. Keep the size of moving objects larger than 10cm.      *
    *   You'll need to use some scaling system when you render your environment and actors.  *
    *   The Box2D samples application does this by using an OpenGL viewport transform.       *
    *   DO NOT USE PIXEL UNITS for box2D unless you understand the implications.             *
    * - Box2D uses radians, not degrees.                                                     *
    * - Box2D works best with world sizes less than 12 kilometers.                           *
    ******************************************************************************************
    
    Hello World Example at @ https://box2d.org/documentation/hello.html#autotoc_md21

    More examples at @ https://box2d.org/documentation/examples.html

    Not box2d docs but could be usefull, at @ https://libgdx.com/wiki/extensions/physics/box2d#initialization

    UNFINISHED see https://box2d.org/documentation/hello.html#autotoc_md21 
    to get the necessary basic code for minimal support
*/

// box2d include file
module engine::physics::box2d;

import std::math::vector; // c3 math for Vec2f
import engine::misc; // for Exported tag
import thirdparty::raylib5::rl;

// region BASE

// if there's any desire to override the internal box2d memory allocator and assert function
alias B2AllocCallback  = fn void*(uint size, int alignment);
alias B2FreeCallback   = fn void(void* mem);
alias B2AssertCallback = fn int(ZString condition, ZString fileName, int lineNumber);
 
fn void setAllocator( B2AllocCallback* allocFcn, B2FreeCallback* freeFcn ) @cname("b2SetAllocator");
fn int  getByteCount() @cname("b2GetByteCount");
fn void setAssertFcn( B2AssertCallback* assertFcn ) @cname("b2SetAssertFcn");
 
struct B2Version @compact
{
    int major;
    int minor;
    int revision;
}

fn B2Version getVersion() @cname("b2GetVersion");
 
// Timer for profiling. This has platform specific code and may not work on every platform.
struct B2Timer
{
    long start       @if(env::WIN32);
    ulong start_sec  @if(env::LINUX || env::POSIX);
    ulong start_usec @if(env::LINUX || env::POSIX);
    int dummy        @if(!env::WIN32 && !env::LINUX && !env::POSIX);
}
 
fn B2Timer createTimer() @cname("b2CreateTimer");
fn long B2Timer.getTicks( B2Timer* timer ) @cname("b2GetTicks");
fn float B2Timer.getMilliseconds( B2Timer* timer ) @cname("b2GetMilliseconds");
fn float B2Timer.getMillisecondsAndReset( B2Timer* timer ) @cname("b2GetMillisecondsAndReset");
fn void sleepMilliseconds( int milliseconds ) @cname("b2SleepMilliseconds");
fn void yield() @cname("b2Yield");
 
// Simple djb2 hash function for determinism testing
const B2_HASH_INIT = 5381;

alias UInt8 @local = char;
fn uint hash( uint hash, UInt8* data, int count ) @cname("b2Hash");

// end_region BASE

// region id

struct B2WorldId @compact
{
    ushort	index1;	
    ushort revision;
}

// Body id references a body instance. This should be treated as an opaque handle.
struct B2BodyId 
{
    int	index1;	
    ushort revision;	
    ushort	world0;
}

struct B2ShapeId @compact
{
    int index1;
    ushort world0;
    ushort revision;
}

struct B2JointId @compact
{
    int index1;
    ushort world0;
    ushort revision;
}

struct B2ChainId @compact
{
    int index1;
    ushort world0;
    ushort revision;
}

//alias ZERO_INIT = {};
const B2WorldId NULL_WORLD_ID @local = {};
const B2BodyId  NULL_BODY_ID  @local = {};
const B2ShapeId NULL_SHAPE_ID @local = {};
const B2JointId NULL_JOINT_ID @local = {};
const B2ChainId NULL_CHAIN_ID @local = {};

macro bool @is_null(#id) => #id.index1 == 0;

macro bool @is_non_null(#id) => #id.index1 != 0;

macro bool @id_equals(#id1, #id2 ) => (#id1.index1 == #id2.index1 && #id1.world0 == #id2.world0 && #id1.revision == #id2.revision);
// end_region id

// region TYPES
 
alias B2TaskCallback        = fn void(int startIndex, int endIndex, uint workerIndex, void* taskContext);
alias B2EnqueueTaskCallback = fn void*(B2TaskCallback* task, int itemCount, int minRange, void* taskContext, void* userContext);
alias B2FinishTaskCallback  = fn void(void* userTask, void* userContext);
 
struct B2RayResult
{
    B2ShapeId shapeId;
    B2Vec2 point;
    B2Vec2 normal;
    float fraction;
    bool hit;
}
 
/// World definition used to create a simulation world.
/// Must be initialized using defaultWorldDef().
struct B2WorldDef
{
	/// Gravity vector. Box2D has no up-vector defined.
	B2Vec2 gravity;

	/// Restitution velocity threshold, usually in m/s. Collisions above this
	/// speed have restitution applied (will bounce).
	float restitutionThreshold;

	/// This parameter controls how fast overlap is resolved and has units of meters per second
	float contactPushoutVelocity;

	/// Threshold velocity for hit events. Usually meters per second.
	float hitEventThreshold;

	/// Contact stiffness. Cycles per second.
	float contactHertz;

	/// Contact bounciness. Non-dimensional.
	float contactDampingRatio;

	/// Joint stiffness. Cycles per second.
	float jointHertz;

	/// Joint bounciness. Non-dimensional.
	float jointDampingRatio;

	/// Maximum linear velocity. Usually meters per second.
	float maximumLinearVelocity;

	/// Can bodies go to sleep to improve performance
	bool enableSleep;

	/// Enable continuous collision
	bool enableContinous;

	/// Number of workers to use with the provided task system. Box2D performs best when using only
	///	performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide
	///	little benefit and may even harm performance.
	int workerCount;

	/// Function to spawn tasks
	B2EnqueueTaskCallback* enqueueTask;

	/// Function to finish a task
	B2FinishTaskCallback* finishTask;

	/// User context that is provided to enqueueTask and finishTask
	void* userTaskContext;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}
 
fn B2WorldDef defaultWorldDef() @cname("b2DefaultWorldDef");
 
alias B2BodyType = int;
const B2BodyType STATIC    = 0; // zero mass, zero velocity, may be manually moved
const B2BodyType KINEMATIC = 1; // zero mass, velocity set by user, moved by solver
const B2BodyType DYNAMIC   = 2; // positive mass, velocity determined by forces, moved by solver
 
/// A body definition holds all the data needed to construct a rigid body.
/// You can safely re-use body definitions. Shapes are added to a body after construction.
///	Body definitions are temporary objects used to bundle creation parameters.
/// Must be initialized using defaultBodyDef().
struct B2BodyDef
{
	/// The body type: static, kinematic, or dynamic.
	B2BodyType type;

	/// The initial world position of the body. Bodies should be created with the desired position.
	/// @note Creating bodies at the origin and then moving them nearly doubles the cost of body creation, especially
	///	if the body is moved after shapes have been added.
	B2Vec2 position;

	/// The initial world rotation of the body. Use b2MakeRot() if you have an angle.
	B2Rot rotation;

	/// The initial linear velocity of the body's origin. Typically in meters per second.
	B2Vec2 linearVelocity;

	/// The initial angular velocity of the body. Radians per second.
	float angularVelocity;

	/// Linear damping is use to reduce the linear velocity. The damping parameter
	/// can be larger than 1 but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	///	Generally linear damping is undesirable because it makes objects move slowly
	///	as if they are floating.
	float linearDamping;

	/// Angular damping is use to reduce the angular velocity. The damping parameter
	/// can be larger than 1.0f but the damping effect becomes sensitive to the
	/// time step when the damping parameter is large.
	///	Angular damping can be use slow down rotating bodies.
	float angularDamping;

	/// Scale the gravity applied to this body. Non-dimensional.
	float gravityScale;

	/// Sleep velocity threshold, default is 0.05 meter per second
	float sleepThreshold;

	/// Use this to store application specific body data.
	void* userData;

	/// Set this flag to false if this body should never fall asleep.
	bool enableSleep;

	/// Is this body initially awake or sleeping?
	bool isAwake;

	/// Should this body be prevented from rotating? Useful for characters.
	bool fixedRotation;

	/// Treat this body as high speed object that performs continuous collision detection
	/// against dynamic and kinematic bodies, but not other bullet bodies.
	///	@warning Bullets should be used sparingly. They are not a solution for general dynamic-versus-dynamic
	///	continuous collision. They may interfere with joint constraints.
	bool isBullet;

	/// Used to disable a body. A disabled body does not move or collide.
	bool isEnabled;

	/// Automatically compute mass and related properties on this body from shapes.
	/// Triggers whenever a shape is add/removed/changed. Default is true.
	bool automaticMass;

	/// This allows this body to bypass rotational speed limits. Should only be used
	///	for circular objects, like wheels.
	bool allowFastRotation;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}
 
// Use this to initialize your body definition.
fn B2BodyDef defaultBodyDef() @cname("b2DefaultBodyDef");
 
/// This is used to filter collision on shapes. It affects shape-vs-shape collision
///	and shape-versus-query collision (such as b2World_CastRay).
struct B2Filter @compact
{
	/// The collision category bits. Normally you would just set one bit. The category bits should
	///	represent your application object types. For example:
	///	@code{.cpp}
	///	enum MyCategories
	///	{
	///	   Static  = 0x00000001,
	///	   Dynamic = 0x00000002,
	///	   Debris  = 0x00000004,
	///	   Player  = 0x00000008,
	///	   // etc
	/// };
	///	@endcode
	uint categoryBits;

	/// The collision mask bits. This states the categories that this
	/// shape would accept for collision.
	///	For example, you may want your player to only collide with static objects
	///	and other players.
	///	@code{.c}
	///	maskBits = Static | Player;
	///	@endcode
	uint maskBits;

	/// Collision groups allow a certain group of objects to never collide (negative)
	/// or always collide (positive). A group index of zero has no effect. Non-zero group filtering
	/// always wins against the mask bits.
	///	For example, you may want ragdolls to collide with other ragdolls but you don't want
	///	ragdoll self-collision. In this case you would give each ragdoll a unique negative group index
	///	and apply that group index to all shapes on the ragdoll.
	int groupIndex;
}
 
fn B2Filter defaultFilter() @cname("b2DefaultFilter");
 
/// The query filter is used to filter collisions between queries and shapes. For example,
///	you may want a ray-cast representing a projectile to hit players and the static environment
///	but not debris.
/// @ingroup shape
struct B2QueryFilter @compact
{
	/// The collision category bits of this query. Normally you would just set one bit.
	uint categoryBits;

	/// The collision mask bits. This states the shape categories that this
	/// query would accept for collision.
	uint maskBits;
}
 
/// Use this to initialize your query filter
fn B2QueryFilter defaultQueryFilter() @cname("b2DefaultQueryFilter");
 
enum B2ShapeType : int
{
	/// A circle with an offset
	CIRCLE,

	/// A capsule is an extruded circle
	CAPSULE,

	/// A line segment
	SEGMENT,

	/// A convex polygon
	POLYGON,

	/// A smooth segment owned by a chain shape
	SMOOTH_SEGMENT
}
 
/// Used to create a shape.
/// This is a temporary object used to bundle shape creation parameters. You may use
///	the same shape definition to create multiple shapes.
/// Must be initialized using defaultShapeDef().
struct B2ShapeDef
{
	/// Use this to store application specific shape data.
	void* userData;

	/// The Coulomb (dry) friction coefficient, usually in the range [0,1].
	float friction;

	/// The restitution (bounce) usually in the range [0,1].
	float restitution;

	/// The density, usually in kg/m^2.
	float density;

	/// Collision filtering data.
	B2Filter filter;

	/// Custom debug draw color.
	uint customColor;

	/// A sensor shape generates overlap events but never generates a collision response.
	bool isSensor;

	/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableSensorEvents;

	/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableContactEvents;

	/// Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.
	bool enableHitEvents;

	/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive
	///	and must be carefully handled due to threading. Ignored for sensors.
	bool enablePreSolveEvents;

	/// Normally shapes on static bodies don't invoke contact creation when they are added to the world. This overrides
	///	that behavior and causes contact creation. This significantly slows down static body creation which can be important
	///	when there are many static shapes.
	bool forceContactCreation;

	/// Used internally to detect a valid definition. DO NOT SET.
	int internalValue;
}

// Use this to initialize your shape definition.
fn B2ShapeDef defaultShapeDef() @cname("b2DefaultShapeDef");
 
struct B2ChainDef
{
    void* userData;
    B2Vec2* points;
    int count;
    float friction;
    float restitution;
    B2Filter filter;
    bool isLoop;
    int internalValue;
}
 
fn B2ChainDef defaultChainDef() @cname("b2DefaultChainDef");
 
struct B2Profile @compact
{
    float step;
    float pairs;
    float collide;
    float solve;
    float buildIslands;
    float solveConstraints;
    float prepareTasks;
    float solverTasks;
    float prepareConstraints;
    float integrateVelocities;
    float warmStart;
    float solveVelocities;
    float integratePositions;
    float relaxVelocities;
    float applyRestitution;
    float storeImpulses;
    float finalizeBodies;
    float splitIslands;
    float sleepIslands;
    float hitEvents;
    float broadphase;
    float continuous;
}
 
struct B2Counters @compact
{
    int staticBodyCount;
    int bodyCount;
    int shapeCount;
    int contactCount;
    int jointCount;
    int islandCount;
    int stackUsed;
    int staticTreeHeight;
    int treeHeight;
    int byteCount;
    int taskCount;
    int[12] colorCounts;
}
 
enum B2JointType : int
{
    DISTANCE,
    MOTOR,
    MOUSE,
    PRISMATIC,
    REVOLUTE,
    WELD,
    WHEEL,
}
 
struct B2DistanceJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 localAnchorA;
    B2Vec2 localAnchorB;
    float length;
    bool enableSpring;
    float hertz;
    float dampingRatio;
    bool enableLimit;
    float minLength;
    float maxLength;
    bool enableMotor;
    float maxMotorForce;
    float motorSpeed;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2DistanceJointDef defaultDistanceJointDef() @cname("b2DefaultDistanceJointDef");
 
struct B2MotorJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 linearOffset;
    float angularOffset;
    float maxForce;
    float maxTorque;
    float correctionFactor;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2MotorJointDef defaultMotorJointDef() @cname("b2DefaultMotorJointDef");
 
struct B2MouseJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 target;
    float hertz;
    float dampingRatio;
    float maxForce;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2MouseJointDef defaultMouseJointDef() @cname("b2DefaultMotorJointDef");
 
struct B2PrismaticJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 localAnchorA;
    B2Vec2 localAnchorB;
    B2Vec2 localAxisA;
    float referenceAngle;
    bool enableSpring;
    float hertz;
    float dampingRatio;
    bool enableLimit;
    float lowerTranslation;
    float upperTranslation;
    bool enableMotor;
    float maxMotorForce;
    float motorSpeed;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2PrismaticJointDef defaultPrismaticJointDef() @cname("b2DefaultPrismaticJointDef");
 
struct B2RevoluteJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 localAnchorA;
    B2Vec2 localAnchorB;
    float referenceAngle;
    bool enableSpring;
    float hertz;
    float dampingRatio;
    bool enableLimit;
    float lowerAngle;
    float upperAngle;
    bool enableMotor;
    float maxMotorTorque;
    float motorSpeed;
    float drawSize;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2RevoluteJointDef defaultRevoluteJointDef() @cname("b2DefaultRevoluteJointDef");
 
struct B2WeldJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 localAnchorA;
    B2Vec2 localAnchorB;
    float referenceAngle;
    float linearHertz;
    float angularHertz;
    float linearDampingRatio;
    float angularDampingRatio;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2WeldJointDef defaultWeldJointDef() @cname("b2DefaultWeldJointDef");
 
struct B2WheelJointDef
{
    B2BodyId bodyIdA;
    B2BodyId bodyIdB;
    B2Vec2 localAnchorA;
    B2Vec2 localAnchorB;
    B2Vec2 localAxisA;
    bool enableSpring;
    float hertz;
    float dampingRatio;
    bool enableLimit;
    float lowerTranslation;
    float upperTranslation;
    bool enableMotor;
    float maxMotorTorque;
    float motorSpeed;
    bool collideConnected;
    void* userData;
    int internalValue;
}
 
fn B2WheelJointDef defaultWheelJointDef() @cname("b2DefaultWheelJointDef");
 
struct B2SensorBeginTouchEvent
{
    B2ShapeId sensorShapeId;
    B2ShapeId visitorShapeId;
}
 
struct B2SensorEndTouchEvent
{
    B2ShapeId sensorShapeId;
    B2ShapeId visitorShapeId;
}
 
struct B2SensorEvents
{
    B2SensorBeginTouchEvent* beginEvents;
    B2SensorEndTouchEvent* endEvents;
    int beginCount;
    int endCount;
}
 
struct B2ContactBeginTouchEvent
{
    B2ShapeId shapeIdA;
    B2ShapeId shapeIdB;
}
 
struct B2ContactEndTouchEvent
{
    B2ShapeId shapeIdA;
    B2ShapeId shapeIdB;
}
 
struct B2ContactHitEvent
{
    B2ShapeId shapeIdA;
    B2ShapeId shapeIdB;
    B2Vec2 point;
    B2Vec2 normal;
    float approachSpeed;
}
 
struct B2ContactEvents
{
    B2ContactBeginTouchEvent* beginEvents;
    B2ContactEndTouchEvent* endEvents;
    B2ContactHitEvent* hitEvents;
    int beginCount;
    int endCount;
    int hitCount;
}
 
struct B2BodyMoveEvent
{
    B2Transform transform;
    B2BodyId bodyId;
    void* userData;
    bool fellAsleep;
}
 
struct B2BodyEvents
{
    B2BodyMoveEvent* moveEvents;
    int moveCount;
}
 
struct B2ContactData
{
    B2ShapeId shapeIdA;
    B2ShapeId shapeIdB;
    B2Manifold manifold;
}
 
//typedef bool b2CustomFilterFcn( B2ShapeId shapeIdA, B2ShapeId shapeIdB, void* context );
alias B2CustomFilterCallback  = fn bool(B2ShapeId,B2ShapeId,void*);
//typedef bool b2PreSolveFcn( B2ShapeId shapeIdA, B2ShapeId shapeIdB, B2Manifold* manifold, void* context );
alias B2PreSolveCallback      = fn bool(B2ShapeId,B2ShapeId,B2Manifold*,void*);
//typedef bool b2OverlapResultFcn( B2ShapeId shapeId, void* context );
alias B2OverlapResultCallback = fn bool(B2ShapeId,void*);
//typedef float b2CastResultFcn( B2ShapeId shapeId, B2Vec2 point, B2Vec2 normal, float fraction, void* context );
alias B2CastResultCallback    = fn float(B2ShapeId,B2Vec2,B2Vec2,float,void*);

<*
Create a world for rigid body simulation.

A world contains bodies, shapes, and constraints. You make create up to 128 worlds. Each world is completely independent and may be simulated in parallel.

Returns
    the world id
*>
fn B2WorldId createWorld( B2WorldDef* wdef ) @cname("b2CreateWorld");
fn void      destroyWorld( B2WorldId worldId ) @cname("b2DestroyWorld");
// World id validation. Provides validation for up to 64K allocations.
fn bool            B2WorldId.isValid( B2WorldId id ) @cname("b2World_IsValid");
// Simulate a world for one time step.
fn void            B2WorldId.step( B2WorldId worldId, float timeStep, int subStepCount ) @cname("b2World_Step");
fn B2BodyEvents    B2WorldId.getBodyEvents( B2WorldId worldId ) @cname("b2World_GetBodyEvents");
fn B2SensorEvents  B2WorldId.getSensorEvents( B2WorldId worldId ) @cname("b2World_GetSensorEvents");
fn B2ContactEvents B2WorldId.getContactEvents( B2WorldId worldId ) @cname("b2World_GetContactEvents");
fn void            B2WorldId.overlapAABB( B2WorldId worldId, B2AABBox aabb, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context ) @cname("b2World_OverlapAABB");
fn void            B2WorldId.overlapCircle( B2WorldId worldId, B2Circle* circle, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context ) @cname("b2World_OverlapCircle");
fn void            B2WorldId.overlapCapsule( B2WorldId worldId, B2Capsule* capsule, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context ) @cname("b2World_OverlapCapsule");
fn void            B2WorldId.overlapPolygon( B2WorldId worldId, B2Polygon* polygon, B2Transform transform, B2QueryFilter filter, B2OverlapResultCallback* fcn, void* context ) @cname("b2World_OverlapPolygon");
fn void            B2WorldId.castRay( B2WorldId worldId, B2Vec2 origin, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context ) @cname("b2World_CastRay");
fn B2RayResult     B2WorldId.castRayClosest( B2WorldId worldId, B2Vec2 origin, B2Vec2 translation, B2QueryFilter filter ) @cname("b2World_CastRayClosest");
fn void            B2WorldId.castCircle( B2WorldId worldId, B2Circle* circle, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context ) @cname("b2World_CastCircle");
fn void            B2WorldId.castCapsule( B2WorldId worldId, B2Capsule* capsule, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context ) @cname("b2World_CastCapsule");
fn void B2WorldId.castPolygon( B2WorldId worldId, B2Polygon* polygon, B2Transform originTransform, B2Vec2 translation, B2QueryFilter filter, B2CastResultCallback* fcn, void* context ) @cname("b2World_CastPolygon");
fn void            B2WorldId.enableSleeping( B2WorldId worldId, bool flag ) @cname("b2World_EnableSleeping");
fn void            B2WorldId.enableContinuous( B2WorldId worldId, bool flag ) @cname("b2World_EnableContinuous");
fn void            B2WorldId.setRestitutionThreshold( B2WorldId worldId, float value ) @cname("b2World_SetRestitutionThreshold");
fn void            B2WorldId.setHitEventThreshold( B2WorldId worldId, float value ) @cname("b2World_SetHitEventThreshold");
fn void            B2WorldId.setCustomFilterCallback( B2WorldId worldId, B2CustomFilterCallback* fcn, void* context ) @cname("b2World_SetCustomFilterCallback");
fn void            B2WorldId.setPreSolveCallback( B2WorldId worldId, B2PreSolveCallback* fcn, void* context ) @cname("b2World_SetPreSolveCallback");
fn void            B2WorldId.setGravity( B2WorldId worldId, B2Vec2 gravity ) @cname("b2World_SetGravity");
fn B2Vec2          B2WorldId.getGravity( B2WorldId worldId ) @cname("b2World_GetGravity");
fn void            B2WorldId.explode( B2WorldId worldId, B2Vec2 position, float radius, float impulse ) @cname("b2World_Explode");
fn void            B2WorldId.setContactTuning( B2WorldId worldId, float hertz, float dampingRatio, float pushVelocity ) @cname("b2World_SetContactTuning");
fn void            B2WorldId.enableWarmStarting( B2WorldId worldId, bool flag ) @cname("b2World_EnableWarmStarting");
fn B2Profile       B2WorldId.getProfile( B2WorldId worldId ) @cname("b2World_GetProfile");
fn B2Counters      B2WorldId.getCounters( B2WorldId worldId ) @cname("b2World_GetCounters");
fn void            B2WorldId.dumpMemoryStats( B2WorldId worldId ) @cname("b2World_DumpMemoryStats");

/// Call this to draw shapes and other debug draw data
fn void B2WorldId.debugDraw(B2WorldId worldId, B2DebugDraw* draw ) @cname("b2World_Draw");

<*
Create a rigid body given a definition.

No reference to the definition is retained. So you can create the definition on the stack and pass it as a pointer.

ex: 
B2BodyDef bodyDef  = box2d::defaultBodyDef();
B2BodyId  myBodyId = box2d::createBody(myWorldId, &bodyDef);

Warning: This function is locked during callbacks.
*>
fn B2BodyId createBody( B2WorldId worldId, B2BodyDef* bdef ) @cname("b2CreateBody");
fn void     destroyBody( B2BodyId bodyId ) @cname("b2DestroyBody");
fn bool        B2BodyId.isValid( B2BodyId id ) @cname("b2Body_IsValid");
fn B2BodyType  B2BodyId.getType( B2BodyId bodyId ) @cname("b2Body_GetType");
fn void        B2BodyId.setType( B2BodyId bodyId, B2BodyType type ) @cname("b2Body_SetType");
fn void        B2BodyId.setUserData( B2BodyId bodyId, void* userData ) @cname("b2Body_SetUserData");
fn void*       B2BodyId.getUserData( B2BodyId bodyId ) @cname("b2Body_GetUserData");
// Get the world position of a body. This is the location of the body origin.
fn B2Vec2      B2BodyId.getPosition( B2BodyId bodyId ) @cname("b2Body_GetPosition");
// Get the world rotation of a body as a cosine/sine pair (complex number)
fn B2Rot       B2BodyId.getRotation( B2BodyId bodyId ) @cname("b2Body_GetRotation");
fn B2Transform B2BodyId.getTransform( B2BodyId bodyId ) @cname("b2Body_GetTransform");
fn void        B2BodyId.setTransform( B2BodyId bodyId, B2Vec2 position, B2Rot rotation ) @cname("b2Body_SetTransform");
fn B2Vec2      B2BodyId.getLocalPoint( B2BodyId bodyId, B2Vec2 worldPoint ) @cname("b2Body_GetLocalPoint");
// Get a world point on a body given a local point.
fn B2Vec2      B2BodyId.getWorldPoint( B2BodyId bodyId, B2Vec2 localPoint ) @cname("b2Body_GetWorldPoint");
fn B2Vec2      B2BodyId.getLocalVector( B2BodyId bodyId, B2Vec2 worldVector ) @cname("b2Body_GetLocalVector");
fn B2Vec2      B2BodyId.getWorldVector( B2BodyId bodyId, B2Vec2 localVector ) @cname("b2Body_GetWorldVector");
fn B2Vec2      B2BodyId.getLinearVelocity( B2BodyId bodyId ) @cname("b2Body_GetLinearVelocity");
fn float       B2BodyId.getAngularVelocity( B2BodyId bodyId ) @cname("b2Body_GetAngularVelocity");
fn void        B2BodyId.setLinearVelocity( B2BodyId bodyId, B2Vec2 linearVelocity ) @cname("b2Body_SetLinearVelocity");
fn void        B2BodyId.setAngularVelocity( B2BodyId bodyId, float angularVelocity ) @cname("b2Body_SetAngularVelocity");
fn void        B2BodyId.applyForce( B2BodyId bodyId, B2Vec2 force, B2Vec2 point, bool wake ) @cname("b2Body_ApplyForce");
fn void        B2BodyId.applyForceToCenter( B2BodyId bodyId, B2Vec2 force, bool wake ) @cname("b2Body_ApplyForceToCenter");
fn void        B2BodyId.applyTorque( B2BodyId bodyId, float torque, bool wake ) @cname("b2Body_ApplyTorque");
fn void        B2BodyId.applyLinearImpulse( B2BodyId bodyId, B2Vec2 impulse, B2Vec2 point, bool wake ) @cname("b2Body_ApplyLinearImpulse");
fn void        B2BodyId.applyLinearImpulseToCenter( B2BodyId bodyId, B2Vec2 impulse, bool wake ) @cname("b2Body_ApplyLinearImpulseToCenter");
fn void        B2BodyId.applyAngularImpulse( B2BodyId bodyId, float impulse, bool wake ) @cname("b2Body_ApplyAngularImpulse");
fn float       B2BodyId.getMass( B2BodyId bodyId ) @cname("b2Body_GetMass");
fn float       B2BodyId.getRotationalInertia( B2BodyId bodyId ) @cname("b2Body_GetRotationalInertia");
fn B2Vec2      B2BodyId.getLocalCenterOfMass( B2BodyId bodyId ) @cname("b2Body_GetLocalCenterOfMass");
fn B2Vec2      B2BodyId.getWorldCenterOfMass( B2BodyId bodyId ) @cname("b2Body_GetWorldCenterOfMass");
fn void        B2BodyId.setMassData( B2BodyId bodyId, B2MassData massData ) @cname("b2Body_SetMassData");
fn B2MassData  B2BodyId.getMassData( B2BodyId bodyId ) @cname("b2Body_GetMassData");
fn void        B2BodyId.applyMassFromShapes( B2BodyId bodyId ) @cname("b2Body_ApplyMassFromShapes");
fn void        B2BodyId.setAutomaticMass( B2BodyId bodyId, bool automaticMass ) @cname("b2Body_SetAutomaticMass");
fn bool        B2BodyId.getAutomaticMass( B2BodyId bodyId ) @cname("b2Body_GetAutomaticMass");
fn void        B2BodyId.setLinearDamping( B2BodyId bodyId, float linearDamping ) @cname("b2Body_SetLinearDamping");
fn float       B2BodyId.getLinearDamping( B2BodyId bodyId ) @cname("b2Body_GetLinearDamping");
fn void        B2BodyId.setAngularDamping( B2BodyId bodyId, float angularDamping ) @cname("b2Body_SetAngularDamping");
fn float       B2BodyId.getAngularDamping( B2BodyId bodyId ) @cname("b2Body_GetAngularDamping");
fn void        B2BodyId.setGravityScale( B2BodyId bodyId, float gravityScale ) @cname("b2Body_SetGravityScale");
fn float       B2BodyId.getGravityScale( B2BodyId bodyId ) @cname("b2Body_GetGravityScale");
fn bool        B2BodyId.isAwake( B2BodyId bodyId ) @cname("b2Body_IsAwake");
fn void        B2BodyId.setAwake( B2BodyId bodyId, bool awake ) @cname("b2Body_SetAwake");
fn void        B2BodyId.enableSleep( B2BodyId bodyId, bool enableSleep ) @cname("b2Body_EnableSleep");
fn bool        B2BodyId.isSleepEnabled( B2BodyId bodyId ) @cname("b2Body_IsSleepEnabled");
fn void        B2BodyId.setSleepThreshold( B2BodyId bodyId, float sleepThreshold ) @cname("b2Body_SetSleepThreshold");
fn float       B2BodyId.getSleepThreshold( B2BodyId bodyId ) @cname("b2Body_GetSleepThreshold");
fn bool        B2BodyId.isEnabled( B2BodyId bodyId ) @cname("b2Body_IsEnabled");
fn void        B2BodyId.disable( B2BodyId bodyId ) @cname("b2Body_Disable");
fn void        B2BodyId.enable( B2BodyId bodyId ) @cname("b2Body_Enable");
fn void        B2BodyId.setFixedRotation( B2BodyId bodyId, bool flag ) @cname("b2Body_SetFixedRotation");
fn bool        B2BodyId.isFixedRotation( B2BodyId bodyId ) @cname("b2Body_IsFixedRotation");
fn void        B2BodyId.setBullet( B2BodyId bodyId, bool flag ) @cname("b2Body_SetBullet");
fn bool        B2BodyId.isBullet( B2BodyId bodyId ) @cname("b2Body_IsBullet");
fn void        B2BodyId.enableHitEvents( B2BodyId bodyId, bool enableHitEvents ) @cname("b2Body_EnableHitEvents");
fn int         B2BodyId.getShapeCount( B2BodyId bodyId ) @cname("b2Body_GetShapeCount");
fn int         B2BodyId.getShapes( B2BodyId bodyId, B2ShapeId* shapeArray, int capacity ) @cname("b2Body_GetShapes");
fn int         B2BodyId.getJointCount( B2BodyId bodyId ) @cname("b2Body_GetJointCount");
fn int         B2BodyId.getJoints( B2BodyId bodyId, B2JointId* jointArray, int capacity ) @cname("b2Body_GetJoints");
fn int         B2BodyId.getContactCapacity( B2BodyId bodyId ) @cname("b2Body_GetContactCapacity");
fn int         B2BodyId.getContactData( B2BodyId bodyId, B2ContactData* contactData, int capacity ) @cname("b2Body_GetContactData");
fn B2AABBox    B2BodyId.computeAABB( B2BodyId bodyId ) @cname("b2Body_ComputeAABB");
//
fn B2ShapeId B2BodyId.createCircleShape( B2BodyId bodyId, B2ShapeDef* sdef, B2Circle* circle ) @cname("b2CreateCircleShape");
fn B2ShapeId B2BodyId.createSegmentShape( B2BodyId bodyId, B2ShapeDef* sdef, B2Segment* segment ) @cname("b2CreateSegmentShape");
fn B2ShapeId B2BodyId.createCapsuleShape( B2BodyId bodyId, B2ShapeDef* sdef, B2Capsule* capsule ) @cname("b2CreateCapsuleShape");

<*
Create a polygon shape and attach it to a body.
The shape definition and geometry are fully cloned. Contacts are not created until the next time step.
Returns
    the shape id for accessing the shape
	@param bodyId : "the body to attach the shape to"
	@param [&in] sdef : "the shape definition, must be initialized using defaultShapeDef()"
	@param [&inout] polygon : "the polygon geometry, must be initialized using defaultPolygon()"
*>
fn B2ShapeId createPolygonShape( B2BodyId bodyId, B2ShapeDef* sdef, B2Polygon* polygon ) @cname("b2CreatePolygonShape");
fn void destroyShape( B2ShapeId shapeId ) @cname("b2DestroyShape");
fn bool        B2ShapeId.isValid( B2ShapeId id ) @cname("b2Shape_IsValid");
fn B2ShapeType B2ShapeId.getType( B2ShapeId shapeId ) @cname("b2Shape_GetType");
fn B2BodyId    B2ShapeId.getBody( B2ShapeId shapeId ) @cname("b2Shape_GetBody");
fn bool        B2ShapeId.isSensor( B2ShapeId shapeId ) @cname("b2Shape_IsSensor");
fn void        B2ShapeId.setUserData( B2ShapeId shapeId, void* userData ) @cname("b2Shape_SetUserData");
fn void*       B2ShapeId.getUserData( B2ShapeId shapeId ) @cname("b2Shape_GetUserData");
fn void        B2ShapeId.setDensity( B2ShapeId shapeId, float density ) @cname("b2Shape_SetDensity");
fn float       B2ShapeId.getDensity( B2ShapeId shapeId ) @cname("b2Shape_GetDensity");
fn void        B2ShapeId.setFriction( B2ShapeId shapeId, float friction ) @cname("b2Shape_SetFriction");
fn float       B2ShapeId.getFriction( B2ShapeId shapeId ) @cname("b2Shape_GetFriction");
fn void        B2ShapeId.setRestitution( B2ShapeId shapeId, float restitution ) @cname("b2Shape_SetRestitution");
fn float       B2ShapeId.getRestitution( B2ShapeId shapeId ) @cname("b2Shape_GetRestitution");
fn B2Filter    B2ShapeId.getFilter( B2ShapeId shapeId ) @cname("b2Shape_GetFilter");
fn void        B2ShapeId.setFilter( B2ShapeId shapeId, B2Filter filter ) @cname("b2Shape_SetFilter");
fn void        B2ShapeId.enableSensorEvents( B2ShapeId shapeId, bool flag ) @cname("b2Shape_EnableSensorEvents");
fn bool        B2ShapeId.areSensorEventsEnabled( B2ShapeId shapeId ) @cname("b2Shape_AreSensorEventsEnabled");
fn void        B2ShapeId.enableContactEvents( B2ShapeId shapeId, bool flag ) @cname("b2Shape_EnableContactEvents");
fn bool        B2ShapeId.areContactEventsEnabled( B2ShapeId shapeId ) @cname("b2Shape_AreContactEventsEnabled");
fn void        B2ShapeId.enablePreSolveEvents( B2ShapeId shapeId, bool flag ) @cname("b2Shape_EnablePreSolveEvents");
fn bool        B2ShapeId.arePreSolveEventsEnabled( B2ShapeId shapeId ) @cname("b2Shape_ArePreSolveEventsEnabled");
fn void        B2ShapeId.enableHitEvents( B2ShapeId shapeId, bool flag ) @cname("b2Shape_EnableHitEvents");
fn bool        B2ShapeId.areHitEventsEnabled( B2ShapeId shapeId ) @cname("b2Shape_AreHitEventsEnabled");
fn bool        B2ShapeId.testPoint( B2ShapeId shapeId, B2Vec2 point ) @cname("b2Shape_TestPoint");
fn B2CastOutput B2ShapeId.rayCast( B2ShapeId shapeId, B2RayCastInput* input ) @cname("b2Shape_RayCast");
fn B2Circle     B2ShapeId.getCircle( B2ShapeId shapeId ) @cname("b2Shape_GetCircle");
fn B2Segment    B2ShapeId.getSegment( B2ShapeId shapeId ) @cname("b2Shape_GetSegment");
fn B2ChainSegment B2ShapeId.getChainSegment( B2ShapeId shapeId ) @cname("b2Shape_GetChainSegment");
fn B2Capsule    B2ShapeId.getCapsule( B2ShapeId shapeId ) @cname("b2Shape_GetCapsule");
fn B2Polygon    B2ShapeId.getPolygon( B2ShapeId shapeId ) @cname("b2Shape_GetPolygon");
fn void        B2ShapeId.setCircle( B2ShapeId shapeId, B2Circle* circle ) @cname("b2Shape_SetCircle");
fn void        B2ShapeId.setCapsule( B2ShapeId shapeId, B2Capsule* capsule ) @cname("b2Shape_SetCapsule");
fn void        B2ShapeId.setSegment( B2ShapeId shapeId, B2Segment* segment ) @cname("b2Shape_SetSegment");
fn void        B2ShapeId.setPolygon( B2ShapeId shapeId, B2Polygon* polygon ) @cname("b2Shape_SetPolygon");
fn B2ChainId   B2ShapeId.getParentChain( B2ShapeId shapeId ) @cname("b2Shape_GetParentChain");
fn int         B2ShapeId.getContactCapacity( B2ShapeId shapeId ) @cname("b2Shape_GetContactCapacity");
fn int         B2ShapeId.getContactData( B2ShapeId shapeId, B2ContactData* contactData, int capacity ) @cname("b2Shape_GetContactData");
fn B2AABBox    B2ShapeId.getAABB( B2ShapeId shapeId ) @cname("b2Shape_GetAABB");
fn B2Vec2      B2ShapeId.getClosestPoint( B2ShapeId shapeId, B2Vec2 target ) @cname("b2Shape_GetClosestPoint");
//
fn B2ChainId createChain( B2BodyId bodyId, B2ChainDef* cdef ) @cname("b2CreateChain");
fn void      destroyChain( B2ChainId chainId ) @cname("b2DestroyChain");
fn void chain_SetFriction( B2ChainId chainId, float friction ) @cname("b2Chain_SetFriction");
fn void chain_SetRestitution( B2ChainId chainId, float restitution ) @cname("b2Chain_SetRestitution");
fn bool chain_IsValid( B2ChainId id ) @cname("b2Chain_IsValid");
//
fn void        destroyJoint( B2JointId jointId ) @cname("b2DestroyJoint");
fn bool        joint_IsValid( B2JointId id ) @cname("b2Joint_IsValid");
fn B2JointType joint_GetType( B2JointId jointId ) @cname("b2Joint_GetType");
fn B2BodyId    joint_GetBodyA( B2JointId jointId ) @cname("b2Joint_GetBodyA");
fn B2BodyId    joint_GetBodyB( B2JointId jointId ) @cname("b2Joint_GetBodyB");
fn B2Vec2      joint_GetLocalAnchorA( B2JointId jointId ) @cname("b2Joint_GetLocalAnchorA");
fn B2Vec2      joint_GetLocalAnchorB( B2JointId jointId ) @cname("b2Joint_GetLocalAnchorB");
fn void        joint_SetCollideConnected( B2JointId jointId, bool shouldCollide ) @cname("b2Joint_SetCollideConnected");
fn bool        joint_GetCollideConnected( B2JointId jointId ) @cname("b2Joint_GetCollideConnected");
fn void        joint_SetUserData( B2JointId jointId, void* userData ) @cname("b2Joint_SetUserData");
fn void*       joint_GetUserData( B2JointId jointId ) @cname("b2Joint_GetUserData");
fn void        joint_WakeBodies( B2JointId jointId ) @cname("b2Joint_WakeBodies");
fn B2Vec2      joint_GetConstraintForce( B2JointId jointId ) @cname("b2Joint_GetConstraintForce");
fn float       joint_GetConstraintTorque( B2JointId jointId ) @cname("b2Joint_GetConstraintTorque");
//
fn B2JointId createDistanceJoint( B2WorldId worldId, B2DistanceJointDef* ddef ) @cname("b2CreateDistanceJoint");
fn void      distanceJoint_SetLength( B2JointId jointId, float length ) @cname("b2DistanceJoint_SetLength");
fn float     distanceJoint_GetLength( B2JointId jointId ) @cname("b2DistanceJoint_GetLength");
fn void      distanceJoint_EnableSpring( B2JointId jointId, bool enableSpring ) @cname("b2DistanceJoint_EnableSpring");
fn bool      distanceJoint_IsSpringEnabled( B2JointId jointId ) @cname("b2DistanceJoint_IsSpringEnabled");
fn void      distanceJoint_SetSpringHertz( B2JointId jointId, float hertz ) @cname("b2DistanceJoint_SetSpringHertz");
fn void      distanceJoint_SetSpringDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2DistanceJoint_SetSpringDampingRatio");
fn float     distanceJoint_GetSpringHertz( B2JointId jointId ) @cname("b2DistanceJoint_GetSpringHertz");
fn float     distanceJoint_GetSpringDampingRatio( B2JointId jointId ) @cname("b2DistanceJoint_GetSpringDampingRatio");
fn void      distanceJoint_EnableLimit( B2JointId jointId, bool enableLimit ) @cname("b2DistanceJoint_EnableLimit");
fn bool      distanceJoint_IsLimitEnabled( B2JointId jointId ) @cname("b2DistanceJoint_IsLimitEnabled");
fn void      distanceJoint_SetLengthRange( B2JointId jointId, float minLength, float maxLength ) @cname("b2DistanceJoint_SetLengthRange");
fn float     distanceJoint_GetMinLength( B2JointId jointId ) @cname("b2DistanceJoint_GetMinLength");
fn float     distanceJoint_GetMaxLength( B2JointId jointId ) @cname("b2DistanceJoint_GetMaxLength");
fn float     distanceJoint_GetCurrentLength( B2JointId jointId ) @cname("b2DistanceJoint_GetCurrentLength");
fn void      distanceJoint_EnableMotor( B2JointId jointId, bool enableMotor ) @cname("b2DistanceJoint_EnableMotor");
fn bool      distanceJoint_IsMotorEnabled( B2JointId jointId ) @cname("b2DistanceJoint_IsMotorEnabled");
fn void      distanceJoint_SetMotorSpeed( B2JointId jointId, float motorSpeed ) @cname("b2DistanceJoint_SetMotorSpeed");
fn float     distanceJoint_GetMotorSpeed( B2JointId jointId ) @cname("b2DistanceJoint_GetMotorSpeed");
fn void      distanceJoint_SetMaxMotorForce( B2JointId jointId, float force ) @cname("b2DistanceJoint_SetMaxMotorForce");
fn float     distanceJoint_GetMaxMotorForce( B2JointId jointId ) @cname("b2DistanceJoint_GetMaxMotorForce");
fn float     distanceJoint_GetMotorForce( B2JointId jointId ) @cname("b2DistanceJoint_GetMotorForce");
//
fn B2JointId createMotorJoint( B2WorldId worldId, B2MotorJointDef* mdef ) @cname("b2CreateMotorJoint");
fn void      motorJoint_SetLinearOffset( B2JointId jointId, B2Vec2 linearOffset ) @cname("b2MotorJoint_SetLinearOffset");
fn B2Vec2    motorJoint_GetLinearOffset( B2JointId jointId ) @cname("b2MotorJoint_GetLinearOffset");
fn void      motorJoint_SetAngularOffset( B2JointId jointId, float angularOffset ) @cname("b2MotorJoint_SetAngularOffset");
fn float     motorJoint_GetAngularOffset( B2JointId jointId ) @cname("b2MotorJoint_GetAngularOffset");
fn void      motorJoint_SetMaxForce( B2JointId jointId, float maxForce ) @cname("b2MotorJoint_SetMaxForce");
fn float     motorJoint_GetMaxForce( B2JointId jointId ) @cname("b2MotorJoint_GetMaxForce");
fn void      motorJoint_SetMaxTorque( B2JointId jointId, float maxTorque ) @cname("b2MotorJoint_SetMaxTorque");
fn float     motorJoint_GetMaxTorque( B2JointId jointId ) @cname("b2MotorJoint_GetMaxTorque");
fn void      motorJoint_SetCorrectionFactor( B2JointId jointId, float correctionFactor ) @cname("b2MotorJoint_SetCorrectionFactor");
fn float     motorJoint_GetCorrectionFactor( B2JointId jointId ) @cname("b2MotorJoint_GetCorrectionFactor");
//
fn B2JointId createMouseJoint( B2WorldId worldId, B2MouseJointDef* mdef ) @cname("b2CreateMouseJoint");
fn void      mouseJoint_SetTarget( B2JointId jointId, B2Vec2 target ) @cname("b2MouseJoint_SetTarget");
fn B2Vec2    mouseJoint_GetTarget( B2JointId jointId ) @cname("b2MouseJoint_GetTarget");
fn void      mouseJoint_SetSpringHertz( B2JointId jointId, float hertz ) @cname("b2MouseJoint_SetSpringHertz");
fn float     mouseJoint_GetSpringHertz( B2JointId jointId ) @cname("b2MouseJoint_GetSpringHertz");
fn void      mouseJoint_SetSpringDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2MouseJoint_SetSpringDampingRatio");
fn float     mouseJoint_GetSpringDampingRatio( B2JointId jointId ) @cname("b2MouseJoint_GetSpringDampingRatio");
fn void      mouseJoint_SetMaxForce( B2JointId jointId, float maxForce ) @cname("b2MouseJoint_SetMaxForce");
fn float     mouseJoint_GetMaxForce( B2JointId jointId ) @cname("b2MouseJoint_GetMaxForce");
//
fn B2JointId createPrismaticJoint( B2WorldId worldId, B2PrismaticJointDef* pdef ) @cname("b2CreatePrismaticJoint");
fn void      prismaticJoint_EnableSpring( B2JointId jointId, bool enableSpring ) @cname("b2PrismaticJoint_EnableSpring");
fn bool      prismaticJoint_IsSpringEnabled( B2JointId jointId ) @cname("b2PrismaticJoint_IsSpringEnabled");
fn void      prismaticJoint_SetSpringHertz( B2JointId jointId, float hertz ) @cname("b2PrismaticJoint_SetSpringHertz");
fn float     prismaticJoint_GetSpringHertz( B2JointId jointId ) @cname("b2PrismaticJoint_GetSpringHertz");
fn void      prismaticJoint_SetSpringDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2PrismaticJoint_SetSpringDampingRatio");
fn float     prismaticJoint_GetSpringDampingRatio( B2JointId jointId ) @cname("b2PrismaticJoint_GetSpringDampingRatio");
fn void      prismaticJoint_EnableLimit( B2JointId jointId, bool enableLimit ) @cname("b2PrismaticJoint_EnableLimit");
fn bool      prismaticJoint_IsLimitEnabled( B2JointId jointId ) @cname("b2PrismaticJoint_IsLimitEnabled");
fn float     prismaticJoint_GetLowerLimit( B2JointId jointId ) @cname("b2PrismaticJoint_GetLowerLimit");
fn float     prismaticJoint_GetUpperLimit( B2JointId jointId ) @cname("b2PrismaticJoint_GetUpperLimit");
fn void      prismaticJoint_SetLimits( B2JointId jointId, float lower, float upper ) @cname("b2PrismaticJoint_SetLimits");
fn void      prismaticJoint_EnableMotor( B2JointId jointId, bool enableMotor ) @cname("b2PrismaticJoint_EnableMotor");
fn bool      prismaticJoint_IsMotorEnabled( B2JointId jointId ) @cname("b2PrismaticJoint_IsMotorEnabled");
fn void      prismaticJoint_SetMotorSpeed( B2JointId jointId, float motorSpeed ) @cname("b2PrismaticJoint_SetMotorSpeed");
fn float     prismaticJoint_GetMotorSpeed( B2JointId jointId ) @cname("b2PrismaticJoint_GetMotorSpeed");
fn void      prismaticJoint_SetMaxMotorForce( B2JointId jointId, float force ) @cname("b2PrismaticJoint_SetMaxMotorForce");
fn float     prismaticJoint_GetMaxMotorForce( B2JointId jointId ) @cname("b2PrismaticJoint_GetMaxMotorForce");
fn float     prismaticJoint_GetMotorForce( B2JointId jointId ) @cname("b2PrismaticJoint_GetMotorForce");
//
fn B2JointId createRevoluteJoint( B2WorldId worldId, B2RevoluteJointDef* rdef ) @cname("b2CreateRevoluteJoint");
fn void    revoluteJoint_EnableSpring( B2JointId jointId, bool enableSpring ) @cname("b2RevoluteJoint_EnableSpring");
fn bool    revoluteJoint_IsSpringEnabled( B2JointId jointId ) @cname("b2RevoluteJoint_IsSpringEnabled");
fn void    revoluteJoint_SetSpringHertz( B2JointId jointId, float hertz ) @cname("b2RevoluteJoint_SetSpringHertz");
fn float   revoluteJoint_GetSpringHertz( B2JointId jointId ) @cname("b2RevoluteJoint_GetSpringHertz");
fn void    revoluteJoint_SetSpringDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2RevoluteJoint_SetSpringDampingRatio");
fn float   revoluteJoint_GetSpringDampingRatio( B2JointId jointId ) @cname("b2RevoluteJoint_GetSpringDampingRatio");
fn float   revoluteJoint_GetAngle( B2JointId jointId ) @cname("b2RevoluteJoint_GetAngle");
fn void    revoluteJoint_EnableLimit( B2JointId jointId, bool enableLimit ) @cname("b2RevoluteJoint_EnableLimit");
fn bool    revoluteJoint_IsLimitEnabled( B2JointId jointId ) @cname("b2RevoluteJoint_IsLimitEnabled");
fn float   revoluteJoint_GetLowerLimit( B2JointId jointId ) @cname("b2RevoluteJoint_GetLowerLimit");
fn float   revoluteJoint_GetUpperLimit( B2JointId jointId ) @cname("b2RevoluteJoint_GetUpperLimit");
fn void    revoluteJoint_SetLimits( B2JointId jointId, float lower, float upper ) @cname("b2RevoluteJoint_SetLimits");
fn void    revoluteJoint_EnableMotor( B2JointId jointId, bool enableMotor ) @cname("b2RevoluteJoint_EnableMotor");
fn bool    revoluteJoint_IsMotorEnabled( B2JointId jointId ) @cname("b2RevoluteJoint_IsMotorEnabled");
fn void    revoluteJoint_SetMotorSpeed( B2JointId jointId, float motorSpeed ) @cname("b2RevoluteJoint_SetMotorSpeed");
fn float   revoluteJoint_GetMotorSpeed( B2JointId jointId ) @cname("b2RevoluteJoint_GetMotorSpeed");
fn float   revoluteJoint_GetMotorTorque( B2JointId jointId ) @cname("b2RevoluteJoint_GetMotorTorque");
fn void    revoluteJoint_SetMaxMotorTorque( B2JointId jointId, float torque ) @cname("b2RevoluteJoint_SetMaxMotorTorque");
fn float   revoluteJoint_GetMaxMotorTorque( B2JointId jointId ) @cname("b2RevoluteJoint_GetMaxMotorTorque");
//
fn B2JointId createWeldJoint( B2WorldId worldId, B2WeldJointDef* wdef ) @cname("b2CreateWeldJoint");
fn void      weldJoint_SetLinearHertz( B2JointId jointId, float hertz ) @cname("b2WeldJoint_SetLinearHertz");
fn float     weldJoint_GetLinearHertz( B2JointId jointId ) @cname("b2WeldJoint_GetLinearHertz");
fn void      weldJoint_SetLinearDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2WeldJoint_SetLinearDampingRatio");
fn float     weldJoint_GetLinearDampingRatio( B2JointId jointId ) @cname("b2WeldJoint_GetLinearDampingRatio");
fn void      weldJoint_SetAngularHertz( B2JointId jointId, float hertz ) @cname("b2WeldJoint_SetAngularHertz");
fn float     weldJoint_GetAngularHertz( B2JointId jointId ) @cname("b2WeldJoint_GetAngularHertz");
fn void      weldJoint_SetAngularDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2WeldJoint_SetAngularDampingRatio");
fn float     weldJoint_GetAngularDampingRatio( B2JointId jointId ) @cname("b2WeldJoint_GetAngularDampingRatio");
//
fn B2JointId createWheelJoint( B2WorldId worldId, B2WheelJointDef* wdef ) @cname("b2CreateWheelJoint");
fn void      wheelJoint_EnableSpring( B2JointId jointId, bool enableSpring ) @cname("b2WheelJoint_EnableSpring");
fn bool      wheelJoint_IsSpringEnabled( B2JointId jointId ) @cname("b2WheelJoint_IsSpringEnabled");
fn void      wheelJoint_SetSpringHertz( B2JointId jointId, float hertz ) @cname("b2WheelJoint_SetSpringHertz");
fn float     wheelJoint_GetSpringHertz( B2JointId jointId ) @cname("b2WheelJoint_GetSpringHertz");
fn void      wheelJoint_SetSpringDampingRatio( B2JointId jointId, float dampingRatio ) @cname("b2WheelJoint_SetSpringDampingRatio");
fn float     wheelJoint_GetSpringDampingRatio( B2JointId jointId ) @cname("b2WheelJoint_GetSpringDampingRatio");
fn void      wheelJoint_EnableLimit( B2JointId jointId, bool enableLimit ) @cname("b2WheelJoint_EnableLimit");
fn bool      wheelJoint_IsLimitEnabled( B2JointId jointId ) @cname("b2WheelJoint_IsLimitEnabled");
fn float     wheelJoint_GetLowerLimit( B2JointId jointId ) @cname("b2WheelJoint_GetLowerLimit");
fn float     wheelJoint_GetUpperLimit( B2JointId jointId ) @cname("b2WheelJoint_GetUpperLimit");
fn void      wheelJoint_SetLimits( B2JointId jointId, float lower, float upper ) @cname("b2WheelJoint_SetLimits");
fn void      wheelJoint_EnableMotor( B2JointId jointId, bool enableMotor ) @cname("b2WheelJoint_EnableMotor");
fn bool      wheelJoint_IsMotorEnabled( B2JointId jointId ) @cname("b2WheelJoint_IsMotorEnabled");
fn void      wheelJoint_SetMotorSpeed( B2JointId jointId, float motorSpeed ) @cname("b2WheelJoint_SetMotorSpeed");
fn float     wheelJoint_GetMotorSpeed( B2JointId jointId ) @cname("b2WheelJoint_GetMotorSpeed");
fn void      wheelJoint_SetMaxMotorTorque( B2JointId jointId, float torque ) @cname("b2WheelJoint_SetMaxMotorTorque");
fn float     wheelJoint_GetMaxMotorTorque( B2JointId jointId ) @cname("b2WheelJoint_GetMaxMotorTorque");
fn float     wheelJoint_GetMotorTorque( B2JointId jointId ) @cname("b2WheelJoint_GetMotorTorque");

// end_region TYPES

// region collision

/// The maximum number of vertices on a convex polygon. Changing this affects performance even if you
///	don't use more vertices.
const MAX_POLYGON_VERTICES = 8;

struct B2RayCastInput
{
    B2Vec2 origin;
    B2Vec2 translation;
    float maxFraction;
}

struct B2ShapeCastInput
{
    B2Vec2[MAX_POLYGON_VERTICES] points;
    int count;
    float radius;
    B2Vec2 translation;
    float maxFraction;
}

struct B2CastOutput
{
    B2Vec2 normal;
    B2Vec2 point;
    float fraction;
    int iterations;
    bool hit;
}

struct B2MassData
{
    float mass;
    B2Vec2 center;
    float rotationalInertia;
}

struct B2Circle
{
    B2Vec2 center;
    float radius;
}

struct B2Capsule
{
    B2Vec2 center1;

    B2Vec2 center2;

    float radius;
}

/// A solid convex polygon. It is assumed that the interior of the polygon is to
/// the left of each edge.
/// Polygons have a maximum number of vertices equal to b2_maxPolygonVertices.
/// In most cases you should not need many vertices for a convex polygon.
///	@warning DO NOT fill this out manually, instead use a helper function like
///	b2MakePolygon or b2MakeBox.
struct B2Polygon
{
	/// The polygon vertices
	B2Vec2[MAX_POLYGON_VERTICES] vertices;
	/// The outward normal vectors of the polygon sides
	B2Vec2[MAX_POLYGON_VERTICES] normals;
	/// The centroid of the polygon
	B2Vec2 centroid;
	/// The external radius for rounded polygons
	float radius;
	/// The number of polygon vertices
	int count;
}

struct B2Segment
{
    B2Vec2 point1;
    B2Vec2 point2;
}

struct B2ChainSegment
{
    B2Vec2 ghost1;
    B2Segment segment;
    B2Vec2 ghost2;
    int chainId;
}

fn bool isValidRay( B2RayCastInput* input ) @cname("b2IsValidRay");
fn B2Polygon makePolygon( B2Hull* hull, float radius ) @cname("b2MakePolygon");
fn B2Polygon makeOffsetPolygon( B2Hull* hull, float radius, B2Transform transform ) @cname("b2MakeOffsetPolygon");
// Make a square polygon, bypassing the need for a convex hull.
fn B2Polygon makeSquare( float h ) @cname("b2MakeSquare");
// Make a box (rectangle) polygon, bypassing the need for a convex hull.
fn B2Polygon makeBox( float halfwidth, float halfheight ) @cname("b2MakeBox");
fn B2Polygon makeRoundedBox( float hx, float hy, float radius ) @cname("b2MakeRoundedBox");
fn B2Polygon makeOffsetBox( float hx, float hy, B2Vec2 center, B2Rot rotation ) @cname("b2MakeOffsetBox");
fn B2Polygon transformPolygon( B2Transform transform, B2Polygon* polygon ) @cname("b2TransformPolygon");
fn B2MassData computeCircleMass( B2Circle* shape, float density ) @cname("b2ComputeCircleMass");
fn B2MassData computeCapsuleMass( B2Capsule* shape, float density ) @cname("b2ComputeCapsuleMass");
fn B2MassData computePolygonMass( B2Polygon* shape, float density ) @cname("b2ComputePolygonMass");
fn B2AABBox computeCircleAABB( B2Circle* shape, B2Transform transform ) @cname("b2ComputeCircleAABB");
fn B2AABBox computeCapsuleAABB( B2Capsule* shape, B2Transform transform ) @cname("b2ComputeCapsuleAABB");
fn B2AABBox computePolygonAABB( B2Polygon* shape, B2Transform transform ) @cname("b2ComputePolygonAABB");
fn B2AABBox computeSegmentAABB( B2Segment* shape, B2Transform transform ) @cname("b2ComputeSegmentAABB");
fn bool pointInCircle( B2Vec2 point, B2Circle* shape ) @cname("b2PointInCircle");
fn bool pointInCapsule( B2Vec2 point, B2Capsule* shape ) @cname("b2PointInCapsule");
fn bool pointInPolygon( B2Vec2 point, B2Polygon* shape ) @cname("b2PointInPolygon");
fn B2CastOutput rayCastCircle( B2RayCastInput* input, B2Circle* shape ) @cname("b2RayCastCircle");
fn B2CastOutput rayCastCapsule( B2RayCastInput* input, B2Capsule* shape ) @cname("b2RayCastCapsule");
fn B2CastOutput rayCastSegment( B2RayCastInput* input, B2Segment* shape, bool oneSided ) @cname("b2RayCastSegment");
fn B2CastOutput rayCastPolygon( B2RayCastInput* input, B2Polygon* shape ) @cname("b2RayCastPolygon");
fn B2CastOutput shapeCastCircle( B2ShapeCastInput* input, B2Circle* shape ) @cname("b2ShapeCastCircle");
fn B2CastOutput shapeCastCapsule( B2ShapeCastInput* input, B2Capsule* shape ) @cname("b2ShapeCastCapsule");
fn B2CastOutput shapeCastSegment( B2ShapeCastInput* input, B2Segment* shape ) @cname("b2ShapeCastSegment");
fn B2CastOutput shapeCastPolygon( B2ShapeCastInput* input, B2Polygon* shape ) @cname("b2ShapeCastPolygon");

struct B2Hull
{
    B2Vec2[MAX_POLYGON_VERTICES] points;
    int count;
}

fn B2Hull computeHull( B2Vec2* points, int count ) @cname("b2ComputeHull");
fn bool validateHull( B2Hull* hull ) @cname("b2ValidateHull");

struct B2SegmentDistanceResult @compact
{
    B2Vec2 closest1;
    B2Vec2 closest2;
    float fraction1;
    float fraction2;
    float distanceSquared;
}

fn B2SegmentDistanceResult segmentDistance( B2Vec2 p1, B2Vec2 q1, B2Vec2 p2, B2Vec2 q2 ) @cname("b2SegmentDistance");

struct B2DistanceProxy
{
    B2Vec2[MAX_POLYGON_VERTICES] points;
    int count;
    float radius;
}

struct B2DistanceCache
{
    short count;
    char[3] indexA;
    char[3] indexB;
}

// is this needed? c3 is a zero initialized language by default.
const B2DistanceCache EMPTY_DISTANCE_CACHE = {};

struct B2DistanceInput
{
    B2DistanceProxy proxyA;
    B2DistanceProxy proxyB;
    B2Transform transformA;
    B2Transform transformB;
    bool useRadii;
}

struct B2DistanceOutput
{
    B2Vec2 pointA;        
    B2Vec2 pointB;        
    float distance;       
    int iterations;   
    int simplexCount; 
}

struct B2SimplexVertex
{
    B2Vec2 wA;      
    B2Vec2 wB;      
    B2Vec2 w;       
    float a;        
    int indexA; 
    int indexB; 
}

struct B2Simplex
{
    B2SimplexVertex v1, v2, v3; 
    int count;              
}

fn B2DistanceOutput shapeDistance( B2DistanceCache* cache, B2DistanceInput* input, B2Simplex* simplexes, int simplexCapacity ) @cname("b2ShapeDistance");

struct B2ShapeCastPairInput
{
    B2DistanceProxy proxyA; 
    B2DistanceProxy proxyB; 
    B2Transform transformA; 
    B2Transform transformB; 
    B2Vec2 translationB;    
    float maxFraction;      
}

fn B2CastOutput shapeCast( B2ShapeCastPairInput* input ) @cname("b2ShapeCast");
fn B2DistanceProxy makeProxy( B2Vec2* vertices, int count, float radius ) @cname("b2MakeProxy");

struct B2Sweep @compact
{
    B2Vec2 localCenter; 
    B2Vec2 c1;          
    B2Vec2 c2;          
    B2Rot q1;           
    B2Rot q2;           
}

fn B2Transform getSweepTransform( B2Sweep* sweep, float time ) @cname("b2GetSweepTransform");

struct B2TOIInput
{
    B2DistanceProxy proxyA; 
    B2DistanceProxy proxyB; 
    B2Sweep sweepA;         
    B2Sweep sweepB;         
    float tMax;             
}

enum B2TOIState : int
{
    UNKNOWN,
    FAILED,
    OVERLAPPED,
    HIT,
    SEPARATED
}

struct B2TOIOutput
{
    B2TOIState state;
    float t;   
}

fn B2TOIOutput timeOfImpact( B2TOIInput* input ) @cname("b2TimeOfImpact");

struct B2ManifoldPoint
{
    B2Vec2 point;
    B2Vec2 anchorA;
    B2Vec2 anchorB;
    float separation;
    float normalImpulse;
    float tangentImpulse;
    float maxNormalImpulse;
    float normalVelocity;
    ushort id;
    bool persisted;
}

struct B2Manifold
{
    B2ManifoldPoint[2] points;
    B2Vec2 normal;
    int pointCount;
}

fn B2Manifold collideCircles( B2Circle* circleA, B2Transform xfA, B2Circle* circleB, B2Transform xfB ) @cname("b2CollideCircles");
fn B2Manifold collideCapsuleAndCircle( B2Capsule* capsuleA, B2Transform xfA, B2Circle* circleB, B2Transform xfB ) @cname("b2CollideCapsuleAndCircle");
fn B2Manifold collideSegmentAndCircle( B2Segment* segmentA, B2Transform xfA, B2Circle* circleB, B2Transform xfB ) @cname("b2CollideSegmentAndCircle");
fn B2Manifold collidePolygonAndCircle( B2Polygon* polygonA, B2Transform xfA, B2Circle* circleB, B2Transform xfB ) @cname("b2CollidePolygonAndCircle");
fn B2Manifold collideCapsules( B2Capsule* capsuleA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB ) @cname("b2CollideCapsules");
fn B2Manifold collideSegmentAndCapsule( B2Segment* segmentA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB ) @cname("b2CollideSegmentAndCapsule");
fn B2Manifold collidePolygonAndCapsule( B2Polygon* polygonA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB ) @cname("b2CollidePolygonAndCapsule");
fn B2Manifold collidePolygons( B2Polygon* polygonA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB ) @cname("b2CollidePolygons");
fn B2Manifold collideSegmentAndPolygon( B2Segment* segmentA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB ) @cname("b2CollideSegmentAndPolygon");
fn B2Manifold collideChainSegmentAndCircle( B2ChainSegment* segmentA, B2Transform xfA, B2Circle* circleB, B2Transform xfB ) @cname("b2CollideChainSegmentAndCircle");
fn B2Manifold collideChainSegmentAndCapsule( B2ChainSegment* segmentA, B2Transform xfA, B2Capsule* capsuleB, B2Transform xfB, B2DistanceCache* cache ) @cname("b2CollideChainSegmentAndCapsule");
fn B2Manifold collideChainSegmentAndPolygon( B2ChainSegment* segmentA, B2Transform xfA, B2Polygon* polygonB, B2Transform xfB, B2DistanceCache* cache ) @cname("b2CollideChainSegmentAndPolygon");

const DEFAULT_CATEGORY_BITS = 1;
const DEFAULT_MASK_BITS     = ulong.max; //( UINT64_MAX )

struct B2TreeNode
{
    B2AABBox aabb; // 16
    ulong categoryBits; // 8
    union
    {
        int parent;
        int next;
    } // 4
    int child1; // 4
    int child2; // 4
    // todo could be union with child index
    int userData; // 4
    short height; // 2
    bool enlarged; // 1
    CChar[5] pad;
}

struct B2DynamicTree
{
    B2TreeNode* nodes;
    int root;
    int nodeCount;
    int nodeCapacity;
    int freeList;
    int proxyCount;
    int* leafIndices;
    B2AABBox* leafBoxes;
    B2Vec2* leafCenters;
    int* binIndices;
    int rebuildCapacity;
}

fn B2DynamicTree dynamicTree_Create() @cname("b2DynamicTree_Create");
fn void dynamicTree_Destroy( B2DynamicTree* tree ) @cname("b2DynamicTree_Destroy");
fn int dynamicTree_CreateProxy( B2DynamicTree* tree, B2AABBox aabb, ulong categoryBits, int userData ) @cname("b2DynamicTree_CreateProxy");
fn void dynamicTree_DestroyProxy( B2DynamicTree* tree, int proxyId ) @cname("b2DynamicTree_DestroyProxy");
fn void dynamicTree_MoveProxy( B2DynamicTree* tree, int proxyId, B2AABBox aabb ) @cname("b2DynamicTree_MoveProxy");
fn void dynamicTree_EnlargeProxy( B2DynamicTree* tree, int proxyId, B2AABBox aabb ) @cname("b2DynamicTree_EnlargeProxy");

//typedef bool b2TreeQueryCallbackFcn( int proxyId, int userData, void* context );
alias B2TreeQueryCallback = fn bool(int,int,void*);

fn void dynamicTree_Query( B2DynamicTree* tree, B2AABBox aabb, ulong maskBits, B2TreeQueryCallback* callback, void* context ) @cname("b2DynamicTree_Query");

//typedef float b2TreeRayCastCallbackFcn( B2RayCastInput* input, int proxyId, int userData, void* context );
alias B2TreeRayCastCallback = fn float(B2RayCastInput*,int,int,void*);

fn void dynamicTree_RayCast( B2DynamicTree* tree, B2RayCastInput* input, ulong maskBits, B2TreeRayCastCallback* callback, void* context ) @cname("b2DynamicTree_RayCast");

//typedef float b2TreeShapeCastCallbackFcn( B2ShapeCastInput* input, int proxyId, int userData, void* context );
alias B2TreeShapeCastCallback = fn float(B2ShapeCastInput*,int,int,void*);

fn void dynamicTree_ShapeCast( B2DynamicTree* tree, B2ShapeCastInput* input, ulong maskBits, B2TreeShapeCastCallback* callback, void* context ) @cname("b2DynamicTree_ShapeCast");
fn void dynamicTree_Validate( B2DynamicTree* tree ) @cname("b2DynamicTree_Validate");
fn int  dynamicTree_GetHeight( B2DynamicTree* tree ) @cname("b2DynamicTree_GetHeight");
fn int  dynamicTree_GetMaxBalance( B2DynamicTree* tree ) @cname("b2DynamicTree_GetMaxBalance");
fn float dynamicTree_GetAreaRatio( B2DynamicTree* tree ) @cname("b2DynamicTree_GetAreaRatio");
fn void dynamicTree_RebuildBottomUp( B2DynamicTree* tree ) @cname("b2DynamicTree_RebuildBottomUp");
fn int dynamicTree_GetProxyCount( B2DynamicTree* tree ) @cname("b2DynamicTree_GetProxyCount");
fn int dynamicTree_Rebuild( B2DynamicTree* tree, bool fullBuild ) @cname("b2DynamicTree_Rebuild");
fn void dynamicTree_ShiftOrigin( B2DynamicTree* tree, B2Vec2 newOrigin ) @cname("b2DynamicTree_ShiftOrigin");
fn int dynamicTree_GetByteCount( B2DynamicTree* tree ) @cname("b2DynamicTree_GetByteCount");

// end_region Collision












// WARNING(HM) Most of this functions will not work as their symbols (func names) 
// are not exported in the current box2d static library, this may or may not change in future versions
// for now try to use Raylib or C3 math functions
// region MATH

alias B2Vec2 = float[<2>];

struct B2CosSin //@packed @align(4)
{
	float cosine;
	float sine;
}

struct B2Rot //@packed @align(4) @compact
{
    float c; // cosine and sine
    float s;
}

/// A 2D rigid transform
struct B2Transform //@packed @align(16) @compact
{
	B2Vec2 p;
	B2Rot q;
}

struct B2Mat22 //@compact
{
    B2Vec2 cx, cy;
}

struct B2AABBox
{
    B2Vec2 lowerBound;
    B2Vec2 upperBound;
}

const B2Vec2 VEC2_ZERO    = { 0.0f, 0.0f };
const B2Rot  ROT_IDENTITY = { 1.0f, 0.0f };
const B2Transform TRANSFORM_IDENTITY = { { 0.0f, 0.0f }, { 1.0f, 0.0f } };
const B2Mat22 MAT22_ZERO  = { { 0.0f, 0.0f }, { 0.0f, 0.0f } };


// Compute an approximate arctangent in the range [-pi, pi] This is hand coded for cross platform determinism.
fn float atan2(float y, float x) @cname("b2Atan2") @Exported;
/// Compute the cosine and sine of an angle in radians. Implemented
/// for cross-platform determinism.
fn B2CosSin computeCosSin( float radians ) @cname("b2ComputeCosSin") @Exported;

fn float minFloat(float a, float b) @cname("b2MinFloat");
fn float maxFloat(float a, float b) @cname("b2MaxFloat");
fn float absFloat(float a)          @cname("b2AbsFloat");
fn float clampFloat(float a, float lower, float upper) @cname("b2ClampFloat");
fn int 	 minInt(int a, int b) @cname("b2MinInt");
fn int 	 maxInt(int a, int b) @cname("b2MaxInt");
fn int 	 absInt(int a)        @cname("b2AbsInt");
fn int 	 clampInt(int a, int lower, int upper) @cname("b2ClampInt");
// Vector dot product.
fn float dot(B2Vec2 a, B2Vec2 b) @cname("b2Dot");
// Vector cross product. In 2D this yields a scalar.
fn float cross(B2Vec2 a, B2Vec2 b) @cname("b2Cross");
// Perform the cross product on a vector and a scalar. In 2D this produces a vector.
fn B2Vec2 crossVS(B2Vec2 v, float s) @cname("b2CrossVS");
// Perform the cross product on a scalar and a vector. In 2D this produces a vector.
fn B2Vec2 crossSV(float s, B2Vec2 v) @cname("b2CrossSV");
// Get a left pointing perpendicular vector. Equivalent to b2CrossSV(1.0f, v)
fn B2Vec2 leftPerp(B2Vec2 v) @cname("b2LeftPerp");
// Get a right pointing perpendicular vector. Equivalent to b2CrossVS(v, 1.0f)
fn B2Vec2 rightPerp (B2Vec2 v) @cname("b2RightPerp");
// Vector addition.
fn B2Vec2 add(B2Vec2 a, B2Vec2 b) @cname("b2Add");
// Vector subtraction.
fn B2Vec2 sub(B2Vec2 a, B2Vec2 b) @cname("b2Sub");
// Vector negation.
fn B2Vec2 neg(B2Vec2 a) @cname("b2Neg");
// Vector linear interpolation https://fgiesen.wordpress.com/2012/08/15/linear-interpolation-past-present-and-future/.
fn B2Vec2 lerp(B2Vec2 a, B2Vec2 b, float t) @cname("b2Lerp");
// Component-wise multiplication.
fn B2Vec2 mul(B2Vec2 a, B2Vec2 b) @cname("b2Mul");
// Multiply a scalar and vector.
fn B2Vec2 mulSV(float s, B2Vec2 v) @cname("b2MulSV");
// a + s * b
fn B2Vec2 mulAdd(B2Vec2 a, float s, B2Vec2 b) @cname("b2MulAdd");
// a - s * b
fn B2Vec2 mulSub(B2Vec2 a, float s, B2Vec2 b) @cname("b2MulSub");
 
/*
 
B2Vec2 	b2Abs (B2Vec2 a) @cname("b2MinInt");
 	Component-wise absolute vector.
 
B2Vec2 	b2Min (B2Vec2 a, B2Vec2 b) @cname("b2MinInt");
 	Component-wise minimum vector.
 
B2Vec2 	b2Max (B2Vec2 a, B2Vec2 b) @cname("b2MinInt");
 	Component-wise maximum vector.
*/
 
// Component-wise clamp vector v into the range [a, b].
fn B2Vec2 B2Vec2.clamp (B2Vec2 v, B2Vec2 a, B2Vec2 b) @cname("b2Clamp");
// Get the length of this vector (the norm)
//fn float B2Vec2.length(B2Vec2 v) @cname("b2Length");
// Get the distance between two points.
fn float distance(B2Vec2 a, B2Vec2 b) @cname("b2Distance");
// Convert a vector into a unit vector if possible, otherwise returns the zero vector.
fn B2Vec2 B2Vec2.normalize(B2Vec2 v) @cname("b2Normalize");
// Convert a vector into a unit vector if possible, otherwise returns the zero vector.
fn B2Vec2 getLengthAndNormalize (float* length, B2Vec2 v) @cname("b2GetLengthAndNormalize");
/*
B2Rot 	b2NormalizeRot (B2Rot q) @cname("b2MinInt");
 	Normalize rotation.
 
B2Rot 	b2IntegrateRotation (B2Rot q1, float deltaAngle) @cname("b2MinInt");
 	Integration rotation from angular velocity.
*/ 
 
// Get the length squared of this vector.
fn float B2Vec2.lengthSquared(B2Vec2 v) @cname("b2LengthSquared");
// Get the distance squared between points.
fn float distanceSquared(B2Vec2 a, B2Vec2 b) @cname("b2DistanceSquared");
//Make a rotation using an angle in radians.
//fn B2Rot makeRot(float angle) @cname("b2MakeRot");
// Is this rotation normalized?
fn bool B2Rot.isNormalized(B2Rot q) @cname("b2IsNormalized");
/*
fn B2Rot b2NLerp( B2Rot q1, B2Rot q2, float t );
fn float b2ComputeAngularVelocity( B2Rot q1, B2Rot q2, float inv_h );
fn float b2Rot_GetAngle( B2Rot q );
fn B2Vec2 b2Rot_GetXAxis( B2Rot q );
fn B2Vec2 b2Rot_GetYAxis( B2Rot q );
fn B2Rot b2MulRot( B2Rot q, B2Rot r );
fn B2Rot b2InvMulRot( B2Rot q, B2Rot r );
fn float b2RelativeAngle( B2Rot b, B2Rot a );
fn float b2UnwindAngle( float angle );
fn float b2UnwindLargeAngle( float angle );
fn B2Vec2 b2RotateVector( B2Rot q, B2Vec2 v );
fn B2Vec2 b2InvRotateVector( B2Rot q, B2Vec2 v );
fn B2Vec2 b2TransformPoint( B2Transform t, B2Vec2 p );
fn B2Vec2 b2InvTransformPoint( B2Transform t, B2Vec2 p );
fn B2Transform b2MulTransforms( B2Transform a, B2Transform b );
fn B2Transform b2InvMulTransforms( B2Transform a, B2Transform b );
fn B2Vec2 b2MulMV( Mat22 a, B2Vec2 v );
fn Mat22 b2GetInverse22( Mat22 a );
fn B2Vec2 b2Solve22( Mat22 A, B2Vec2 b );
fn bool b2AABB_Contains( b2AABB a, b2AABB b );
fn B2Vec2 b2AABB_Center( b2AABB a );
fn B2Vec2 b2AABB_Extents( b2AABB a );
fn b2AABB b2AABB_Union( b2AABB a, b2AABB b );
*/
fn bool isValid( float a ) @cname("b2IsValid") @Exported;
fn bool vec2_IsValid( B2Vec2 v ) @cname("b2Vec2_IsValid") @Exported;
fn bool rot_IsValid( B2Rot q ) @cname("b2Rot_IsValid") @Exported;
fn bool aabb_IsValid( B2AABBox aabb ) @cname("b2AABB_IsValid") @Exported;
<*
Box2D bases all length units on meters, but you may need different units for your game.

You can set this value to use different units. This should be done at application startup and only modified once. Default value is 1.

Warning
    This must be modified before any calls to Box2D
*>
fn void setLengthUnitsPerMeter( float lengthUnits ) @cname("b2SetLengthUnitsPerMeter") @Exported;
fn float getLengthUnitsPerMeter() @cname("b2GetLengthUnitsPerMeter") @Exported;



// region DEBUG

/// These colors are used for debug draw.
///	See https://www.rapidtables.com/web/color/index.html
typedef B2HexColor = inline int;
const B2HexColor ALICE_BLUE           = 0xf0f8ff;
const B2HexColor ANTIQUE_WHITE        = 0xfaebd7;
const B2HexColor AQUA                 = 0x00ffff;
const B2HexColor AQUAMARINE           = 0x7fffd4;
const B2HexColor AZURE                = 0xf0ffff;
const B2HexColor BEIGE                = 0xf5f5dc;
const B2HexColor BISQUE               = 0xffe4c4;
const B2HexColor BLACK                = 0x000000;
const B2HexColor BLANCHED_ALMOND      = 0xffebcd;
const B2HexColor BLUE                 = 0x0000ff;
const B2HexColor BLUE_VIOLET          = 0x8a2be2;
const B2HexColor BROWN                = 0xa52a2a;
const B2HexColor BURLYWOOD            = 0xdeb887;
const B2HexColor CADET_BLUE           = 0x5f9ea0;
const B2HexColor CHARTREUSE           = 0x7fff00;
const B2HexColor CHOCOLATE            = 0xd2691e;
const B2HexColor CORAL                = 0xff7f50;
const B2HexColor CORN_FLOWER_BLUE     = 0x6495ed;
const B2HexColor CORN_SILK            = 0xfff8dc;
const B2HexColor CRIMSON              = 0xdc143c;
const B2HexColor CYAN                 = 0x00ffff;
const B2HexColor DARK_BLUE            = 0x00008b;
const B2HexColor DARK_CYAN            = 0x008b8b;
const B2HexColor DARK_GOLDENROD       = 0xb8860b;
const B2HexColor DARK_GRAY            = 0xa9a9a9;
const B2HexColor DARK_GREEN           = 0x006400;
const B2HexColor DARK_KHAKI           = 0xbdb76b;
const B2HexColor DARK_MAGENTA         = 0x8b008b;
const B2HexColor DARK_OLIVEGREEN      = 0x556b2f;
const B2HexColor DARK_ORANGE          = 0xff8c00;
const B2HexColor DARK_ORCHID          = 0x9932cc;
const B2HexColor DARK_RED             = 0x8b0000;
const B2HexColor DARK_SALMON          = 0xe9967a;
const B2HexColor DARK_SEAGREEN        = 0x8fbc8f;
const B2HexColor DARK_SLATEBLUE       = 0x483d8b;
const B2HexColor DARK_SLATEGRAY       = 0x2f4f4f;
const B2HexColor DARK_TURQUOISE       = 0x00ced1;
const B2HexColor DARK_VIOLET          = 0x9400d3;
const B2HexColor DEEP_PINK            = 0xff1493;
const B2HexColor DEEP_SKYBLUE         = 0x00bfff;
const B2HexColor DIMGRAY              = 0x696969;
const B2HexColor DODGERBLUE           = 0x1e90ff;
const B2HexColor FIREBRICK            = 0xb22222;
const B2HexColor FLORALWHITE          = 0xfffaf0;
const B2HexColor FORESTGREEN          = 0x228b22;
const B2HexColor FUCHSIA              = 0xff00ff;
const B2HexColor GAINSBORO            = 0xdcdcdc;
const B2HexColor GHOSTWHITE           = 0xf8f8ff;
const B2HexColor GOLD                 = 0xffd700;
const B2HexColor GOLDENROD            = 0xdaa520;
const B2HexColor GRAY                 = 0xbebebe;
const B2HexColor GRAY1                = 0x1a1a1a;
const B2HexColor GRAY2                = 0x333333;
const B2HexColor GRAY3                = 0x4d4d4d;
const B2HexColor GRAY4                = 0x666666;
const B2HexColor GRAY5                = 0x7f7f7f;
const B2HexColor GRAY6                = 0x999999;
const B2HexColor GRAY7                = 0xb3b3b3;
const B2HexColor GRAY8                = 0xcccccc;
const B2HexColor GRAY9                = 0xe5e5e5;
const B2HexColor GREEN                = 0x00ff00;
const B2HexColor GREENYELLOW          = 0xadff2f;
const B2HexColor HONEYDEW             = 0xf0fff0;
const B2HexColor HOTPINK              = 0xff69b4;
const B2HexColor INDIANRED            = 0xcd5c5c;
const B2HexColor INDIGO               = 0x4b0082;
const B2HexColor IVORY                = 0xfffff0;
const B2HexColor KHAKI                = 0xf0e68c;
const B2HexColor LAVENDER             = 0xe6e6fa;
const B2HexColor LAVENDERBLUSH        = 0xfff0f5;
const B2HexColor LAWNGREEN            = 0x7cfc00;
const B2HexColor LEMONCHIFFON         = 0xfffacd;
const B2HexColor LIGHTBLUE            = 0xadd8e6;
const B2HexColor LIGHTCORAL           = 0xf08080;
const B2HexColor LIGHTCYAN            = 0xe0ffff;
const B2HexColor LIGHTGOLDENROD       = 0xeedd82;
const B2HexColor LIGHTGOLDENRODYELLOW = 0xfafad2;
const B2HexColor LIGHTGRAY            = 0xd3d3d3;
const B2HexColor LIGHTGREEN           = 0x90ee90;
const B2HexColor LIGHTPINK            = 0xffb6c1;
const B2HexColor LIGHTSALMON          = 0xffa07a;
const B2HexColor LIGHTSEAGREEN        = 0x20b2aa;
const B2HexColor LIGHTSKYBLUE         = 0x87cefa;
const B2HexColor LIGHTSLATEBLUE       = 0x8470ff;
const B2HexColor LIGHTSLATEGRAY       = 0x778899;
const B2HexColor LIGHTSTEELBLUE       = 0xb0c4de;
const B2HexColor LIGHTYELLOW          = 0xffffe0;
const B2HexColor LIME                 = 0x00ff00;
const B2HexColor LIMEGREEN            = 0x32cd32;
const B2HexColor LINEN                = 0xfaf0e6;
const B2HexColor MAGENTA              = 0xff00ff;
const B2HexColor MAROON               = 0xb03060;
const B2HexColor MEDIUMAQUAMARINE     = 0x66cdaa;
const B2HexColor MEDIUMBLUE           = 0x0000cd;
const B2HexColor MEDIUMORCHID         = 0xba55d3;
const B2HexColor MEDIUMPURPLE         = 0x9370db;
const B2HexColor MEDIUMSEAGREEN       = 0x3cb371;
const B2HexColor MEDIUMSLATEBLUE      = 0x7b68ee;
const B2HexColor MEDIUMSPRINGGREEN    = 0x00fa9a;
const B2HexColor MEDIUMTURQUOISE      = 0x48d1cc;
const B2HexColor MEDIUMVIOLETRED      = 0xc71585;
const B2HexColor MIDNIGHTBLUE         = 0x191970;
const B2HexColor MINTCREAM            = 0xf5fffa;
const B2HexColor MISTYROSE            = 0xffe4e1;
const B2HexColor MOCCASIN             = 0xffe4b5;
const B2HexColor NAVAJOWHITE          = 0xffdead;
const B2HexColor NAVY                 = 0x000080;
const B2HexColor NAVYBLUE             = 0x000080;
const B2HexColor OLDLACE              = 0xfdf5e6;
const B2HexColor OLIVE                = 0x808000;
const B2HexColor OLIVEDRAB            = 0x6b8e23;
const B2HexColor ORANGE               = 0xffa500;
const B2HexColor ORANGERED            = 0xff4500;
const B2HexColor ORCHID               = 0xda70d6;
const B2HexColor PALEGOLDENROD        = 0xeee8aa;
const B2HexColor PALEGREEN            = 0x98fb98;
const B2HexColor PALETURQUOISE        = 0xafeeee;
const B2HexColor PALEVIOLETRED        = 0xdb7093;
const B2HexColor PAPAYAWHIP           = 0xffefd5;
const B2HexColor PEACHPUFF            = 0xffdab9;
const B2HexColor PERU                 = 0xcd853f;
const B2HexColor PINK                 = 0xffc0cb;
const B2HexColor PLUM                 = 0xdda0dd;
const B2HexColor POWDERBLUE           = 0xb0e0e6;
const B2HexColor PURPLE               = 0xa020f0;
const B2HexColor REBECCAPURPLE        = 0x663399;
const B2HexColor RED                  = 0xff0000;
const B2HexColor ROSYBROWN            = 0xbc8f8f;
const B2HexColor ROYALBLUE            = 0x4169e1;
const B2HexColor SADDLEBROWN          = 0x8b4513;
const B2HexColor SALMON               = 0xfa8072;
const B2HexColor SANDYBROWN           = 0xf4a460;
const B2HexColor SEAGREEN             = 0x2e8b57;
const B2HexColor SEASHELL             = 0xfff5ee;
const B2HexColor SIENNA               = 0xa0522d;
const B2HexColor SILVER               = 0xc0c0c0;
const B2HexColor SKYBLUE              = 0x87ceeb;
const B2HexColor SLATEBLUE            = 0x6a5acd;
const B2HexColor SLATEGRAY            = 0x708090;
const B2HexColor SNOW                 = 0xfffafa;
const B2HexColor SPRINGGREEN          = 0x00ff7f;
const B2HexColor STEELBLUE            = 0x4682b4;
const B2HexColor TAN                  = 0xd2b48c;
const B2HexColor TEAL                 = 0x008080;
const B2HexColor THISTLE              = 0xd8bfd8;
const B2HexColor TOMATO               = 0xff6347;
const B2HexColor TURQUOISE            = 0x40e0d0;
const B2HexColor VIOLET               = 0xee82ee;
const B2HexColor VIOLETRED            = 0xd02090;
const B2HexColor WHEAT                = 0xf5deb3;
const B2HexColor WHITE                = 0xffffff;
const B2HexColor WHITESMOKE           = 0xf5f5f5;
const B2HexColor YELLOW               = 0xffff00;
const B2HexColor YELLOWGREEN          = 0x9acd32;
const B2HexColor BOX2DRED             = 0xdc3132;
const B2HexColor BOX2DBLUE            = 0x30aebf;
const B2HexColor BOX2DGREEN           = 0x8cc924;
const B2HexColor BOX2DYELLOW          = 0xffee8c;

<*
This struct holds callbacks you can implement to draw a Box2D world.
*>
alias B2DrawPolygonCallback      = fn void(B2Vec2*,int,B2HexColor,void*);
alias B2DrawSolidPolygonCallback = fn void(B2Transform,B2Vec2*,int,float,B2HexColor,void*);
alias B2DrawCircleCallback       = fn void(B2Vec2,float,B2HexColor,void*);
alias B2DrawSolidCircleCallback  = fn void(B2Transform,float,B2HexColor,void*);
alias B2DrawCapsuleCallback      = fn void(B2Vec2,B2Vec2,float,B2HexColor,void*);
alias B2DrawSolidCapsuleCallback = fn void(B2Vec2,B2Vec2,float,B2HexColor,void*);
alias B2DrawSegmentCallback      = fn void(B2Vec2,B2Vec2,B2HexColor,void*);
alias B2DrawTransformCallback    = fn void(B2Transform,void*);
alias B2DrawPointCallback        = fn void(B2Vec2,float,B2HexColor,void*);
alias B2DrawStringCallback       = fn void(B2Vec2,ZString,void*);

struct B2DebugDraw
{
	/// Draw a closed polygon provided in CCW order.
	//void ( *DrawPolygon )( const B2Vec2* vertices, int vertexCount, b2HexColor color, void* context );
    B2DrawPolygonCallback drawPolygon;
	/// Draw a solid closed polygon provided in CCW order.
	//void ( *DrawSolidPolygon )( B2Transform transform, const B2Vec2* vertices, int vertexCount, float radius, b2HexColor color, void* context );
    B2DrawSolidPolygonCallback drawSolidPolygon; 
	//void ( *DrawCircle )( B2Vec2 center, float radius, b2HexColor color, void* context );
    B2DrawCircleCallback drawCircle;
	//void ( *DrawSolidCircle )( B2Transform transform, float radius, b2HexColor color, void* context );
    B2DrawSolidCircleCallback drawSolidCircle;
	//void ( *DrawCapsule )( B2Vec2 p1, B2Vec2 p2, float radius, b2HexColor color, void* context );
    B2DrawCapsuleCallback drawCapsule;
	//void ( *DrawSolidCapsule )( B2Vec2 p1, B2Vec2 p2, float radius, b2HexColor color, void* context );
    B2DrawSolidCapsuleCallback drawSolidCapsule;
	/// Draw a line segment.
	//void ( *DrawSegment )( B2Vec2 p1, B2Vec2 p2, b2HexColor color, void* context );
    B2DrawSegmentCallback drawSegment;
	/// Draw a transform. Choose your own length scale.
	//void ( *DrawTransform )( B2Transform transform, void* context );
    B2DrawTransformCallback drawTransform;
	//void ( *DrawPoint )( B2Vec2 p, float size, b2HexColor color, void* context );
    B2DrawPointCallback drawPoint;
	//void ( *DrawString )( B2Vec2 p, const char* s, void* context );
    B2DrawStringCallback drawString;
    
	/// Bounds to use if restricting drawing to a rectangular region
	B2AABBox drawingBounds;

	/// Option to restrict drawing to a rectangular region. May suffer from unstable depth sorting.
	bool useDrawingBounds;

	/// Option to draw shapes
	bool drawShapes;

	/// Option to draw joints
	bool drawJoints;

	/// Option to draw additional information for joints
	bool drawJointExtras;

	/// Option to draw the bounding boxes for shapes
	bool drawAABBs;

	/// Option to draw the mass and center of mass of dynamic bodies
	bool drawMass;

	/// Option to draw contact points
	bool drawContacts;

	/// Option to visualize the graph coloring used for contacts and joints
	bool drawGraphColors;

	/// Option to draw contact normals
	bool drawContactNormals;

	/// Option to draw contact normal impulses
	bool drawContactImpulses;

	/// Option to draw contact friction impulses
	bool drawFrictionImpulses;

	/// User context that is passed as an argument to drawing callback functions
	void* context;
}

fn B2DebugDraw defaultDebugDraw() @cname("b2DefaultDebugDraw");

// end_region DEBUG
