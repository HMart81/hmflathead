module thirdparty::raylib5::rl;

import std::math::vector;
import engine::misc;

const float PI = 3.14159265358979323846f;
const float DEG2RAD = PI / 180.0f;
const float RAD2DEG = 180.0f / PI;
const ZString VERSION = "5.5";

macro CInt glsl_version() {
$if env::WIN32 || env::LINUX: //$defined(PLATFORM_DESKTOP):
    return 330;
$else   // PLATFORM_ANDROID, PLATFORM_WEB
    return 100;
$endif
}

alias GLFWwindow = void*;
fn GLFWwindow getOpenGLContext() @cname("glfwGetCurrentContext");
//----------------------------------------------------------------------------------
const CUInt GL_VENDOR = 0x1F00;
// Returns the company responsible for this GL implementation. 
// This name does not change from release to release.
const CUInt GL_RENDERER = 0x1F01;
// Returns the name of the renderer. 
// This name is typically specific to a particular configuration of a hardware platform. 
// It does not change from release to release.

// requires opengl context run after window creation
<*
    @param name : "GL_VENDOR or GL_RENDERER"
    @require name == GL_VENDOR || name == GL_RENDERER
*>
fn ZString glGetString(CUInt name) @cname("glGetString");
macro ZString getGLVendor() => glGetString(GL_VENDOR); // gets GPU vendor name
macro ZString getGLRenderer() => glGetString(GL_RENDERER); // gets GPU model name
//----------------------------------------------------------------------------------

// Some Basic Colors
// NOTE: Custom raylib color palette for amazing visuals on WHITE background
const RLColor LIGHTGRAY   = { 200, 200, 200, 255 };   // Light Gray
const RLColor GRAY        = { 130, 130, 130, 255 };   // Gray
const RLColor DARKGRAY    = { 80, 80, 80, 255 };      // Dark Gray
const RLColor YELLOW      = { 253, 249, 0, 255 };     // Yellow
const RLColor GOLD        = { 255, 203, 0, 255 };     // Gold
const RLColor ORANGE      = { 255, 161, 0, 255 };     // Orange
const RLColor PINK        = { 255, 109, 194, 255 };   // Pink
const RLColor RED         = { 230, 41, 55, 255 };     // Red
const RLColor MAROON      = { 190, 33, 55, 255 };     // Maroon
const RLColor GREEN       = { 0, 228, 48, 255 };      // Green
const RLColor LIME        = { 0, 158, 47, 255 };      // Lime
const RLColor DARKGREEN   = { 0, 117, 44, 255 };      // Dark Green
const RLColor SKYBLUE     = { 102, 191, 255, 255 };   // Sky Blue
const RLColor BLUE        = { 0, 121, 241, 255 };     // Blue
const RLColor DARKBLUE    = { 0, 82, 172, 255 };      // Dark Blue
const RLColor PURPLE      = { 200, 122, 255, 255 };   // Purple
const RLColor VIOLET      = { 135, 60, 190, 255 };    // Violet
const RLColor DARKPURPLE  = { 112, 31, 126, 255 };    // Dark Purple
const RLColor BEIGE       = { 211, 176, 131, 255 };   // Beige
const RLColor BROWN       = { 127, 106, 79, 255 };    // Brown
const RLColor DARKBROWN   = { 76, 63, 47, 255 };      // Dark Brown

const RLColor WHITE       = { 255, 255, 255, 255 };   // White
const RLColor BLACK       = { 0, 0, 0, 255 };         // Black
const RLColor BLANK       = { 0, 0, 0, 0 };           // Blank (Transparent)
const RLColor MAGENTA     = { 255, 0, 255, 255 };     // Magenta
const RLColor RAYWHITE    = { 245, 245, 245, 255 };   // My own White (raylib logo)

/// Converts a COMPILE TIME hex color value to a RLColor struct.
macro @hexToColor($hexValue) @builtin
{
  var rgbColor = WHITE;
  rgbColor.r = (char)(($hexValue >> 16) & 0xFF);  // Extract the RR byte
  rgbColor.g = (char)(($hexValue >> 8) & 0xFF);   // Extract the GG byte
  rgbColor.b = (char)(($hexValue) & 0xFF);        // Extract the BB byte

  return rgbColor;
}

macro RLVector2.toVec2i(&self) => (Vec2i) {(CInt)self.x, (CInt)self.y};

alias RLVector2 = Vec2f;
alias RLVector3 = Vec3f;
alias RLVector4 = Vec4f;

// RLQuaternion, 4 components (RLVector4 alias)
alias RLQuaternion = RLVector4;

// RLMatrix, 4x4 components, column major, OpenGL style, right handed
struct RLMatrix @compact
{
    float m0, m4, m8, m12;  // RLMatrix first row (4 components)
    float m1, m5, m9, m13;  // RLMatrix second row (4 components)
    float m2, m6, m10, m14; // RLMatrix third row (4 components)
    float m3, m7, m11, m15; // RLMatrix fourth row (4 components)
}

// RLColor, 4 components, R8G8B8A8 (32bit)
struct RLColor
{
    char r;        // RLColor red value
    char g;        // RLColor green value
    char b;        // RLColor blue value
    char a;        // RLColor alpha value
}

macro bool RLColor.eql(&self, RLColor other) @operator(==)
{
    return ( self.r == other.r &&
             self.g == other.g &&
             self.b == other.b &&
             self.a == other.a );
}

macro bool RLColor.neql(&self, RLColor other) @operator(!=)
{
    return ( self.r != other.r ||
             self.g != other.g ||
             self.b != other.b ||
             self.a != other.a );
}

// RLRectangle, 4 components
union RLRectangle
{
    struct {
        float x;                // RLRectangle top-left corner position x
        float y;                // RLRectangle top-left corner position y
        float width;            // RLRectangle width
        float height;           // RLRectangle height
    }
    struct {
        RLVector2 pos;
        RLVector2 size;
    }
}

macro bool RLRectangle.eql(&self, RLRectangle other) @operator(==)
{
    return (self.pos == other.pos && self.size == other.size);
}

macro bool RLRectangle.neql(&self, RLRectangle other) @operator(!=)
{
    return (self.pos != other.pos || self.size != other.size);
}

//macro RLVector2 RLRectangle.getPosition(&self)  => { self.x, self.y }; // in world coords
//macro RLVector2 RLRectangle.getSize(&self) => { self.width, self.height }; // in pixel coords

macro RLVector2 RLRectangle.getPosition(&self)  => self.pos; // in world coords
macro RLVector2 RLRectangle.getSize(&self) => self.size; // in pixel coords


// RLImage, pixel data stored in CPU memory (RAM)
struct RLImage
{
    void* data;             // RLImage raw data
    CInt width;             // RLImage base width
    CInt height;            // RLImage base height
    CInt mipmaps;           // Mipmap levels, 1 by default
    RLPixelFormat format;     // Data format (RLPixelFormat type)
}

// RLTexture, tex data stored in GPU memory (VRAM)
struct RLTexture @packed
{
    CUInt id;                // OpenGL texture id
    CInt width;              // RLTexture base width
    CInt height;             // RLTexture base height
    CInt mipmaps;            // Mipmap levels, 1 by default
    RLPixelFormat format;     // Data format (RLPixelFormat type)
}

macro Vec2f RLTexture.getSize(&self) @nodiscard
{
    return (Vec2f){ (float)self.width, (float)self.height };
}

macro bool RLTexture.eql(&self, RLTexture other) @operator(==)
{
    return (bool)(self.id == other.id &&
           self.width == other.width &&
           self.height == other.height &&
           self.mipmaps == other.mipmaps &&
           self.format == other.format);
}

macro bool RLTexture.neql(&self, RLTexture other) @operator(!=)
{
    return (bool)(self.id != other.id ||
           self.width != other.width ||
           self.height != other.height ||
           self.mipmaps != other.mipmaps ||
           self.format != other.format);
}

// RLTexture2D, same as RLTexture
alias RLTexture2D = RLTexture;
// C3 is a zero initialized language so this is done automatically 
// but sometimes it's better to be explicit
const INVALID_TEXTURE = (RLTexture2D){0, 0, 0, 0, (RLPixelFormat)0};

// RLTextureCubemap, same as RLTexture
alias RLTextureCubemap = RLTexture;

// RLRenderTexture, fbo for texture rendering
struct RLRenderTexture
{
    CUInt id;                // OpenGL framebuffer object id
    RLTexture texture;        // RLColor buffer attachment texture
    RLTexture depth;          // Depth buffer attachment texture
}

// RLRenderTexture2D, same as RLRenderTexture
alias RLRenderTexture2D = RLRenderTexture;

// NPatchInfo, n-patch layout info
struct NPatchInfo
{
    RLRectangle source;       // RLTexture source rectangle
    CInt left;               // Left border offset
    CInt top;                // Top border offset
    CInt right;              // Right border offset
    CInt bottom;             // Bottom border offset
    RLNPatchLayout layout;    // Layout of the n-patch: 3x3, 1x3 or 3x1
}

// GlyphInfo, font characters glyphs info
struct GlyphInfo
{
    CInt value;              // Character value (Unicode)
    CInt offsetX;            // Character offset X when drawing
    CInt offsetY;            // Character offset Y when drawing
    CInt advanceX;           // Character advance position X
    RLImage image;            // Character CPU/RAM image data
}

// RLFont, font texture and GlyphInfo array data
struct RLFont
{
    CInt baseSize;           // Base size (default chars height)
    CInt glyphCount;         // Number of glyph characters
    CInt glyphPadding;       // Padding around the glyph characters
    RLTexture2D texture;      // RLTexture atlas containing the glyphs
    RLRectangle* recs;        // Rectangles in texture for the glyphs
    GlyphInfo* glyphs;      // Glyphs info data
}

// RLCamera, defines position/orientation in 3d space
struct RLCamera3D
{
    RLVector3 position;               // RLCamera position
    RLVector3 target;                 // RLCamera target it looks-at
    RLVector3 up;                     // RLCamera up vector (rotation over its axis)
    float fovy;                     // RLCamera field-of-view apperture in Y (degrees) in perspective, used as near plane width in orthographic
    RLCameraProjection projection;    // RLCamera projection: CAMERA_PERSPECTIVE or CAMERA_ORTHOGRAPHIC
}

alias RLCamera = RLCamera3D;    // RLCamera type fallback, defaults to RLCamera3D

// RLCamera2D, defines position/orientation in 2d space
struct RLCamera2D
{
    RLVector2 offset;         // RLCamera offset (displacement from target)
    RLVector2 target;         // RLCamera target (rotation and zoom origin)
    float rotation;         // RLCamera rotation in degrees
    float zoom;             // RLCamera zoom (scaling), should be 1.0f by default
}

// RLMesh, vertex data and vao/vbo
struct RLMesh
{
    CInt vertexCount;        // Number of vertices stored in arrays
    CInt triangleCount;      // Number of triangles stored (indexed or not)

    // Vertex attributes data
    float* vertices;        // Vertex position (XYZ - 3 components per vertex) (shader-location = 0)
    float* texcoords;       // Vertex texture coordinates (UV - 2 components per vertex) (shader-location = 1)
    float* texcoords2;      // Vertex second texture coordinates (useful for lightmaps) (shader-location = 5)
    float* normals;         // Vertex normals (XYZ - 3 components per vertex) (shader-location = 2)
    float* tangents;        // Vertex tangents (XYZW - 4 components per vertex) (shader-location = 4)
    char* colors;           // Vertex colors (RGBA - 4 components per vertex) (shader-location = 3)
    ushort *indices;        // Vertex indices (in case vertex data comes indexed)

    // Animation vertex data
    float* animVertices;    // Animated vertex positions (after bones transformations)
    float* animNormals;     // Animated normals (after bones transformations)
    char* boneIds;          // Vertex bone ids, max 255 bone ids, up to 4 bones influence by vertex (skinning)
    float* boneWeights;     // Vertex bone weight, up to 4 bones influence by vertex (skinning)
    RLMatrix *boneMatrices;   // Bones animated transformation matrices
    CInt boneCount;          // Number of bones

    // OpenGL identifiers
    CUInt vaoId;             // OpenGL Vertex Array Object id
    CUInt* vboId;            // OpenGL Vertex Buffer Objects id (default vertex data)
}

struct RLShader
{
    CUInt id;                // RLShader program id
    CInt* locs;              // RLShader locations array (RL_MAX_SHADER_LOCATIONS)
}

macro bool RLShader.equal(&self, RLShader other) @operator(==)
{
    return (bool)(self.id == other.id && self.locs == other.locs);
}

macro bool RLShader.nequal(&self, RLShader other) @operator(!=)
{
    return (bool)(self.id != other.id || self.locs != other.locs);
}

macro bool RLShader.isValid(&self)
{
    const INVALID_ID = 0x00ff00ff;
    return (bool)(self.id != INVALID_ID && self.id != 0);
}

/*
    DOC(HM) RLMaterialMap
    Usage:
        The value field is often used to represent properties like metalness, 
        roughness, or other scalar material characteristics in 
        physically-based rendering (PBR) materials. 
    Example:
        model.materials[0].maps[MATERIAL_MAP_METALNESS].value = 1.0f; 
            sets the metalness value, and 
        model.materials[0].maps[MATERIAL_MAP_ROUGHNESS].value = 0.0f; 
            sets the roughness value for the first material of a model. 
*/
struct RLMaterialMap
{
    RLTexture2D texture;      // RLMaterial map texture
    RLColor color;            // RLMaterial map color
    float value;            // RLMaterial map generic value
}

// RLMaterial, includes shader and maps
struct RLMaterial
{
    RLShader shader;          // RLMaterial shader
    RLMaterialMap* maps;      // RLMaterial maps array (MAX_MATERIAL_MAPS)
    float[4] params;        // RLMaterial generic parameters (if required)
}

// RLTransform, vectex transformation data
struct RLTransform
{
    RLVector3 translation;    // Translation
    RLQuaternion rotation;    // Rotation
    RLVector3 scale;          // Scale
}

// Bone, skeletal animation bone
struct RLBoneInfo
{
    CChar[32] name;          // Bone name
    CInt parent;             // Bone parent
}

// RLModel, meshes, materials and animation data
struct RLModel
{
    RLMatrix transform;       // Local transform matrix

    CInt meshCount;          // Number of meshes
    CInt materialCount;      // Number of materials
    RLMesh* meshes;           // Meshes array
    RLMaterial* materials;    // Materials array
    CInt* meshMaterial;      // RLMesh material number

    // Animation data
    CInt boneCount;          // Number of bones
    RLBoneInfo* bones;        // Bones information (skeleton)
    RLTransform* bindPose;    // Bones base transformation (pose)
}

// RLModelAnimation
struct RLModelAnimation
{
    CInt boneCount;          // Number of bones
    CInt frameCount;         // Number of animation frames
    RLBoneInfo* bones;        // Bones information (skeleton)
    RLTransform** framePoses; // Poses array by frame
}

// RLRay, ray for raycasting
struct RLRay
{
    RLVector3 position;       // RLRay position (origin)
    RLVector3 direction;      // RLRay direction (normalized)
}

// RLRayCollision, ray hit information
struct RLRayCollision
{
    bool hit;               // Did the ray hit something?
    float distance;         // Distance to nearest hit
    RLVector3 point;          // Point of nearest hit
    RLVector3 normal;         // Surface normal of hit
}

// RLBoundingBox
struct RLBoundingBox //@compact
{
    RLVector3 min;            // Minimum vertex box-corner
    RLVector3 max;            // Maximum vertex box-corner
}

// RLWave, audio wave data
struct RLWave
{
    CUInt frameCount;            // Total number of frames (considering channels)
    CUInt sampleRate;            // Frequency (samples per second)
    CUInt sampleSize;            // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    CUInt channels;              // Number of channels (1-mono, 2-stereo, ...)
    void* data;                 // Buffer data pointer
}

alias RLAudioBufferRef = void*;
alias RLAudioProcessorRef = void*;

// RLAudioStream, custom audio stream
struct RLAudioStream
{
    RLAudioBufferRef buffer;       // Pointer to internal data used by the audio system
	RLAudioProcessorRef processor; // Pointer to internal data processor, useful for audio effects

    CUInt sampleRate;             // Frequency (samples per second)
    CUInt sampleSize;             // Bit depth (bits per sample): 8, 16, 32 (24 not supported)
    CUInt channels;               // Number of channels (1-mono, 2-stereo, ...)
}


// RLSound
struct RLSound
{
    RLAudioStream stream;         // Audio stream
    CUInt frameCount;            // Total number of frames (considering channels)
}

// RLMusic, audio stream, anything longer than ~10 seconds should be streamed
struct RLMusic
{
    RLAudioStream stream;         // Audio stream
    CUInt frameCount;            // Total number of frames (considering channels)
    bool looping;               // RLMusic looping enable

    CInt ctxType;                // Type of music context (audio filetype)
    void* ctxData;              // Audio context data, depends on type
}

// RLVrDeviceInfo, Head-Mounted-Display device parameters
struct RLVrDeviceInfo
{
    CInt hResolution;                // Horizontal resolution in pixels
    CInt vResolution;                // Vertical resolution in pixels
    float hScreenSize;              // Horizontal size in meters
    float vScreenSize;              // Vertical size in meters
    float vScreenCenter;            // Screen center in meters
    float eyeToScreenDistance;      // Distance between eye and display in meters
    float lensSeparationDistance;   // Lens separation distance in meters
    float interpupillaryDistance;   // IPD (distance between pupils) in meters
    float[4] lensDistortionValues;  // Lens distortion constant parameters
    float[4] chromaAbCorrection;    // Chromatic aberration correction parameters
}

// RLVrStereoConfig, VR stereo rendering configuration for simulator
struct RLVrStereoConfig
{
    RLMatrix[2] projection;           // VR projection matrices (per eye)
    RLMatrix[2] viewOffset;           // VR view offset matrices (per eye)
    float[2] leftLensCenter;        // VR left lens center
    float[2] rightLensCenter;       // VR right lens center
    float[2] leftScreenCenter;      // VR left screen center
    float[2] rightScreenCenter;     // VR right screen center
    float[2] scale;                 // VR distortion scale
    float[2] scaleIn;               // VR distortion scale in
}

struct RLFilePathList
{
    CUInt capacity;                  // Filepaths max entries
    CUInt count;                     // Filepaths entries count
    ZString* paths;                 // Filepaths entries
}

// Automation event
struct RLAutomationEvent
{
    CUInt frame;                     // Event frame
    CUInt type;                      // Event type (AutomationEventType)
    CInt[4] params;                  // Event parameters (if required)
}

// Automation event list
struct RLAutomationEventList
{
    CUInt capacity;                  // Events max entries (MAX_AUTOMATION_EVENTS)
    CUInt count;                     // Events entries count
    RLAutomationEvent* events;        // Events entries
}

// Trace log level
// NOTE: Organized by priority level
enum RLTraceLogLevel : const inline CInt
{
    ALL = 0,        // Display all logs (0)
    TRACE,          // Trace logging, intended for internal use only
    DEBUG,          // Debug logging, used for internal debugging, it should be disabled on release builds
    INFO,           // Info logging, used for program execution info
    WARNING,        // Warning logging, used on recoverable failures
    ERROR,          // Error logging, used on unrecoverable failures
    FATAL,          // Fatal logging, used to abort program: exit(EXIT_FAILURE)
    NONE            // Disable logging
}

// Mouse buttons
enum RLMouseButton : const inline CInt
{
    LEFT = 0,       // Mouse button left
    RIGHT,      // Mouse button right
    MIDDLE,     // Mouse button middle (pressed wheel)
    SIDE,       // Mouse button side (advanced mouse device)
    EXTRA,      // Mouse button extra (advanced mouse device)
    FORWARD,    // Mouse button fordward (advanced mouse device)
    BACK,       // Mouse button back (advanced mouse device)
}

// Mouse cursor
enum RLMouseCursor : const CInt
{
    DEFAULT = 0,       // Default pointer shape
    ARROW,         // Arrow shape
    IBEAM,         // Text writing cursor shape
    CROSSHAIR,     // Cross shape
    POINTING_HAND, // Pointing hand cursor
    RESIZE_EW,     // Horizontal resize/move arrow shape
    RESIZE_NS,     // Vertical resize/move arrow shape
    RESIZE_NWSE,   // Top-left to bottom-right diagonal resize/move arrow shape
    RESIZE_NESW,   // The top-right to bottom-left diagonal resize/move arrow shape
    RESIZE_ALL,    // The omni-directional resize/move cursor shape
    NOT_ALLOWED    // The operation-not-allowed shape
}

// Gamepad buttons
enum RLGamepadButton : const CInt
{
    UNKNOWN = 0,             // Unknown button, just for error checking
    LEFT_FACE_UP,        // Gamepad left DPAD up button
    LEFT_FACE_RIGHT,     // Gamepad left DPAD right button
    LEFT_FACE_DOWN,      // Gamepad left DPAD down button
    LEFT_FACE_LEFT,      // Gamepad left DPAD left button
    RIGHT_FACE_UP,       // Gamepad right button up (i.e. PS3: Triangle, Xbox: Y)
    RIGHT_FACE_RIGHT,    // Gamepad right button right (i.e. PS3: Square, Xbox: X)
    RIGHT_FACE_DOWN,     // Gamepad right button down (i.e. PS3: Cross, Xbox: A)
    RIGHT_FACE_LEFT,     // Gamepad right button left (i.e. PS3: Circle, Xbox: B)
    LEFT_TRIGGER_1,      // Gamepad top/back trigger left (first), it could be a trailing button
    LEFT_TRIGGER_2,      // Gamepad top/back trigger left (second), it could be a trailing button
    RIGHT_TRIGGER_1,     // Gamepad top/back trigger right (one), it could be a trailing button
    RIGHT_TRIGGER_2,     // Gamepad top/back trigger right (second), it could be a trailing button
    MIDDLE_LEFT,         // Gamepad center buttons, left one (i.e. PS3: Select)
    MIDDLE,              // Gamepad center buttons, middle one (i.e. PS3: PS, Xbox: XBOX)
    MIDDLE_RIGHT,        // Gamepad center buttons, right one (i.e. PS3: Start)
    LEFT_THUMB,          // Gamepad joystick pressed button left
    RIGHT_THUMB          // Gamepad joystick pressed button right
}

enum RLGamepadAxis : const CInt
{
    LEFT_X = 0,           // Gamepad left stick X axis
    LEFT_Y,           // Gamepad left stick Y axis
    RIGHT_X,          // Gamepad right stick X axis
    RIGHT_Y,          // Gamepad right stick Y axis
    LEFT_TRIGGER,     // Gamepad back trigger left, pressure level: [1..-1]
    RIGHT_TRIGGER     // Gamepad back trigger right, pressure level: [1..-1]
}

// RLMaterial map index
enum RLMtlMapIndex : const inline CInt
{
    ALBEDO = 0,            // Albedo material (same as: MATERIAL_MAP_DIFFUSE)
    METALNESS,         // Metalness material (same as: MATERIAL_MAP_SPECULAR)
    NORMAL,            // Normal material
    ROUGHNESS,         // Roughness material
    OCCLUSION,         // Ambient occlusion material
    EMISSION,          // Emission material
    HEIGHT,            // Heightmap material
    CUBEMAP,           // Cubemap material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    IRRADIANCE,        // Irradiance material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    PREFILTER,         // Prefilter material (NOTE: Uses GL_TEXTURE_CUBE_MAP)
    BRDF,              // Brdf material
    DEPTH0,            // New depth map index shadow for light1
    DEPTH1,            // New depth map index shadow for light2
    DEPTH2,            // New depth map index shadow for light3
    DEPTH3             // New depth map index shadow for light4
}

const MATERIAL_MAP_DIFFUSE  = RLMtlMapIndex.ALBEDO;
const MATERIAL_MAP_SPECULAR = RLMtlMapIndex.METALNESS;

// RLShader location index
// NOTE: str is the identifier you should write in your glsl shader code!
// this is so is easy to parse the shader code and find the location
enum RLShdLocInd : inline CInt (String str)
{
    VERTEX_POSITION   = "vertexPosition",  // RLShader location: vertex attribute: position
    VERTEX_TEXCOORD01 = "vertexTexCoord1",  // RLShader location: vertex attribute: texcoord01
    VERTEX_NORMAL     = "vertexNormal",  // RLShader location: vertex attribute: normal
    VERTEX_COLOR      = "vertexColor",  // RLShader location: vertex attribute: color
    VERTEX_TANGENT    = "vertexTangent",  // RLShader location: vertex attribute: tangent
    VERTEX_TEXCOORD02 = "vertexTexCoord2",  // RLShader location: vertex attribute: texcoord02
    MATRIX_MVP        = "mvp",  // RLShader location: matrix uniform: model-view-projection
    MATRIX_VIEW       = "matView",  // RLShader location: matrix uniform: view (camera transform)
    MATRIX_PROJECTION = "matProjection",  // RLShader location: matrix uniform: projection
    MATRIX_MODEL      = "matModel",  // RLShader location: matrix uniform: model (transform)
    MATRIX_NORMAL     = "matNormal",  // RLShader location: matrix uniform: normal
    VECTOR_VIEW       = "vector_view",  // RLShader location: vector uniform: view
    COLOR_DIFFUSE     = "colDiffuse",  // RLShader location: vector uniform: diffuse color
    COLOR_SPECULAR    = "colSpecular",  // RLShader location: vector uniform: specular color
    COLOR_AMBIENT     = "colAmbient",  // RLShader location: vector uniform: ambient color
    MAP_ALBEDO        = "map_albedo",  // RLShader location: sampler2d texture: albedo (same as: SHADER_LOC_MAP_DIFFUSE)
    MAP_METALNESS     = "map_metalness",  // RLShader location: sampler2d texture: metalness (same as: SHADER_LOC_MAP_SPECULAR)
    MAP_NORMAL        = "map_normal",  // RLShader location: sampler2d texture: normal
    MAP_ROUGHNESS     = "map_roughness",  // RLShader location: sampler2d texture: roughness
    MAP_OCCLUSION     = "map_occlusion",  // RLShader location: sampler2d texture: occlusion
    MAP_EMISSION      = "map_emission",  // RLShader location: sampler2d texture: emission
    MAP_HEIGHT        = "map_height",  // RLShader location: sampler2d texture: height
    MAP_CUBEMAP       = "map_cubemap",  // RLShader location: samplerCube texture: cubemap
    MAP_IRRADIANCE    = "map_irradiance",  // RLShader location: samplerCube texture: irradiance
    MAP_PREFILTER     = "map_prefilter",  // RLShader location: samplerCube texture: prefilter
    MAP_BRDF          = "map_brdf",   // RLShader location: sampler2d texture: brdf
    DEPTH0            = "depth0",  // RLShader location: sampler2d texture: depth map 0
    DEPTH1            = "depth1",  // RLShader location: sampler2d texture: depth map 1
    DEPTH2            = "depth2",  // RLShader location: sampler2d texture: depth map 2
    DEPTH3            = "depth3"  // RLShader location: sampler2d texture: depth map 3
}

$assert(RLShdLocInd.VERTEX_POSITION.ordinal == 0);

/*
NOTE(HM) 
Default shader attribute names to be used in glsl shader code, 
is recomended to use them to take advantage of the default raylib shader 
locations, so you don't have to set them manually.

They are defined inside raylib/src/config.h

#define RL_DEFAULT_SHADER_ATTRIB_NAME_POSITION     "vertexPosition"    // Binded by default to shader location: 0
#define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD     "vertexTexCoord1"    // Binded by default to shader location: 1
#define RL_DEFAULT_SHADER_ATTRIB_NAME_NORMAL       "vertexNormal"      // Binded by default to shader location: 2
#define RL_DEFAULT_SHADER_ATTRIB_NAME_COLOR        "vertexColor"       // Binded by default to shader location: 3
#define RL_DEFAULT_SHADER_ATTRIB_NAME_TANGENT      "vertexTangent"     // Binded by default to shader location: 4
#define RL_DEFAULT_SHADER_ATTRIB_NAME_TEXCOORD2    "vertexTexCoord2"   // Binded by default to shader location: 5

#define RL_DEFAULT_SHADER_UNIFORM_NAME_MVP         "mvp"               // model-view-projection matrix
#define RL_DEFAULT_SHADER_UNIFORM_NAME_VIEW        "matView"           // view matrix
#define RL_DEFAULT_SHADER_UNIFORM_NAME_PROJECTION  "matProjection"     // projection matrix
#define RL_DEFAULT_SHADER_UNIFORM_NAME_MODEL       "matModel"          // model matrix
#define RL_DEFAULT_SHADER_UNIFORM_NAME_NORMAL      "matNormal"         // normal matrix (transpose(inverse(matModelView))
#define RL_DEFAULT_SHADER_UNIFORM_NAME_COLOR       "colDiffuse"        // color diffuse (base tint color, multiplied by texture color)
#define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE0  "texture0"          // texture0 (texture slot active 0)
#define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE1  "texture1"          // texture1 (texture slot active 1)
#define RL_DEFAULT_SHADER_SAMPLER2D_NAME_TEXTURE2  "texture2"          // texture2 (texture slot active 2)
*/

//#define SHADER_LOC_MAP_DIFFUSE      SHADER_LOC_MAP_ALBEDO
//#define SHADER_LOC_MAP_SPECULAR     SHADER_LOC_MAP_METALNESS

// RLShader uniform data type
enum RLShdUniTyp : inline CInt
{
    FLOAT,           // RLShader uniform type: float
    VEC2,            // RLShader uniform type: vec2 (2 float)
    VEC3,            // RLShader uniform type: vec3 (3 float)
    VEC4,            // RLShader uniform type: vec4 (4 float)
    INT,             // RLShader uniform type: CInt
    IVEC2,           // RLShader uniform type: ivec2 (2 CInt)
    IVEC3,           // RLShader uniform type: ivec3 (3 CInt)
    IVEC4,           // RLShader uniform type: ivec4 (4 CInt)
    SAMPLER2D        // RLShader uniform type: sampler2d
}

// RLShader attribute data types
enum RLShdrAttrbDatTyp : CInt
{
    FLOAT,            // RLShader attribute type: float
    VEC2,             // RLShader attribute type: vec2 (2 float)
    VEC3,             // RLShader attribute type: vec3 (3 float)
    VEC4              // RLShader attribute type: vec4 (4 float)
}

// Pixel formats
// NOTE: Support depends on OpenGL version and platform
enum RLPixelFormat : const inline CInt
{
	NONE = 0,
    UNCOMPRESSED_GRAYSCALE,     // 8 bit per pixel (no alpha)
    UNCOMPRESSED_GRAY_ALPHA,    // 8*2 bpp (2 channels)
    UNCOMPRESSED_R5G6B5,        // 16 bpp
    UNCOMPRESSED_R8G8B8,        // 24 bpp
    UNCOMPRESSED_R5G5B5A1,      // 16 bpp (1 bit alpha)
    UNCOMPRESSED_R4G4B4A4,      // 16 bpp (4 bit alpha)
    UNCOMPRESSED_R8G8B8A8,      // 32 bpp
    UNCOMPRESSED_R32,           // 32 bpp (1 channel - float)
    UNCOMPRESSED_R32G32B32,     // 32*3 bpp (3 channels - float)
    UNCOMPRESSED_R32G32B32A32,  // 32*4 bpp (4 channels - float)
    COMPRESSED_DXT1_RGB,        // 4 bpp (no alpha)
    COMPRESSED_DXT1_RGBA,       // 4 bpp (1 bit alpha)
    COMPRESSED_DXT3_RGBA,       // 8 bpp
    COMPRESSED_DXT5_RGBA,       // 8 bpp
    COMPRESSED_ETC1_RGB,        // 4 bpp
    COMPRESSED_ETC2_RGB,        // 4 bpp
    COMPRESSED_ETC2_EAC_RGBA,   // 8 bpp
    COMPRESSED_PVRT_RGB,        // 4 bpp
    COMPRESSED_PVRT_RGBA,       // 4 bpp
    COMPRESSED_ASTC_4X4_RGBA,   // 8 bpp
    COMPRESSED_ASTC_8X8_RGBA    // 2 bpp
}

// RLTexture parameters: filter mode
// NOTE 1: Filtering considers mipmaps if available in the texture
// NOTE 2: Filter is accordingly set for minification and magnification
enum RLTextureFilter : const CInt
{
    POINT = 0,                   // No filter, just pixel approximation
    BILINEAR,                // Linear filtering
    TRILINEAR,               // Trilinear filtering (linear with mipmaps)
    ANISOTROPIC_4X,          // Anisotropic filtering 4x
    ANISOTROPIC_8X,          // Anisotropic filtering 8x
    ANISOTROPIC_16X,         // Anisotropic filtering 16x
}

// RLTexture parameters: wrap mode
enum RLTextureWrap : const int
{
    REPEAT = 0,                    // Repeats texture in tiled mode
    CLAMP,                     // Clamps texture to edge pixel in tiled mode
    MIRROR_REPEAT,             // Mirrors and repeats the texture in tiled mode
    MIRROR_CLAMP               // Mirrors and clamps to border the texture in tiled mode
}

// Cubemap layouts
enum RLCubemapLayout : const int
{
    AUTO_DETECT = 0,             // Automatically detect layout type
    LINE_VERTICAL,           // Layout is defined by a vertical line with faces
    LINE_HORIZONTAL,         // Layout is defined by an horizontal line with faces
    CROSS_THREE_BY_FOUR,     // Layout is defined by a 3x4 cross with cubemap faces
    CROSS_FOUR_BY_THREE,     // Layout is defined by a 4x3 cross with cubemap faces
    PANORAMA                 // Layout is defined by a panorama image (equirectangular map)
}

// RLFont type, defines generation method
enum RLFontType : const int
{
    DEFAULT = 0,                   // Default font generation, anti-aliased
    BITMAP,                    // Bitmap font generation, no anti-aliasing
    SDF                        // SDF font generation, requires external shader
}

// RLColor blending modes (pre-defined)
enum RLBlendMode : const inline CInt
{
    ALPHA = 0,                    // Blend textures considering alpha (default)
    ADDITIVE,                 // Blend textures adding colors
    MULTIPLIED,               // Blend textures multiplying colors
    ADD_COLORS,               // Blend textures adding colors (alternative)
    SUBTRACT_COLORS,          // Blend textures subtracting colors (alternative)
    ALPHA_PREMUL,             // Blend premultiplied textures considering alpha
    CUSTOM,                   // Blend textures using custom src/dst factors (use setBlendMode(CUSTOM))
    CUSTOM_SEPARATE           // Blend textures using custom src/dst factors (use setBlendFactorsSeparate())
}

// GL blending factors
const RL_ZERO                      = 0;           // GL_ZERO
const RL_ONE                       = 1;           // GL_ONE
const RL_SRC_COLOR                 = 0x0300;      // GL_SRC_COLOR
const RL_ONE_MINUS_SRC_COLOR       = 0x0301;      // GL_ONE_MINUS_SRC_COLOR
const RL_SRC_ALPHA                 = 0x0302;      // GL_SRC_ALPHA
const RL_ONE_MINUS_SRC_ALPHA       = 0x0303;      // GL_ONE_MINUS_SRC_ALPHA
const RL_DST_ALPHA                 = 0x0304;      // GL_DST_ALPHA
const RL_ONE_MINUS_DST_ALPHA       = 0x0305;      // GL_ONE_MINUS_DST_ALPHA
const RL_DST_COLOR                 = 0x0306;      // GL_DST_COLOR
const RL_ONE_MINUS_DST_COLOR       = 0x0307;      // GL_ONE_MINUS_DST_COLOR
const RL_SRC_ALPHA_SATURATE        = 0x0308;      // GL_SRC_ALPHA_SATURATE
const RL_CONSTANT_COLOR            = 0x8001;      // GL_CONSTANT_COLOR
const RL_ONE_MINUS_CONSTANT_COLOR  = 0x8002;      // GL_ONE_MINUS_CONSTANT_COLOR
const RL_CONSTANT_ALPHA            = 0x8003;      // GL_CONSTANT_ALPHA
const RL_ONE_MINUS_CONSTANT_ALPHA  = 0x8004;      // GL_ONE_MINUS_CONSTANT_ALPHA

// GL blending functions/equations
const RL_FUNC_ADD                  = 0x8006;      // GL_FUNC_ADD
const RL_MIN                       = 0x8007;      // GL_MIN
const RL_MAX                       = 0x8008;      // GL_MAX
const RL_FUNC_SUBTRACT             = 0x800A;      // GL_FUNC_SUBTRACT
const RL_FUNC_REVERSE_SUBTRACT     = 0x800B;      // GL_FUNC_REVERSE_SUBTRACT
const RL_BLEND_EQUATION            = 0x8009;      // GL_BLEND_EQUATION
const RL_BLEND_EQUATION_RGB        = 0x8009;      // GL_BLEND_EQUATION_RGB   // (Same as BLEND_EQUATION)
const RL_BLEND_EQUATION_ALPHA      = 0x883D;      // GL_BLEND_EQUATION_ALPHA
const RL_BLEND_DST_RGB             = 0x80C8;      // GL_BLEND_DST_RGB
const RL_BLEND_SRC_RGB             = 0x80C9;      // GL_BLEND_SRC_RGB
const RL_BLEND_DST_ALPHA           = 0x80CA;      // GL_BLEND_DST_ALPHA
const RL_BLEND_SRC_ALPHA           = 0x80CB;      // GL_BLEND_SRC_ALPHA
const RL_BLEND_COLOR               = 0x8005;      // GL_BLEND_COLOR


// RLCamera system modes
enum RLCameraMode : const int
{
    CUSTOM = 0,                  // RLCamera custom, controlled by user (UpdateCamera() does nothing)
    FREE,                    // RLCamera free mode
    ORBITAL,                 // RLCamera orbital, around target, zoom supported
    FIRST_PERSON,            // RLCamera first person
    THIRD_PERSON             // RLCamera third person
}

// RLCamera projection
enum RLCameraProjection : const int
{
    PERSPECTIVE = 0,             // Perspective projection
    ORTHOGRAPHIC             // Orthographic projection
}

// N-patch layout
enum RLNPatchLayout : const int
{
    NINE_PATCH = 0,              // Npatch layout: 3x3 tiles
    THREE_PATCH_VERTICAL,    // Npatch layout: 1x3 tiles
    THREE_PATCH_HORIZONTAL   // Npatch layout: 3x1 tiles
}

// Callbacks to hook some internal functions
// WARNING: This callbacks are intended for advance users
alias LoadFileDataCallback = fn char* (ZString fileName, CUInt* bytesRead); // FileIO: Load binary data
alias SaveFileDataCallback = fn bool(ZString fileName, void* data, CUInt bytesToWrite); // FileIO: Save binary data
alias LoadFileTextCallback = fn char*(ZString fileName); // FileIO: Load text data
alias SaveFileTextCallback = fn bool(ZString fileName, ZString text); // FileIO: Save text data

// Window-related functions
alias MonitorIndex @local = CInt;
fn void initWindow(CInt width, CInt height, ZString title) @cname("InitWindow");              // Initialize window and OpenGL context
fn void closeWindow() @cname("CloseWindow");                                              // Close window and unload OpenGL context
fn bool windowShouldClose() @cname("WindowShouldClose");                                  // Check if KEY_ESCAPE pressed or Close icon pressed
fn bool isWindowReady() @cname("IsWindowReady");                                          // Check if window has been initialized successfully
fn bool isWindowFullscreen() @cname("IsWindowFullscreen");                                // Check if window is currently fullscreen
fn bool isWindowHidden() @cname("IsWindowHidden");                                        // Check if window is currently hidden (only PLATFORM_DESKTOP)
fn bool isWindowMinimized() @cname("IsWindowMinimized");                                  // Check if window is currently minimized (only PLATFORM_DESKTOP)
fn bool isWindowMaximized() @cname("IsWindowMaximized");                                  // Check if window is currently maximized (only PLATFORM_DESKTOP)
fn bool isWindowFocused() @cname("IsWindowFocused");                                      // Check if window is currently focused (only PLATFORM_DESKTOP)
fn bool isWindowResized() @cname("IsWindowResized");                                      // Check if window has been resized last frame
// NOTE(HM): this requires the window to be previously initialized
fn bool isWindowState(RLConfigFlag flag) @cname("IsWindowState");                           // Check if one specific window flag is enabled
fn void setWindowState(RLConfigFlag flag) @cname("SetWindowState");                         // Set window configuration state using flags (only PLATFORM_DESKTOP)
fn void clearWindowState(RLConfigFlag flags) @cname("ClearWindowState");                    // Clear window configuration state flags
// END NOTE(HM)
fn void toggleFullscreen() @cname("ToggleFullscreen");                                    // Toggle window state: fullscreen/windowed (only PLATFORM_DESKTOP)
fn void toggleBorderlessWindowed() @cname("ToggleBorderlessWindowed");			   // Toggle window state: borderless windowed (only PLATFORM_DESKTOP)
fn void maximizeWindow() @cname("MaximizeWindow");                                        // Set window state: maximized, if resizable (only PLATFORM_DESKTOP)
fn void minimizeWindow() @cname("MinimizeWindow");                                        // Set window state: minimized, if resizable (only PLATFORM_DESKTOP)
fn void restoreWindow() @cname("RestoreWindow");                                          // Set window state: not minimized/maximized (only PLATFORM_DESKTOP)
fn void setWindowIcon(RLImage image) @cname("SetWindowIcon");                               // Set icon for window (only PLATFORM_DESKTOP)
fn void setWindowIcons(RLImage* images, CInt count) @cname("SetWindowIcons");                // Set icon for window (multiple images, RGBA 32bit, only PLATFORM_DESKTOP)
fn void setWindowTitle(ZString title) @cname("SetWindowTitle");                             // Set title for window (only PLATFORM_DESKTOP)
fn void setWindowPosition(CInt x, CInt y) @cname("SetWindowPosition");                      // Set window position on screen (only PLATFORM_DESKTOP)
fn void setWindowMonitor(CInt monitor) @cname("SetWindowMonitor");             // Set monitor for the current window (fullscreen mode)
fn void setWindowMinSize(CInt width, CInt height) @cname("SetWindowMinSize");               // Set window minimum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void setWindowMaxSize(CInt width, CInt height) @cname("SetWindowMaxSize");               // Set window maximum dimensions (for FLAG_WINDOW_RESIZABLE)
fn void setWindowSize(CInt width, CInt height) @cname("SetWindowSize");                     // Set window dimensions
fn void setWindowOpacity(float opacity) @cname("SetWindowOpacity");                       // Set window opacity [0.0f..1.0f] (only PLATFORM_DESKTOP)
fn void* getWindowHandle() @cname("GetWindowHandle");                                     // Get native window handle
fn CInt getScreenWidth() @cname("GetScreenWidth");                                         // Get current screen width
fn CInt getScreenHeight() @cname("GetScreenHeight");                                       // Get current screen height
fn CInt getRenderWidth() @cname("GetRenderWidth");                                         // Get current render width (it considers HiDPI)
fn CInt getRenderHeight() @cname("GetRenderHeight");                                       // Get current render height (it considers HiDPI)
fn CInt getMonitorCount() @cname("GetMonitorCount");                                       // Get number of connected monitors
fn MonitorIndex getCurrentMonitor() @cname("GetCurrentMonitor");                                   // Get current connected monitor
fn RLVector2 getMonitorPosition(MonitorIndex monitor) @cname("GetMonitorPosition");                  // Get specified monitor position
fn CInt getMonitorWidth(MonitorIndex monitor) @cname("GetMonitorWidth");                            // Get specified monitor width (max available by monitor)
fn CInt getMonitorHeight(MonitorIndex monitor) @cname("GetMonitorHeight");                          // Get specified monitor height (max available by monitor)
fn CInt getMonitorPhysicalWidth(MonitorIndex monitor) @cname("GetMonitorPhysicalWidth");            // Get specified monitor physical width in millimetres
fn CInt getMonitorPhysicalHeight(MonitorIndex monitor) @cname("GetMonitorPhysicalHeight");          // Get specified monitor physical height in millimetres
fn CInt getMonitorRefreshRate(MonitorIndex monitor) @cname("GetMonitorRefreshRate");                // Get specified monitor refresh rate
fn RLVector2 getWindowPosition() @cname("GetWindowPosition");                               // Get window position XY on monitor
//
fn RLVector2 getWindowScaleDPI() @cname("GetWindowScaleDPI");                               // Get window scale DPI factor ex: (1.0f, 1.0f) for 100% scale, (2.0f, 2.0f) for 200% scale, etc.
/*
Note(HM) GetWindowScaleDPI() function is only useful, if we want to manage DPI scale manually instead of in an automated way. 
(so the size of text and UI of our raylib application matches the rest of the desktop environment's text and UI sizes)
If FLAG_WINDOW_HIGHDPI is enabled, that's up to the backend to automatically rescale the size of the window's content 
to match the DPI scale of the display.
*/
fn ZString getMonitorName(MonitorIndex monitor) @cname("GetMonitorName");                          // Get the human-readable, UTF-8 encoded name of the primary monitor
fn void setClipboardText(ZString text) @cname("SetClipboardText");                        // Set clipboard text content
fn ZString getClipboardText() @cname("GetClipboardText");                                 // Get clipboard text content
fn RLImage getClipboardImage() @cname("GetClipboardImage");                                 // Get clipboard image content
fn void enableEventWaiting() @cname("EnableEventWaiting");                                // Enable waiting for events on EndDrawing(), no automatic event polling
fn void disableEventWaiting() @cname("DisableEventWaiting");                              // Disable waiting for events on EndDrawing(), automatic events polling

// Cursor-related functions
fn void showCursor() @cname("ShowCursor");                                                 // Shows cursor
fn void hideCursor() @cname("HideCursor");                                                 // Hides cursor
fn bool isCursorHidden() @cname("IsCursorHidden");                                        // Check if cursor is not visible
fn void enableCursor() @cname("EnableCursor");                                             // Enables cursor (unlock cursor)
fn void disableCursor() @cname("DisableCursor");                                           // Disables cursor (lock cursor)
fn bool isCursorOnScreen() @cname("IsCursorOnScreen");                                   // Check if cursor is on the screen

// Drawing-related functions
fn void clearBackground(RLColor color) @cname("ClearBackground");                            // Set background color (framebuffer clear color)
fn void beginDrawing() @cname("BeginDrawing");                                             // Setup canvas (framebuffer) to start drawing
fn void endDrawing() @cname("EndDrawing");                                                 // End canvas drawing and swap buffers (double buffering)
fn void beginMode2D(RLCamera2D camera) @cname("BeginMode2D");                                // Begin 2D mode with custom camera (2D)
fn void endMode2D() @cname("EndMode2D");                                                   // Ends 2D mode with custom camera
fn void beginMode3D(RLCamera3D camera) @cname("BeginMode3D");                                // Begin 3D mode with custom camera (3D)
fn void endMode3D() @cname("EndMode3D");                                                   // Ends 3D mode and returns to default 2D orthographic mode
fn void beginTextureMode(RLRenderTexture2D target) @cname("BeginTextureMode");              // Begin drawing to render texture
fn void endTextureMode() @cname("EndTextureMode");                                        // Ends drawing to render texture
fn void beginShaderMode(RLShader shader) @cname("BeginShaderMode");                         // Begin custom shader drawing
fn void endShaderMode() @cname("EndShaderMode");                                          // End custom shader drawing (use default shader)
fn void beginBlendMode(CInt mode) @cname("BeginBlendMode");                                // Begin blending mode (alpha, additive, multiplied, subtract, custom)
fn void endBlendMode() @cname("EndBlendMode");                                            // End blending mode (reset to default: alpha blending)
fn void setBlendFactors(CInt glSrcFactor, CInt glDstFactor, CInt glEquation) @cname("rlSetBlendFactors"); // Set blending mode factor and equation (using OpenGL factors)
fn void setBlendFactorsSeparate(CInt glSrcRGB, CInt glDstRGB, CInt glSrcAlpha, CInt glDstAlpha, CInt glEqRGB, CInt glEqAlpha) @cname("rlSetBlendFactorsSeparate"); // Set blending mode factors and equations separately (using OpenGL factors)
fn void setBlendMode(CInt mode) @cname("rlSetBlendMode");                                  // Needs to be called AFTER rlSetBlendFactors() or rlSetBlendFactorsSeparate()
fn void beginScissorMode(CInt x, CInt y, CInt w, CInt h) @cname("BeginScissorMode");          // Begin scissor mode (define screen area for following drawing)
fn void endScissorMode() @cname("EndScissorMode");                                        // End scissor mode
fn void beginVrStereoMode(RLVrStereoConfig config) @cname("BeginVrStereoMode");            // Begin stereo rendering (requires VR simulator)
fn void endVrStereoMode() @cname("EndVrStereoMode");                                     // End stereo rendering (requires VR simulator)

// VR stereo config functions for VR simulator
fn RLVrStereoConfig loadVrStereoConfig(RLVrDeviceInfo device) @cname("LoadVrStereoConfig");  // Load VR stereo config for VR simulator device parameters
fn void unloadVrStereoConfig(RLVrStereoConfig config) @cname("UnloadVrStereoConfig");      // Unload VR stereo config

// RLShader management functions
// NOTE: RLShader functionality is not available on OpenGL 1.1
fn RLShader loadShader(ZString vsFileName, ZString fsFileName) @cname("LoadShader");          // Load shader from files and bind default locations
fn RLShader loadShaderFromMemory(ZString vs, ZString fs) @cname("LoadShaderFromMemory");      // Load shader from code strings and bind default locations
fn bool isShaderValid(RLShader shader) @cname("IsShaderValid");                               // Check if a shader is ready
//fn bool RLShader.isValid(self) @cname("IsShaderValid");                              // Check if a shader is ready
fn CInt getShaderLocation(RLShader shader, ZString uniformName) @cname("GetShaderLocation");   // Get shader uniform location
fn CInt RLShader.getUniformLocation(self, ZString uniformName) @cname("GetShaderLocation");   // Get shader uniform location
fn CInt getShaderLocationAttrib(RLShader shader, ZString attr) @cname("GetShaderLocationAttrib");  // Get shader attribute location
fn CInt RLShader.getAttributeLocation(self, ZString attr) @cname("GetShaderLocationAttrib");  // Get shader attribute location
fn void setShaderValue(RLShader shader, CInt locIndex, void* value, CInt uniformType) @cname("SetShaderValue"); // Set shader uniform value
fn void setShaderValueV(RLShader shader, CInt locIndex, void* value, CInt uniformType, CInt count) @cname("SetShaderValueV");   // Set shader uniform value vector
fn void setShaderValueMatrix(RLShader shader, CInt locIndex, RLMatrix mat) @cname("SetShaderValueMatrix"); // Set shader uniform value (matrix 4x4)
fn void setShaderValueTexture(RLShader shader, CInt locIndex, RLTexture2D texture) @cname("SetShaderValueTexture"); // Set shader uniform value for texture (sampler2d)
fn void unloadShader(RLShader shader) @cname("UnloadShader");                                // Unload shader from GPU memory (VRAM)

//
fn void RLShader.setValue(self, CInt locIndex, void* value, CInt uniformType) @cname("SetShaderValue"); // Set shader uniform value
fn void RLShader.setValueV(self, CInt locIndex, void* value, CInt uniformType, CInt count) @cname("SetShaderValueV");   // Set shader uniform value vector
fn void RLShader.setValueMatrix(self, CInt locIndex, RLMatrix mat) @cname("SetShaderValueMatrix"); // Set shader uniform value (matrix 4x4)
fn void RLShader.setValueTexture(self, CInt locIndex, RLTexture2D texture) @cname("SetShaderValueTexture"); // Set shader uniform value for texture (sampler2d)
fn void RLShader.unload(self) @cname("UnloadShader");                                // Unload shader from GPU memory (VRAM)

// Screen-space-related functions
//#define GetMouseRay GetScreenToWorldRay     // Compatibility hack for previous raylib versions
fn RLRay getScreenToWorldRay(RLVector2 mousePosition, RLCamera camera) @cname("GetScreenToWorldRay"); // Get a ray trace from mouse position
fn RLRay getScreenToWorldRayEx(RLVector2 position, RLCamera camera, CInt width, CInt height) @cname("GetScreenToWorldRayEx"); // Get a ray trace from screen position (i.e mouse) in a viewport
fn RLVector2 getWorldToScreen(RLVector3 position, RLCamera camera) @cname("GetWorldToScreen"); // Get the screen space position for a 3d world space position
fn RLVector2 getWorldToScreenEx(RLVector3 position, RLCamera camera, CInt width, CInt height) @cname("GetWorldToScreenEx"); // Get size position for a 3d world space position
fn RLVector2 getWorldToScreen2D(RLVector2 position, RLCamera2D camera) @cname("GetWorldToScreen2D"); // Get the screen space position for a 2d camera world space position
fn RLVector2 getScreenToWorld2D(RLVector2 position, RLCamera2D camera) @cname("GetScreenToWorld2D"); // Get the world space position for a 2d camera screen space position
fn RLMatrix getCameraMatrix(RLCamera camera) @cname("GetCameraMatrix");                            // Get camera transform matrix (view matrix)
fn RLMatrix getCameraMatrix2D(RLCamera2D camera) @cname("GetCameraMatrix2D");                 // Get camera 2d transform matrix

// Timing-related functions
fn void setTargetFPS(CInt fps) @cname("SetTargetFPS");                                     // Set target FPS (maximum)
fn CInt getFPS() @cname("GetFPS");                                                          // Get current FPS
fn float getFrameTime() @cname("GetFrameTime");                                           // Get time in seconds for last frame drawn (delta time)
fn double getTime() @cname("GetTime");                                                     // Get elapsed time in seconds since InitWindow()

// Custom frame control functions
// NOTE: Those functions are intended for advance users that want full control over the frame processing
// By default EndDrawing() does this job: draws everything + SwapScreenBuffer() + manage frame timming + PollInputEvents()
// To avoid that behaviour and control frame processes manually, enable in config.h: SUPPORT_CUSTOM_FRAME_CONTROL
fn void swapScreenBuffer() @cname("SwapScreenBuffer");                                    // Swap back buffer with front buffer (screen drawing)
fn void pollInputEvents() @cname("PollInputEvents");                                      // Register all input events
fn void waitTime(float ms) @cname("WaitTime");                                             // Wait for some milliseconds (halt program execution)

// Random values generation functions
fn CInt getRandomValue(CInt min, CInt max) @cname("GetRandomValue");                          // Get a random value between min and max (both included)
fn void setRandomSeed(CUInt seed) @cname("SetRandomSeed");                                  // Set the seed for the random number generator
fn CInt* loadRandomSequence(CUInt count, CInt min, CInt max) @cname("LoadRandomSequence");     // Load random values sequence, no values repeated
fn void unloadRandomSequence(CInt *sequence) @cname("UnloadRandomSequence");                // Unload random values sequence

// Misc. functions
// NOTE(HM) note the parameter for takeScreenshot(..) is fileName with extension, not filePath!!!
fn void takeScreenshot(ZString fileName) @cname("TakeScreenshot");                         // Takes a screenshot of current screen (filename extension defines format)
fn void setConfigFlags(RLConfigFlag flags) @cname("SetConfigFlags");                         // Setup init configuration flags (view FLAGS)
fn void openURL(ZString url) @cname("OpenURL");                                            // Open URL with default system browser (if available)

fn void traceLog(RLTraceLogLevel logLevel, char* text, ...) @cname("TraceLog");              // Show trace log messages (LOG_DEBUG, LOG_INFO, LOG_WARNING, LOG_ERROR...)
fn void setTraceLogLevel(RLTraceLogLevel logLevel) @cname("SetTraceLogLevel");               // Set the current threshold (minimum) log level
fn void* memAlloc(CInt size) @cname("MemAlloc");                                            // Internal memory allocator
fn void* memRealloc(void* ptr, CInt size) @cname("MemRealloc");                             // Internal memory reallocator
fn void memFree(void* ptr) @cname("MemFree");                								// Internal memory free

// Set custom callbacks
// WARNING: Callbacks setup is intended for advance users
fn void setLoadFileDataCallback(LoadFileDataCallback callback) @cname("SetLoadFileDataCallback"); // Set custom file binary data loader
fn void setSaveFileDataCallback(SaveFileDataCallback callback) @cname("SetSaveFileDataCallback"); // Set custom file binary data saver
fn void setLoadFileTextCallback(LoadFileTextCallback callback) @cname("SetLoadFileTextCallback"); // Set custom file text data loader
fn void setSaveFileTextCallback(SaveFileTextCallback callback) @cname("SetSaveFileTextCallback"); // Set custom file text data saver

// Files management functions
// Load file data as byte array (read)
fn char* loadFileData(ZString fileName, CInt* bytesRead) @cname("LoadFileData");
// Unload file data allocated by loadFileData()
fn void unloadFileData(char* data) @cname("UnloadFileData");
// Save data to file from byte array (write), returns true on success
fn bool saveFileData(ZString fileName, void* data,  CInt dataSize) @cname("SaveFileData");
// Export data to code (.h), returns true on success
fn bool exportDataAsCode(char *data, CInt dataSize, ZString fileName) @cname("ExportDataAsCode");
// Load text data from file (read), returns a '\0' terminated string
fn ZString loadFileText(ZString fileName) @cname("LoadFileText");
// Unload file text data allocated by LoadFileText()
fn void unloadFileText(ZString text) @cname("UnloadFileText");
// Save text data to file (write), string must be '\0' terminated, returns true on success
fn bool saveFileText(ZString fileName, ZString text) @cname("SaveFileText");

// File system functions
// Check if file exists
fn bool fileExists(ZString fileName) @cname("FileExists");
// Check if a directory path exists
fn bool directoryExists(ZString dirPath) @cname("DirectoryExists");
// Check file extension (including point: .png, .wav)
fn bool isFileExtension(ZString fileName, ZString ext) @cname("IsFileExtension");
// Get file length in bytes (NOTE: GetFileSize() conflicts with windows.h)
fn CInt getFileLength(ZString fileName) @cname("GetFileLength");
// Get pointer to extension for a filename string (includes dot: '.png')
fn ZString getFileExtension(ZString fileName) @cname("GetFileExtension");
// Get pointer to filename for a path string
fn ZString getFileName(ZString filePath) @cname("GetFileName");
// Get filename string without extension (uses static string)
fn ZString getFileNameWithoutExt(ZString filePath) @cname("GetFileNameWithoutExt");
// Get full path for a given fileName with path (uses static string)
fn ZString getDirectoryPath(ZString filePath) @cname("GetDirectoryPath");
// Get previous directory path for a given path (uses static string)
fn ZString getPrevDirectoryPath(ZString dirPath) @cname("GetPrevDirectoryPath");
// Get current working directory (uses static string)
fn ZString getWorkingDirectory() @cname("GetWorkingDirectory");
// Get the directory if the running application (uses static string)
fn ZString getApplicationDirectory() @cname("GetApplicationDirectory");
// Create directories (including full path requested), returns 0 on success
fn CInt makeDirectory(ZString dirPath) @cname("MakeDirectory");
// Change working directory, return true on success
fn bool changeDirectory(ZString dir) @cname("ChangeDirectory");
// Check if a given path is a file or a directory
fn bool isPathFile(ZString path) @cname("IsPathFile");
// Check if fileName is valid for the platform/OS
fn bool isFileNameValid(ZString fileName)@cname("IsFileNameValid");
// Load directory filepaths
fn RLFilePathList loadDirectoryFiles(ZString dirPath) @cname("LoadDirectoryFiles");
// Load directory filepaths with extension filtering and recursive directory scan
fn RLFilePathList loadDirectoryFilesEx(ZString basePath, ZString filter, bool scanSubdirs) @cname("LoadDirectoryFilesEx");
// Clear directory files paths buffers (free memory)
fn void unloadDirectoryFiles(RLFilePathList files) @cname("UnloadDirectoryFiles");
// Check if a file has been dropped into window
fn bool isFileDropped() @cname("IsFileDropped");
// Load dropped filepaths
fn RLFilePathList loadDroppedFiles() @cname("LoadDroppedFiles");
// Unload dropped filepaths
fn void unloadDroppedFiles(RLFilePathList files) @cname("UnloadDroppedFiles");
// Get file modification time (last write time)
fn CLong getFileModTime(ZString fileName) @cname("GetFileModTime");

// Compression/Encoding functionality
// Compress data (DEFLATE algorithm)
fn char* compressData(char* data, CInt dataLength, CInt* compDataLength) @cname("CompressData");
// Decompress data (DEFLATE algorithm)
fn char* decompressData(char* compData, CInt compDataLength, CInt* dataLength) @cname("DecompressData");
// Encode data to Base64 string
fn char* encodeDataBase64(char* data, CInt dataLength, CInt* outputLength) @cname("EncodeDataBase64");
// Decode Base64 string data
fn char* decodeDataBase64(char* data, CInt* outputLength) @cname("DecodeDataBase64");
// Compute CRC32 hash code
fn CUInt computeCRC32(char *data, CInt dataSize) @cname("ComputeCRC32");
// Compute MD5 hash code, returns static CInt[4] (16 bytes)
fn CUInt* computeMD5(char *data, CInt dataSize) @cname("ComputeMD5");
// Compute SHA1 hash code, returns static CInt[5] (20 bytes)
fn CUInt* computeSHA1(char *data, CInt dataSize) @cname("ComputeSHA1");
// Automation events functionality
// Load automation events list from file, NULL for empty list, capacity = MAX_AUTOMATION_EVENTS
fn RLAutomationEventList loadAutomationEventList(ZString fileName) @cname("LoadAutomationEventList");
// Unload automation events list from file
fn void unloadAutomationEventList(RLAutomationEventList list) @cname("UnloadAutomationEventList");
// Export automation events list as text file
fn bool exportAutomationEventList(RLAutomationEventList list, ZString fileName) @cname("ExportAutomationEventList");
// Set automation event list to record to
fn void setAutomationEventList(RLAutomationEventList *list) @cname("SetAutomationEventList");
// Set automation event internal base frame to start recording
fn void setAutomationEventBaseFrame(CInt frame) @cname("SetAutomationEventBaseFrame");
// Start recording automation events (RLAutomationEventList must be set)
fn void startAutomationEventRecording() @cname("StartAutomationEventRecording");
// Stop recording automation events
fn void stopAutomationEventRecording() @cname("StopAutomationEventRecording");
// Play a recorded automation event
fn void playAutomationEvent(RLAutomationEvent event) @cname("PlayAutomationEvent");

//------------------------------------------------------------------------------------
// Input Handling Functions (Module: core)
//------------------------------------------------------------------------------------

// Input-related functions: keyboard
// Check if a key has been pressed once
// NOTE(HM) has issues when pressing and releasing a key very fast
fn bool isKeyPressed(RLKeyboardKey key) @cname("IsKeyPressed");
//
// Check if a key has been pressed again (Only PLATFORM_DESKTOP)
fn bool isKeyPressedRepeat(RLKeyboardKey key) @cname("IsKeyPressedRepeat");
// Check if a key is being pressed
fn bool isKeyDown(RLKeyboardKey key) @cname("IsKeyDown");
// Check if a key has been released once
fn bool isKeyReleased(RLKeyboardKey key) @cname("IsKeyReleased");
// Check if a key is NOT being pressed
fn bool isKeyUp(RLKeyboardKey key) @cname("IsKeyUp");
// Get key pressed (keycode), call it multiple times for keys queued, returns 0 when the queue is empty
fn CInt getKeyPressed() @cname("GetKeyPressed");
// Get char pressed (unicode), call it multiple times for chars queued, returns 0 when the queue is empty
fn CInt getCharPressed() @cname("GetCharPressed");
// Set a custom key to exit program (default is ESC)
fn void setExitKey(RLKeyboardKey key) @cname("SetExitKey");

// Input-related functions: gamepads
// Check if a gamepad is available
fn bool isGamepadAvailable(CInt gamepad) @cname("IsGamepadAvailable");
// Get gamepad internal name id
fn ZString getGamepadName(CInt gamepad) @cname("GetGamepadName");
// Check if a gamepad button has been pressed once
fn bool isGamepadButtonPressed(CInt gamepad, CInt button) @cname("IsGamepadButtonPressed");
// Check if a gamepad button is being pressed
fn bool isGamepadButtonDown(CInt gamepad, CInt button) @cname("IsGamepadButtonDown");
// Check if a gamepad button has been released once
fn bool isGamepadButtonReleased(CInt gamepad, CInt button) @cname("IsGamepadButtonReleased");
// Check if a gamepad button is NOT being pressed
fn bool isGamepadButtonUp(CInt gamepad, CInt button) @cname("IsGamepadButtonUp");
// Get the last gamepad button pressed
fn CInt getGamepadButtonPressed() @cname("GetGamepadButtonPressed");
// Get gamepad axis count for a gamepad
fn CInt getGamepadAxisCount(CInt gamepad) @cname("GetGamepadAxisCount");
// Get axis movement value for a gamepad axis
fn float getGamepadAxisMovement(CInt gamepad, CInt axis) @cname("GetGamepadAxisMovement");
// Set internal gamepad mappings (SDL_GameControllerDB)
fn CInt setGamepadMappings(ZString mappings) @cname("SetGamepadMappings");
// Set gamepad vibration for both motors (duration in seconds)
fn void setGamepadVibration(CInt gamepad, float leftMotor, float rightMotor, float duration) @cname("SetGamepadVibration");
// Input-related functions: mouse
// Check if a mouse button has been pressed once
fn bool isMouseButtonPressed(RLMouseButton button) @cname("IsMouseButtonPressed");
// Check if a mouse button is being pressed
fn bool isMouseButtonDown(RLMouseButton button) @cname("IsMouseButtonDown");
// Check if a mouse button has been released once
fn bool isMouseButtonReleased(RLMouseButton button) @cname("IsMouseButtonReleased");
// Check if a mouse button is NOT being pressed
fn bool isMouseButtonUp(RLMouseButton button) @cname("IsMouseButtonUp");
// Get mouse position X
fn CInt getMouseX() @cname("GetMouseX");
// Get mouse position Y
fn CInt getMouseY() @cname("GetMouseY");
// Get mouse position XY
fn RLVector2 getMousePosition() @cname("GetMousePosition");
// Get mouse delta between frames
fn RLVector2 getMouseDelta() @cname("GetMouseDelta");
// Set mouse position XY
fn void setMousePosition(CInt x, CInt y) @cname("SetMousePosition");
// Set mouse offset
fn void setMouseOffset(CInt offsetX, CInt offsetY) @cname("SetMouseOffset");
// Set mouse scaling
fn void setMouseScale(float scaleX, float scaleY) @cname("SetMouseScale");
// Get mouse wheel movement Y
fn float getMouseWheelMove() @cname("GetMouseWheelMove");
// Get mouse wheel movement for both X and Y
fn RLVector2 getMouseWheelMoveV() @cname("GetMouseWheelMoveV");
// Set mouse cursor
fn void setMouseCursor(CInt cursor) @cname("SetMouseCursor");

// Input-related functions: touch
// Get touch position X for touch point 0 (relative to screen size)
fn CInt getTouchX() @cname("GetTouchX");
// Get touch position Y for touch point 0 (relative to screen size)
fn CInt getTouchY() @cname("GetTouchY");
// Get touch position XY for a touch point index (relative to screen size)
fn RLVector2 getTouchPosition(CInt index) @cname("GetTouchPosition");
// Get touch point identifier for given index
fn CInt getTouchPointId(CInt index) @cname("GetTouchPointId");
// Get number of touch points
fn CInt getTouchPointCount() @cname("GetTouchPointCount");

//------------------------------------------------------------------------------------
// Gestures and Touch Handling Functions (Module: rgestures)
//------------------------------------------------------------------------------------
// Enable a set of gestures using flags
fn void setGesturesEnabled(RLGesture flags) @cname("SetGesturesEnabled");
// Check if a gesture have been detected
fn bool isGestureDetected(RLGesture gesture) @cname("IsGestureDetected");
// Get latest detected gesture
fn RLGesture getGestureDetected() @cname("GetGestureDetected");
// Get gesture hold time in seconds
fn float getGestureHoldDuration() @cname("GetGestureHoldDuration");
// Get gesture drag vector
fn RLVector2 getGestureDragVector() @cname("GetGestureDragVector");
// Get gesture drag angle
fn float getGestureDragAngle() @cname("GetGestureDragAngle");
// Get gesture pinch delta
fn RLVector2 getGesturePinchVector() @cname("GetGesturePinchVector");
// Get gesture pinch angle
fn float getGesturePinchAngle() @cname("GetGesturePinchAngle");

//------------------------------------------------------------------------------------
// RLCamera System Functions (Module: rcamera)
//------------------------------------------------------------------------------------

// Update camera position for selected mode
fn void updateCamera(RLCamera *camera, RLCameraMode mode) @cname("UpdateCamera");
// Update camera position for selected mode
fn void updateCameraPro(RLCamera *camera, RLVector3 movement, RLVector3 rotation, float zoom) @cname("UpdateCameraPro");

//------------------------------------------------------------------------------------
// Basic Shapes Drawing Functions (Module: shapes)
//------------------------------------------------------------------------------------
// Set texture and rectangle to be used on shapes drawing
// NOTE: It can be useful when using basic shapes and one single font,
// defining a font char white rectangle would allow drawing everything in a single draw call
// Set texture and rectangle to be used on shapes drawing
fn void setShapesTexture(RLTexture2D texture, RLRectangle source) @cname("SetShapesTexture");
// Get texture that is used for shapes drawing
fn RLTexture2D getShapesTexture() @cname("GetShapesTexture");
// Get texture source rectangle that is used for shapes drawing
fn RLRectangle getShapesTextureRectangle() @cname("GetShapesTextureRectangle");
// Basic shapes drawing functions
// Draw a pixel
fn void drawPixel(CInt posX, CInt posY, RLColor color) @cname("DrawPixel");
// Draw a pixel (Vector version)
fn void drawPixelV(RLVector2 position, RLColor color) @cname("DrawPixelV");
// Draw a line
fn void drawLine(CInt startPosX, CInt startPosY, CInt endPosX, CInt endPosY, RLColor color) @cname("DrawLine");
// Draw a line (Vector version)
fn void drawLineV(RLVector2 startPos, RLVector2 endPos, RLColor color) @cname("DrawLineV");
// Draw a line defining thickness
fn void drawLineEx(RLVector2 startPos, RLVector2 endPos, float thick, RLColor color) @cname("DrawLineEx");
// Draw lines sequence (using gl lines)
fn void drawLineStrip(RLVector2* points, CInt pointCount, RLColor color) @cname("DrawLineStrip");
// Draw a line using cubic-bezier curves in-out
fn void drawLineBezier(RLVector2 startPos, RLVector2 endPos, float thick, RLColor color) @cname("DrawLineBezier");
// Draw lines sequence
fn void drawCircle(CInt centerX, CInt centerY, float radius, RLColor color) @cname("DrawCircle");
// Draw a piece of a circle
fn void drawCircleSector(RLVector2 center, float radius, float startAngle, float endAngle, CInt segments, RLColor color) @cname("DrawCircleSector");
// Draw circle sector outline
fn void drawCircleSectorLines(RLVector2 center, float radius, float startAngle, float endAngle, CInt segments, RLColor color) @cname("DrawCircleSectorLines");
// Draw a gradient-filled circle
fn void drawCircleGradient(CInt centerX, CInt centerY, float radius, RLColor inner, RLColor outer) @cname("DrawCircleGradient");
// Draw a color-filled circle (Vector version)
fn void drawCircleV(RLVector2 center, float radius, RLColor color) @cname("DrawCircleV");
// Draw circle outline
fn void drawCircleLines(CInt centerX, CInt centerY, float radius, RLColor color) @cname("DrawCircleLines");
// Draw circle outline (Vector version)
fn void drawCircleLinesV(RLVector2 center, float radius, RLColor color) @cname("DrawCircleLinesV");
// Draw ellipse
fn void drawEllipse(CInt centerX, CInt centerY, float radiusH, float radiusV, RLColor color) @cname("DrawEllipse");
// Draw ellipse outline
fn void drawEllipseLines(CInt centerX, CInt centerY, float radiusH, float radiusV, RLColor color) @cname("DrawEllipseLines");
// Draw ring
fn void drawRing(RLVector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, CInt segments, RLColor color) @cname("DrawRing");
// Draw ring outline
fn void drawRingLines(RLVector2 center, float innerRadius, float outerRadius, float startAngle, float endAngle, CInt segments, RLColor color) @cname("DrawRingLines");
// Draw a color-filled rectangle
fn void drawRectangle(CInt posX, CInt posY, CInt width, CInt height, RLColor color) @cname("DrawRectangle");
// Draw a color-filled rectangle (Vector version)
fn void drawRectangleV(RLVector2 position, RLVector2 size, RLColor color) @cname("DrawRectangleV");
// Draw a color-filled rectangle
fn void drawRectangleRec(RLRectangle rec, RLColor color) @cname("DrawRectangleRec");
// Draw a color-filled rectangle with pro parameters
fn void drawRectanglePro(RLRectangle rec, RLVector2 origin, float rotation, RLColor color) @cname("DrawRectanglePro");
// Draw a vertical-gradient-filled rectangle
fn void drawRectangleGradientV(CInt posX, CInt posY, CInt width, CInt height, RLColor top, RLColor bottom) @cname("DrawRectangleGradientV");
// Draw a horizontal-gradient-filled rectangle
fn void drawRectangleGradientH(CInt posX, CInt posY, CInt width, CInt height, RLColor left, RLColor right) @cname("DrawRectangleGradientH");
// Draw a gradient-filled rectangle with custom vertex colors
fn void drawRectangleGradientEx(RLRectangle rec, RLColor topLeft, RLColor bottomLeft, RLColor topRight, RLColor bottomRight) @cname("DrawRectangleGradientEx");
// Draw rectangle outline
fn void drawRectangleLines(CInt posX, CInt posY, CInt width, CInt height, RLColor color) @cname("DrawRectangleLines");
// Draw rectangle outline with extended parameters
fn void drawRectangleLinesEx(RLRectangle rec, float lineThick, RLColor color) @cname("DrawRectangleLinesEx");
// Draw rectangle with rounded edges
fn void drawRectangleRounded(RLRectangle rec, float roundness, CInt segments, RLColor color) @cname("DrawRectangleRounded");
// Draw rectangle lines with rounded edges
fn void drawRectangleRoundedLines(RLRectangle rec, float roundness, CInt segments, float lineThick, RLColor color) @cname("DrawRectangleRoundedLines");
// Draw rectangle with rounded edges outline
fn void drawRectangleRoundedLinesEx(RLRectangle rec, float roundness, CInt segments, float lineThick, RLColor color) @cname("DrawRectangleRoundedLinesEx");
// Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void drawTriangle(RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("DrawTriangle");
// Draw triangle outline (vertex in counter-clockwise order!)
fn void drawTriangleLines(RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("DrawTriangleLines");
// Draw a triangle fan defined by points (first vertex is the center)
fn void drawTriangleFan(RLVector2 *points, CInt pointCount, RLColor color) @cname("DrawTriangleFan");
// Draw a triangle strip defined by points
fn void drawTriangleStrip(RLVector2 *points, CInt pointCount, RLColor color) @cname("DrawTriangleStrip");
// Draw a regular polygon (Vector version)
fn void drawPoly(RLVector2 center, CInt sides, float radius, float rotation, RLColor color) @cname("DrawPoly");
// Draw a polygon outline of n sides
fn void drawPolyLines(RLVector2 center, CInt sides, float radius, float rotation, RLColor color) @cname("DrawPolyLines");
// Draw a polygon outline of n sides with extended parameters
fn void drawPolyLinesEx(RLVector2 center, CInt sides, float radius, float rotation, float lineThick, RLColor color) @cname("DrawPolyLinesEx");

// Splines drawing functions
// Draw spline: Linear, minimum 2 points
fn void drawSplineLinear(RLVector2 *points, CInt pointCount, float thick, RLColor color) @cname("DrawSplineLinear");
// Draw spline: B-Spline, minimum 4 points
fn void drawSplineBasis(RLVector2 *points, CInt pointCount, float thick, RLColor color);
// Draw spline: Catmull-Rom, minimum 4 points
fn void drawSplineCatmullRom(RLVector2 *points, CInt pointCount, float thick, RLColor color);
// Draw spline: Quadratic Bezier, minimum 3 points (1 control point): [p1, c2, p3, c4...]
fn void drawSplineBezierQuadratic(RLVector2 *points, CInt pointCount, float thick, RLColor color);
// Draw spline: Cubic Bezier, minimum 4 points (2 control points): [p1, c2, c3, p4, c5, c6...]
fn void drawSplineBezierCubic(RLVector2 *points, CInt pointCount, float thick, RLColor color);
// Draw spline segment: Linear, 2 points
fn void drawSplineSegmentLinear(RLVector2 p1, RLVector2 p2, float thick, RLColor color);
// Draw spline segment: B-Spline, 4 points
fn void drawSplineSegmentBasis(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float thick, RLColor color);
// Draw spline segment: Catmull-Rom, 4 points
fn void drawSplineSegmentCatmullRom(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float thick, RLColor color);
// Draw spline segment: Quadratic Bezier, 2 points, 1 control point
fn void drawSplineSegmentBezierQuadratic(RLVector2 p1, RLVector2 c2, RLVector2 p3, float thick, RLColor color);
// Draw spline segment: Cubic Bezier, 2 points, 2 control points
fn void drawSplineSegmentBezierCubic(RLVector2 p1, RLVector2 c2, RLVector2 c3, RLVector2 p4, float thick, RLColor color);

// Spline segment point evaluation functions, for a given t [0.0f .. 1.0f]
// Get (evaluate) spline point: Linear
fn RLVector2 getSplinePointLinear(RLVector2 startPos, RLVector2 endPos, float t);
// Get (evaluate) spline point: B-Spline
fn RLVector2 getSplinePointBasis(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float t);
// Get (evaluate) spline point: Catmull-Rom
fn RLVector2 getSplinePointCatmullRom(RLVector2 p1, RLVector2 p2, RLVector2 p3, RLVector2 p4, float t);
// Get (evaluate) spline point: Quadratic Bezier
fn RLVector2 getSplinePointBezierQuad(RLVector2 p1, RLVector2 c2, RLVector2 p3, float t);
// Get (evaluate) spline point: Cubic Bezier
fn RLVector2 getSplinePointBezierCubic(RLVector2 p1, RLVector2 c2, RLVector2 c3, RLVector2 p4, float t);

// Basic shapes collision detection functions
// Check collision between two rectangles
fn bool checkCollisionRecs(RLRectangle rec1, RLRectangle rec2) @cname("CheckCollisionRecs");
// Check collision between two circles
fn bool checkCollisionCircles(RLVector2 center1, float radius1, RLVector2 center2, float radius2) @cname("CheckCollisionCircles");
// Check collision between circle and rectangle
fn bool checkCollisionCircleRec(RLVector2 center, float radius, RLRectangle rec) @cname("CheckCollisionCircleRec");
// Check if circle collides with a line created betweeen two points [p1] and [p2]
fn bool checkCollisionCircleLine(RLVector2 center, float radius, RLVector2 p1, RLVector2 p2) @cname("CheckCollisionCircleLine");
// Check if point is inside rectangle
fn bool checkCollisionPointRec(RLVector2 point, RLRectangle rec) @cname("CheckCollisionPointRec");
// Check if point is inside circle
fn bool checkCollisionPointCircle(RLVector2 point, RLVector2 center, float radius) @cname("CheckCollisionPointCircle");
// Check if point is inside a triangle
fn bool checkCollisionPointTriangle(RLVector2 point, RLVector2 p1, RLVector2 p2, RLVector2 p3) @cname("CheckCollisionPointTriangle");
// Check if point belongs to line created between two points [p1] and [p2] with defined margin in pixels [threshold]
fn bool checkCollisionPointLine(RLVector2 point, RLVector2 p1, RLVector2 p2, CInt threshold) @cname("CheckCollisionPointLine");
// Check if point is within a polygon described by array of vertices
fn bool checkCollisionPointPoly(RLVector2 point, RLVector2 *points, CInt pointCount) @cname("CheckCollisionPointPoly");
// Check the collision between two lines defined by two points each, returns collision point by reference
fn bool checkCollisionLines(RLVector2 startPos1, RLVector2 endPos1, RLVector2 startPos2, RLVector2 endPos2, RLVector2 *collisionPoint) @cname("CheckCollisionLines");
// Get collision rectangle for two rectangles collision
fn RLRectangle getCollisionRec(RLRectangle rec1, RLRectangle rec2) @cname("GetCollisionRec");

//------------------------------------------------------------------------------------
// RLTexture Loading and Drawing Functions (Module: textures)
//------------------------------------------------------------------------------------

// RLImage loading functions
// NOTE: This functions do not require GPU access
// Load image from file into CPU memory (RAM)
fn RLImage loadImage(ZString fileName) @cname("LoadImage");
// Load image from RAW file data
fn RLImage loadImageRaw(ZString fileName, CInt width, CInt height, CInt format, CInt headerSize) @cname("LoadImageRaw");
// Load image from SVG file data or string with specified size
fn RLImage loadImageSvg(ZString fileNameOrString, CInt width, CInt height) @cname("LoadImageSvg");
// Load image sequence from file (frames appended to image.data)
fn RLImage loadImageAnim(ZString fileName, CInt* frames) @cname("LoadImageAnim");
// Load image sequence from memory buffer
fn RLImage loadImageAnimFromMemory(ZString fileType, ZString fileData, CInt dataSize, CInt* frames) @cname("LoadImageAnimFromMemory");
// Load image from memory buffer, fileType refers to extension: i.e. '.png'
fn RLImage loadImageFromMemory(ZString fileType, char* fileData, CInt dataSize) @cname("LoadImageFromMemory");
// Load image from GPU texture data
fn RLImage loadImageFromTexture(RLTexture2D texture) @cname("LoadImageFromTexture");
// Load image from screen buffer and (screenshot)
fn RLImage loadImageFromScreen() @cname("LoadImageFromScreen");
// Check if an image is valid (data and parameters)
fn bool isImageValid(RLImage image) @cname("IsImageValid");
// Unload image from CPU memory (RAM)
fn void unloadImage(RLImage image) @cname("UnloadImage");
// Export image data to file, returns true on success
fn bool exportImage(RLImage image, ZString fileName) @cname("ExportImage");
// Export image to memory buffer
fn char* exportImageToMemory(RLImage image, ZString fileType, CInt* fileSize) @cname("ExportImageToMemory");
// Export image as code file defining an array of bytes, returns true on success
fn bool exportImageAsCode(RLImage image, ZString fileName) @cname("ExportImageAsCode");

// RLImage generation functions
// Generate image: plain color
fn RLImage genImageColor(CInt width, CInt height, RLColor color) @cname("GenImageColor");
// Generate image: vertical gradient
fn RLImage genImageGradientLinear(CInt width, CInt height, CInt direction, RLColor start, RLColor end) @cname("GenImageGradientLinear");
// Generate image: horizontal gradient
fn RLImage genImageGradientSquare(CInt width, CInt height, float density, RLColor inner, RLColor outer) @cname("GenImageGradientSquare");
// Generate image: radial gradient
fn RLImage genImageGradientRadial(CInt width, CInt height, float density, RLColor inner, RLColor outer) @cname("GenImageGradientRadial");
// Generate image: checked
fn RLImage genImageChecked(CInt width, CInt height, CInt checksX, CInt checksY, RLColor col1, RLColor col2) @cname("GenImageChecked");
// Generate image: white noise
fn RLImage genImageWhiteNoise(CInt width, CInt height, float factor) @cname("GenImageWhiteNoise");
// Generate image: perlin noise
fn RLImage genImagePerlinNoise(CInt width, CInt height, CInt offsetX, CInt offsetY, float scale) @cname("GenImagePerlinNoise");
// Generate image: cellular algorithm, bigger tileSize means bigger cells
fn RLImage genImageCellular(CInt width, CInt height, CInt tileSize) @cname("GenImageCellular");
// Generate image: grayscale image from text data
fn RLImage genImageText(CInt width, CInt height, ZString text) @cname("GenImageText");

// RLImage manipulation functions
// Create an image duplicate (useful for transformations)
fn RLImage imageCopy(RLImage image) @cname("ImageCopy");
// Create an image from another image piece
fn RLImage imageFromImage(RLImage image, RLRectangle rec) @cname("ImageFromImage");
// Create an image from a selected channel of another image (GRAYSCALE)
fn RLImage imageFromChannel(RLImage image, CInt selectedChannel) @cname("ImageFromChannel");
// Create an image from text (default font)
fn RLImage imageText(ZString text, CInt fontSize, RLColor color) @cname("ImageText");
// Create an image from text (custom sprite font)
fn RLImage imageTextEx(RLFont font, ZString text, float fontSize, float spacing, RLColor tint) @cname("ImageTextEx");
// Convert image data to desired format
fn void imageFormat(RLImage* image, RLPixelFormat newFormat) @cname("ImageFormat");
// Convert image to POT (power-of-two)
fn void imageToPOT(RLImage* image, RLColor fill) @cname("ImageToPOT");
// Crop an image to a defined rectangle
fn void imageCrop(RLImage* image, RLRectangle crop) @cname("ImageCrop");
// Crop image depending on alpha value
fn void imageAlphaCrop(RLImage* image, float threshold) @cname("ImageAlphaCrop");
// Clear alpha channel to desired color
fn void imageAlphaClear(RLImage* image, RLColor color, float threshold) @cname("ImageAlphaClear");
// Apply alpha mask to image
fn void imageAlphaMask(RLImage* image, RLImage alphaMask) @cname("ImageAlphaMask");
// Premultiply alpha channel
fn void imageAlphaPremultiply(RLImage* image) @cname("ImageAlphaPremultiply");
// Apply Gaussian blur using a box blur approximation
fn void imageBlurGaussian(RLImage* image, CInt blurSize) @cname("ImageBlurGaussian");
// Apply custom square convolution kernel to image
fn void imageKernelConvolution(RLImage *image, float *kernel, CInt kernelSize) @cname("ImageKernelConvolution");
// Resize image (Bicubic scaling algorithm)
fn void imageResize(RLImage* image, CInt newWidth, CInt newHeight) @cname("ImageResize");
// Resize image (Nearest-Neighbor scaling algorithm)
fn void imageResizeNN(RLImage* image, CInt newWidth,CInt newHeight) @cname("ImageResizeNN");
// Resize canvas and fill with color
fn void imageResizeCanvas(RLImage* image, CInt newWidth, CInt newHeight, CInt offsetX, CInt offsetY, RLColor fill) @cname("ImageResizeCanvas");
// Compute all mipmap levels for a provided image
fn void imageMipmaps(RLImage* image) @cname("ImageMipmaps");
// Dither image data to 16bpp or lower (Floyd-Steinberg dithering)
fn void imageDither(RLImage* image, CInt rBpp, CInt gBpp, CInt bBpp, CInt aBpp) @cname("ImageDither");
// Flip image vertically
fn void imageFlipVertical(RLImage* image) @cname("ImageFlipVertical");
// Flip image horizontally
fn void imageFlipHorizontal(RLImage* image) @cname("ImageFlipHorizontal");
// Rotate image by input angle in degrees (-359 to 359)
fn void imageRotate(RLImage* image, CInt degrees) @cname("ImageRotate");
// Rotate image clockwise 90deg
fn void imageRotateCW(RLImage* image) @cname("ImageRotateCW");
// Rotate image counter-clockwise 90deg
fn void imageRotateCCW(RLImage* image) @cname("ImageRotateCCW");
// Modify image color: tint
fn void imageColorTint(RLImage* image, RLColor color) @cname("ImageColorTint");
// Modify image color: invert
fn void imageColorInvert(RLImage* image) @cname("ImageColorInvert");
// Modify image color: grayscale
fn void imageColorGrayscale(RLImage* image) @cname("ImageColorGrayscale");
// Modify image color: contrast (-100 to 100)
fn void imageColorContrast(RLImage* image, float contrast) @cname("ImageColorContrast");
// Modify image color: brightness (-255 to 255)
fn void imageColorBrightness(RLImage* image, CInt brightness) @cname("ImageColorBrightness");
// Modify image color: replace color
fn void imageColorReplace(RLImage* image, RLColor color, RLColor replace) @cname("ImageColorReplace");
// Load color data from image as a RLColor array (RGBA - 32bit)
fn RLColor *loadImageColors(RLImage image) @cname("LoadImageColors");
// Load colors palette from image as a RLColor array (RGBA - 32bit)
fn RLColor *loadImagePalette(RLImage image, CInt maxPaletteSize, CInt *colorCount) @cname("LoadImagePalette");
// Unload color data loaded with LoadImageColors()
fn void unloadImageColors(RLColor* colors) @cname("UnloadImageColors");
// Unload colors palette loaded with LoadImagePalette()
fn void unloadImagePalette(RLColor* colors) @cname("UnloadImagePalette");
// Get image alpha border rectangle
fn RLRectangle getImageAlphaBorder(RLImage image, float threshold) @cname("GetImageAlphaBorder");
// Get image pixel color at (x, y) position
fn RLColor getImageColor(RLImage image, CInt x, CInt y) @cname("GetImageColor");

// RLImage drawing functions
// NOTE: RLImage software-rendering functions (CPU)
// Clear image background with given color
fn void imageClearBackground(RLImage* dst, RLColor color) @cname("ImageClearBackground");
// Draw pixel within an image
fn void imageDrawPixel(RLImage* dst, CInt posX, CInt posY, RLColor color) @cname("ImageDrawPixel");
// Draw pixel within an image (Vector version)
fn void imageDrawPixelV(RLImage* dst, RLVector2 position, RLColor color) @cname("ImageDrawPixelV");
// Draw line within an image
fn void imageDrawLine(RLImage* dst, CInt startPosX, CInt startPosY, CInt endPosX, CInt endPosY, RLColor color) @cname("ImageDrawLine");
// Draw line within an image (Vector version)
fn void imageDrawLineV(RLImage* dst, RLVector2 start, RLVector2 end, RLColor color) @cname("ImageDrawLineV");
// Draw a line defining thickness within an image
fn void imageDrawLineEx(RLImage *dst, RLVector2 start, RLVector2 end, CInt thick, RLColor color) @cname("ImageDrawLineEx");
// Draw circle within an image
fn void imageDrawCircle(RLImage* dst, CInt centerX, CInt centerY, CInt radius, RLColor color) @cname("ImageDrawCircle");
// Draw circle within an image (Vector version)
fn void imageDrawCircleV(RLImage* dst, RLVector2 center, CInt radius, RLColor color) @cname("ImageDrawCircleV");
// Draw circle outline within an image
fn void imageDrawCircleLines(RLImage* dst, CInt centerX, CInt centerY, CInt radius, RLColor color) @cname("ImageDrawCircleLines");
// Draw circle outline within an image (Vector version)
fn void imageDrawCircleLinesV(RLImage* dst, RLVector2 center, CInt radius, RLColor color) @cname("ImageDrawCircleLinesV");
// Draw rectangle within an image
fn void imageDrawRectangle(RLImage* dst, CInt posX, CInt posY, CInt width, CInt height, RLColor color) @cname("ImageDrawRectangle");
// Draw rectangle within an image (Vector version)
fn void imageDrawRectangleV(RLImage* dst, RLVector2 position, RLVector2 size, RLColor color) @cname("ImageDrawRectangleV");
// Draw rectangle within an image
fn void imageDrawRectangleRec(RLImage* dst, RLRectangle rec, RLColor color) @cname("ImageDrawRectangleRec");
// Draw rectangle lines within an image
fn void imageDrawRectangleLines(RLImage* dst, RLRectangle rec, CInt thick, RLColor color) @cname("ImageDrawRectangleLines");
// Draw triangle within an image
fn void imageDrawTriangle(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("ImageDrawTriangle");
// Draw triangle with interpolated colors within an image
fn void imageDrawTriangleEx(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor c1, RLColor c2, RLColor c3) @cname("ImageDrawTriangleEx");
// Draw triangle outline within an image
fn void imageDrawTriangleLines(RLImage *dst, RLVector2 v1, RLVector2 v2, RLVector2 v3, RLColor color) @cname("ImageDrawTriangleLines");
// Draw a triangle fan defined by points within an image (first vertex is the center)
fn void imageDrawTriangleFan(RLImage *dst, RLVector2 *points, CInt pointCount, RLColor color) @cname("ImageDrawTriangleFan");
// Draw a triangle strip defined by points within an image
fn void imageDrawTriangleStrip(RLImage *dst, RLVector2 *points, CInt pointCount, RLColor color);
// Draw a source image within a destination image (tint applied to source)
fn void imageDraw(RLImage* dst, RLImage src, RLRectangle srcRec, RLRectangle dstRec, RLColor tint) @cname("ImageDraw");
// Draw text (using default font) within an image (destination)
fn void imageDrawText(RLImage* dst, ZString text, CInt posX, CInt posY, CInt fontSize, RLColor color) @cname("ImageDrawText");
// Draw text (custom sprite font) within an image (destination)
fn void imageDrawTextEx(RLImage* dst, RLFont font, ZString text, RLVector2 position, float fontSize, float spacing, RLColor tint) @cname("ImageDrawTextEx");

// RLTexture loading functions
// NOTE: These functions require GPU access
// Load texture from file into GPU memory (VRAM)
fn RLTexture2D loadTexture(ZString fileName) @cname("LoadTexture");
// Load texture from image data
fn RLTexture2D loadTextureFromImage(RLImage image) @cname("LoadTextureFromImage");
// Load cubemap from image, multiple image cubemap layouts supported
fn RLTextureCubemap loadTextureCubemap(RLImage image, CInt layout) @cname("LoadTextureCubemap");
// Load texture for rendering (framebuffer)
fn RLRenderTexture2D loadRenderTexture(CInt width, CInt height) @cname("LoadRenderTexture");
// Check if a texture is valid (loaded in GPU)
fn bool isTextureValid(RLTexture2D texture) @cname("IsTextureValid");
// Unload texture from GPU memory (VRAM)
fn void unloadTexture(RLTexture2D texture) @cname("UnloadTexture");
// Check if a render texture is valid (loaded in GPU)
fn bool isRenderTextureValid(RLRenderTexture2D target) @cname("IsRenderTextureValid");
// Unload render texture from GPU memory (VRAM)
fn void unloadRenderTexture(RLRenderTexture2D target) @cname("UnloadRenderTexture");
// Update GPU texture with new data
fn void updateTexture(RLTexture2D texture, void* pixels) @cname("UpdateTexture");
// Update GPU texture rectangle with new data
fn void updateTextureRec(RLTexture2D texture, RLRectangle rec, void* pixels) @cname("UpdateTextureRec");

// RLTexture configuration functions
// Generate GPU mipmaps for a texture
fn void genTextureMipmaps(RLTexture2D* texture) @cname("GenTextureMipmaps");
// Set texture scaling filter mode
fn void setTextureFilter(RLTexture2D texture, RLTextureFilter filter) @cname("SetTextureFilter");
// Set texture wrapping mode
fn void setTextureWrap(RLTexture2D texture, CInt wrap) @cname("SetTextureWrap");

// RLTexture drawing functions
// Draw a RLTexture2D
fn void drawTexture(RLTexture2D texture, CInt posX, CInt posY, RLColor tint) @cname("DrawTexture");
// Draw a RLTexture2D with position defined as RLVector2
fn void drawTextureV(RLTexture2D texture, RLVector2 position, RLColor tint) @cname("DrawTextureV");
// Draw a RLTexture2D with extended parameters
fn void drawTextureEx(RLTexture2D texture, RLVector2 position, float rotation, float scale, RLColor tint) @cname("DrawTextureEx");
// Draw a part of a texture defined by a rectangle
fn void drawTextureRec(RLTexture2D texture, RLRectangle source, RLVector2 position, RLColor tint) @cname("DrawTextureRec");
// Draw a part of a texture defined by a rectangle with 'pro' parameters
fn void drawTexturePro(RLTexture2D texture, RLRectangle source, RLRectangle dest, RLVector2 origin, float rotation, RLColor tint) @cname("DrawTexturePro");
// Draws a texture (or part of it) that stretches or shrinks nicely
fn void drawTextureNPatch(RLTexture2D texture, NPatchInfo nPatchInfo, RLRectangle dest, RLVector2 origin, float rotation, RLColor tint) @cname("DrawTextureNPatch");

// RLColor/pixel related functions
// Check if two colors are equal
fn bool colorIsEqual(RLColor col1, RLColor col2) @cname("ColorIsEqual");
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn RLColor fade(RLColor color, float alpha) @cname("Fade");
//  Get hexadecimal value for a RLColor (0xRRGGBBAA)
fn CInt colorToInt(RLColor color) @cname("ColorToInt");
// Get RLColor normalized as float [0..1]
fn RLVector4 colorNormalize(RLColor color) @cname("ColorNormalize");
// Get RLColor from normalized values [0..1]
fn RLColor colorFromNormalized(RLVector4 normalized) @cname("ColorFromNormalized");
// Get HSV values for a RLColor, hue [0..360], saturation/value [0..1]
fn RLVector3 colorToHSV(RLColor color) @cname("ColorToHSV");
// Get a RLColor from HSV values, hue [0..360], saturation/value [0..1]
fn RLColor colorFromHSV(float hue, float saturation, float value) @cname("ColorFromHSV");
// Get color multiplied with another color
fn RLColor colorTint(RLColor color, RLColor tint) @cname("ColorTint");
// Get color with brightness correction, brightness factor goes from -1.0f to 1.0f
fn RLColor colorBrightness(RLColor color, float factor) @cname("ColorBrightness");
// Get color with contrast correction, contrast values between -1.0f and 1.0f
fn RLColor colorContrast(RLColor color, float contrast) @cname("ColorContrast");
// Get color with alpha applied, alpha goes from 0.0f to 1.0f
fn RLColor colorAlpha(RLColor color, float alpha) @cname("ColorAlpha");
// Get src alpha-blended into dst color with tint
fn RLColor colorAlphaBlend(RLColor dst, RLColor src, RLColor tint) @cname("ColorAlphaBlend");
// Get color lerp interpolation between two colors, factor [0.0f..1.0f]
fn  RLColor colorLerp(RLColor color1, RLColor color2, float factor) @cname("ColorLerp");
// Get RLColor structure from hexadecimal value
fn RLColor getColor(CUInt hexValue) @cname("GetColor");
// Get RLColor from a source pixel pointer of certain format
fn RLColor getPixelColor(void* srcPtr, CInt format) @cname("GetPixelColor");
// Set color formatted into destination pixel pointer
fn void setPixelColor(void* dstPtr, RLColor color, RLPixelFormat format) @cname("SetPixelColor");
// Get pixel data size in bytes for certain format
fn CInt getPixelDataSize(CInt width, CInt height, RLPixelFormat format) @cname("GetPixelDataSize");

//------------------------------------------------------------------------------------
// RLFont Loading and Text Drawing Functions (Module: text)
//------------------------------------------------------------------------------------

// RLFont loading/unloading functions
// Get the default RLFont
fn RLFont getFontDefault() @cname("GetFontDefault");
// Load font from file into GPU memory (VRAM)
fn RLFont loadFont(ZString fileName) @cname("LoadFont");
// Load font from file with extended parameters, use NULL for fontChars and 0 for glyphCount to load the default character set
fn RLFont loadFontEx(ZString fileName, CInt fontSize, CInt* fontChars, CInt glyphCount) @cname("LoadFontEx");
// Load font from RLImage (XNA style)
fn RLFont loadFontFromImage(RLImage image, RLColor key, CInt firstChar) @cname("LoadFontFromImage");
// Load font from memory buffer, fileType refers to extension: i.e. '.ttf'
fn RLFont loadFontFromMemory(ZString fileType, char* fileData, CInt dataSize, CInt fontSize, CInt* fontChars, CInt glyphCount) @cname("LoadFontFromMemory");
// Check if a font is valid (font data loaded, WARNING: GPU texture not checked)
fn bool isFontValid(RLFont font) @cname("IsFontValid");
// Load font data for further use
fn GlyphInfo* loadFontData(char* fileData, CInt dataSize, CInt fontSize, CInt *fontChars, CInt glyphCount, CInt type) @cname("LoadFontData");
// Generate image font atlas using chars info
fn RLImage genImageFontAtlas(GlyphInfo* chars, RLRectangle **recs, CInt glyphCount, CInt fontSize, CInt padding, CInt packMethod) @cname("GenImageFontAtlas");
// Unload font chars info data (RAM)
fn void unloadFontData(GlyphInfo* chars, CInt glyphCount) @cname("UnloadFontData");
// Unload font from GPU memory (VRAM)
fn void unloadFont(RLFont font) @cname("UnloadFont");
// Export font as code file, returns true on success
fn bool exportFontAsCode(RLFont font, ZString fileName) @cname("ExportFontAsCode");


// Text drawing functions
// Draw current FPS
fn void drawFPS(CInt posX, CInt posY) @cname("DrawFPS");
// Draw text (using default font)
fn void drawText(ZString text, CInt posX, CInt posY, CInt fontSize, RLColor color) @cname("DrawText");
// Draw text using font and additional parameters
fn void drawTextEx(RLFont font, ZString text, RLVector2 position, float fontSize, float spacing, RLColor tint) @cname("DrawTextEx");
// Draw text using RLFont and pro parameters (rotation)
fn void drawTextPro(RLFont font, ZString text, RLVector2 position, RLVector2 origin, float rotation, float fontSize, float spacing, RLColor tint) @cname("DrawTextPro");
// Draw one character (codepoint)
fn void drawTextCodepoint(RLFont font, CInt codepoint, RLVector2 position, float fontSize, RLColor tint) @cname("DrawTextCodepoint");
// Draw multiple character (codepoint)
fn void drawTextCodepoints(RLFont font, CInt* codepoints, CInt count, RLVector2 position, float fontSize, float spacing, RLColor tint) @cname("DrawTextCodepoints");

// Text font info functions
// Set vertical line spacing when drawing with line-breaks
fn void setTextLineSpacing(CInt spacing) @cname("SetTextLineSpacing");
// Measure string width for default font
fn CInt measureText(ZString text, CInt fontSize) @cname("MeasureText");
// Measure string size for RLFont
fn RLVector2 measureTextEx(RLFont font, ZString text, float fontSize, float spacing) @cname("MeasureTextEx");
// Get glyph index position in font for a codepoint (unicode character), fallback to '?' if not found
fn CInt getGlyphIndex(RLFont font, CInt codepoint) @cname("GetGlyphIndex");
// Get glyph font info data for a codepoint (unicode character), fallback to '?' if not found
fn GlyphInfo getGlyphInfo(RLFont font, CInt codepoint) @cname("GetGlyphInfo");
// Get glyph rectangle in font atlas for a codepoint (unicode character), fallback to '?' if not found
fn RLRectangle getGlyphAtlasRec(RLFont font, CInt codepoint) @cname("GetGlyphAtlasRec");

// Text codepoints management functions (unicode characters)
// Load UTF-8 text encoded from codepoints array
fn ZString loadUTF8(CInt *codepoints, CInt length) @cname("LoadUTF8");
// Unload UTF-8 text encoded from codepoints array
fn void unloadUTF8(ZString text) @cname("UnloadUTF8");
// Load all codepoints from a UTF-8 text string, codepoints count returned by parameter
fn CInt* loadCodepoints(ZString text, CInt* count) @cname("LoadCodepoints");
// Unload codepoints data from memory
fn void unloadCodepoints(CInt* codepoints) @cname("UnloadCodepoints");
// Get total number of codepoints in a UTF-8 encoded string
fn CInt getCodepointCount(ZString text) @cname("GetCodepointCount");
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt getCodepoint(ZString text, CInt *bytesProcessed) @cname("GetCodepoint");
// Get next codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt getCodepointNext(ZString text, CInt *codepointSize) @cname("GetCodepointNext");
// Get previous codepoint in a UTF-8 encoded string, 0x3f('?') is returned on failure
fn CInt getCodepointPrevious(ZString text, CInt *codepointSize) @cname("GetCodepointPrevious");
// Encode one codepoint into UTF-8 byte array (array length returned as parameter)
fn ZString codepointToUTF8(CInt codepoint, CInt* byteSize) @cname("CodepointToUTF8");


// Text strings management functions (no UTF-8 strings, only byte chars)
// NOTE: Some strings allocate memory internally for returned strings, just be careful!
// Copy one string to another, returns bytes copied
fn CInt textCopy(char* dst, char* src) @cname("TextCopy");
// Check if two text string are equal
fn bool textIsEqual(ZString text1, ZString text2) @cname("TextIsEqual");
// Get text length, checks for '\0' ending
fn CUInt textLength(ZString text) @cname("TextLength");
// Text formatting with variables (sprintf() style)
fn ZString textFormat(ZString text, ...) @cname("TextFormat");
// Get a piece of a text string
fn ZString textSubtext(ZString text, CInt position, CInt length) @cname("TextSubtext");
// Replace text string (WARNING: memory must be freed!)
fn ZString textReplace(ZString text, ZString replace, ZString by) @cname("TextReplace");
// Insert text in a position (WARNING: memory must be freed!)
fn ZString textInsert(ZString text, ZString insert, CInt position) @cname("TextInsert");
// Join text strings with delimiter
fn ZString textJoin(ZString* textList, CInt count, ZString delimiter) @cname("TextJoin");
// Split text into multiple strings
fn ZString* textSplit(ZString text, char delimiter, CInt *count) @cname("TextSplit");
// Append text at specific position and move cursor!
fn void textAppend(ZString text, ZString append, CInt* position) @cname("TextAppend");
// Find first text occurrence within a string
fn CInt textFindIndex(ZString text, ZString find) @cname("TextFindIndex");
// Get upper case version of provided string
fn ZString textToUpper(ZString text) @cname("TextToUpper");
// Get lower case version of provided string
fn ZString textToLower(ZString text) @cname("TextToLower");
// Get Pascal case notation version of provided string
fn ZString textToPascal(ZString text) @cname("TextToPascal");
// Get Snake case notation version of provided string
fn ZString textToSnake(ZString text) @cname("TextToSnake");
// Get Camel case notation version of provided string
fn ZString textToCamel(ZString text) @cname("TextToCamel");
// Get integer value from text (negative values not supported)
fn CInt textToInteger(ZString text) @cname("TextToInteger");
// Get float value from text (negative values not supported)
fn float textToFloat(ZString text) @cname("TextToFloat");
//------------------------------------------------------------------------------------
// Basic 3d Shapes Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// Basic geometric 3D shapes drawing functions
// Draw a line in 3D world space
fn void drawLine3D(RLVector3 startPos, RLVector3 endPos, RLColor color) @cname("DrawLine3D");
// Draw a point in 3D space, actually a small line
fn void drawPoint3D(RLVector3 position, RLColor color) @cname("DrawPoint3D");
// Draw a circle in 3D world space
fn void drawCircle3D(RLVector3 center, float radius, RLVector3 rotationAxis, float rotationAngle, RLColor color) @cname("DrawCircle3D");
// Draw a color-filled triangle (vertex in counter-clockwise order!)
fn void drawTriangle3D(RLVector3 v1, RLVector3 v2, RLVector3 v3, RLColor color) @cname("DrawTriangle3D");
// Draw a triangle strip defined by points
fn void drawTriangleStrip3D(RLVector3 *points, CInt pointCount, RLColor color) @cname("DrawTriangleStrip3D");
// Draw cube
fn void drawCube(RLVector3 position, float width, float height, float length, RLColor color) @cname("DrawCube");
// Draw cube (Vector version)
fn void drawCubeV(RLVector3 position, RLVector3 size, RLColor color) @cname("DrawCubeV");
// Draw cube wires
fn void drawCubeWires(RLVector3 position, float width, float height, float length, RLColor color) @cname("DrawCubeWires");
// Draw cube wires (Vector version)
fn void drawCubeWiresV(RLVector3 position, RLVector3 size, RLColor color) @cname("DrawCubeWiresV");
// Draw sphere
fn void drawSphere(RLVector3 centerPos, float radius, RLColor color) @cname("DrawSphere");
// Draw sphere with extended parameters
fn void drawSphereEx(RLVector3 centerPos, float radius, CInt rings, CInt slices, RLColor color) @cname("DrawSphereEx");
// Draw sphere wires
fn void drawSphereWires(RLVector3 centerPos, float radius, CInt rings, CInt slices, RLColor color) @cname("DrawSphereWires");
// Draw a cylinder/cone
fn void drawCylinder(RLVector3 position, float radiusTop, float radiusBottom, float height, CInt slices, RLColor color) @cname("DrawCylinder");
// Draw a cylinder with base at startPos and top at endPos
fn void drawCylinderEx(RLVector3 startPos, RLVector3 endPos, float startRadius, float endRadius, CInt sides, RLColor color) @cname("DrawCylinderEx");
// Draw a cylinder/cone wires
fn void drawCylinderWires(RLVector3 position, float radiusTop, float radiusBottom, float height, CInt slices, RLColor color) @cname("DrawCylinderWires");
// Draw a cylinder wires with base at startPos and top at endPos
fn void drawCylinderWiresEx(RLVector3 startPos, RLVector3 endPos, float startRadius, float endRadius, CInt sides, RLColor color) @cname("DrawCylinderWiresEx");
// Draw a capsule with the center of its sphere caps at startPos and endPos
fn void drawCapsule(RLVector3 startPos, RLVector3 endPos, float radius, CInt slices, CInt rings, RLColor color) @cname("DrawCapsule");
//Draw capsule wireframe with the center of its sphere caps at startPos and endPos
fn void drawCapsuleWires(RLVector3 startPos, RLVector3 endPos, float radius, CInt slices, CInt rings, RLColor color) @cname("DrawCapsuleWires");
// Draw a plane XZ
fn void drawPlane(RLVector3 centerPos, RLVector2 size, RLColor color) @cname("DrawPlane");
// Draw a ray line
fn void drawRay(RLRay ray, RLColor color) @cname("DrawRay");
// Draw a grid (centered at (0, 0, 0))
fn void drawGrid(CInt slices, float spacing) @cname("DrawGrid");

//------------------------------------------------------------------------------------
// RLModel 3d Loading and Drawing Functions (Module: models)
//------------------------------------------------------------------------------------

// RLModel management functions
// Load model from files (meshes and materials)
fn RLModel loadModel(ZString fileName) @cname("LoadModel");
// Load model from generated mesh (default material)
fn RLModel loadModelFromMesh(RLMesh mesh) @cname("LoadModelFromMesh");
// Check if a model is ready
fn bool isModelValid(RLModel model) @cname("IsModelValid");
// Unload model (including meshes) from memory (RAM and/or VRAM)
fn void unloadModel(RLModel model) @cname("UnloadModel");
// Compute model bounding box limits (considers all meshes)
fn RLBoundingBox getModelBoundingBox(RLModel model) @cname("GetModelBoundingBox");

// RLModel drawing functions
// Draw a model (with texture if set)
fn void drawModel(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModel");
// Draw a model with extended parameters
fn void drawModelEx(RLModel model, RLVector3 position, RLVector3 rotationAxis, float rotationAngle, RLVector3 scale, RLColor tint) @cname("DrawModelEx");
// Draw a model wires (with texture if set)
fn void drawModelWires(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModelWires");
// Draw a model wires (with texture if set) with extended parameters
fn void drawModelWiresEx(RLModel model, RLVector3 position, RLVector3 rotationAxis, float rotationAngle, RLVector3 scale, RLColor tint) @cname("DrawModelWiresEx");
// Draw a model as points
fn void drawModelPoints(RLModel model, RLVector3 position, float scale, RLColor tint) @cname("DrawModelPoints");
// Draw a model as points with extended parameters
fn void drawModelPointsEx(RLModel model, RLVector3 position, RLVector3 rotationAxis, float rotationAngle, RLVector3 scale, RLColor tint) @cname("DrawModelPointsEx");
// Draw bounding box (wires)
fn void drawBoundingBox(RLBoundingBox box, RLColor color) @cname("DrawBoundingBox");
// Draw a billboard texture
fn void drawBillboard(RLCamera camera, RLTexture2D texture, RLVector3 position, float scale, RLColor tint) @cname("DrawBillboard");
// Draw a billboard texture defined by source
fn void drawBillboardRec(RLCamera camera, RLTexture2D texture, RLRectangle source, RLVector3 position, RLVector2 size, RLColor tint) @cname("DrawBillboardRec");
// Draw a billboard texture defined by source and rotation
fn void drawBillboardPro(RLCamera camera, RLTexture2D texture, RLRectangle source, RLVector3 position, RLVector3 up, RLVector2 size, RLVector2 origin, float rotation, RLColor tint) @cname("DrawBillboardPro");

// RLMesh management functions
// Upload mesh vertex data in GPU and provide VAO/VBO ids
fn void uploadMesh(RLMesh* mesh, bool dynamic) @cname("UploadMesh");
// Update mesh vertex data in GPU for a specific buffer index
fn void updateMeshBuffer(RLMesh mesh, CInt index, void* data, CInt dataSize, CInt offset) @cname("UpdateMeshBuffer");
// Unload mesh data from CPU and GPU
fn void unloadMesh(RLMesh mesh) @cname("UnloadMesh");
// Draw a 3d mesh with material and transform
fn void drawMesh(RLMesh mesh, RLMaterial material, RLMatrix transform) @cname("DrawMesh");
// Draw multiple mesh instances with material and different transforms
fn void drawMeshInstanced(RLMesh mesh, RLMaterial material, RLMatrix* transforms, CInt instances) @cname("DrawMeshInstanced");
// Compute mesh bounding box limits
fn RLBoundingBox getMeshBoundingBox(RLMesh mesh) @cname("GetMeshBoundingBox");
// Compute mesh tangents
fn void genMeshTangents(RLMesh* mesh) @cname("GenMeshTangents");
// Export mesh data to file, returns true on success
fn bool exportMesh(RLMesh mesh, ZString fileName) @cname("ExportMesh");
// Export mesh as code file (.h) defining multiple arrays of vertex attributes
fn bool exportMeshAsCode(RLMesh mesh, ZString fileName) @cname("ExportMeshAsCode");

// RLMesh generation functions
// Generate polygonal mesh
fn RLMesh genMeshPoly(CInt sides, float radius) @cname("GenMeshPoly");
// Generate plane mesh (with subdivisions)
fn RLMesh genMeshPlane(float width, float length, CInt resX, CInt resZ) @cname("GenMeshPlane");
// Generate cuboid mesh
fn RLMesh genMeshCube(float width, float height, float length) @cname("GenMeshCube");
// Generate sphere mesh (standard sphere)
fn RLMesh genMeshSphere(float radius, CInt rings, CInt slices) @cname("GenMeshSphere");
// Generate half-sphere mesh (no bottom cap)
fn RLMesh genMeshHemiSphere(float radius, CInt rings, CInt slices) @cname("GenMeshHemiSphere");
// Generate cylinder mesh
fn RLMesh genMeshCylinder(float radius, float height, CInt slices) @cname("GenMeshCylinder");
// Generate cone/pyramid mesh
fn RLMesh genMeshCone(float radius, float height, CInt slices) @cname("GenMeshCone");
// Generate torus mesh
fn RLMesh genMeshTorus(float radius, float size, CInt radSeg, CInt sides) @cname("GenMeshTorus");
// Generate trefoil knot mesh
fn RLMesh genMeshKnot(float radius, float size, CInt radSeg, CInt sides) @cname("GenMeshKnot");
// Generate heightmap mesh from image data
fn RLMesh genMeshHeightmap(RLImage heightmap, RLVector3 size) @cname("GenMeshHeightmap");
// Generate cubes-based map mesh from image data
fn RLMesh genMeshCubicmap(RLImage cubicmap, RLVector3 cubeSize) @cname("GenMeshCubicmap");

// RLMaterial loading/unloading functions
// Load materials from model file
fn RLMaterial* loadMaterials(ZString fileName, CInt* materialCount) @cname("LoadMaterials");
// Load default material (Supports: DIFFUSE, SPECULAR, NORMAL maps)
fn RLMaterial loadMaterialDefault() @cname("LoadMaterialDefault");
// Check if a material is ready
fn bool isMaterialValid(RLMaterial material) @cname("IsMaterialValid");
// Unload material from GPU memory (VRAM)
fn void unloadMaterial(RLMaterial material) @cname("UnloadMaterial");
// Set texture for a material map type (MATERIAL_MAP_DIFFUSE, MATERIAL_MAP_SPECULAR...)
fn void setMaterialTexture(RLMaterial* material, CInt mapType, RLTexture2D texture) @cname("SetMaterialTexture");
// Set material for a mesh
fn void setModelMeshMaterial(RLModel* model, CInt meshId, CInt materialId) @cname("SetModelMeshMaterial");

// RLModel animations loading/unloading functions
// Load model animations from file
fn RLModelAnimation* loadModelAnimations(ZString fileName, CInt* animCount) @cname("LoadModelAnimations");
// Update model animation pose
fn void updateModelAnimation(RLModel model, RLModelAnimation anim, CInt frame) @cname("UpdateModelAnimation");
// Update model animation mesh bone matrices (GPU skinning)
fn void updateModelAnimationBones(RLModel model, RLModelAnimation anim, CInt frame) @cname("UpdateModelAnimationBones");
// Unload animation data
fn void unloadModelAnimation(RLModelAnimation anim) @cname("UnloadModelAnimation");
// Unload animation array data
fn void unloadModelAnimations(RLModelAnimation* animations, CUInt count) @cname("UnloadModelAnimations");
// Check model animation skeleton match
fn bool isModelAnimationValid(RLModel model, RLModelAnimation anim) @cname("IsModelAnimationValid");

// Collision detection functions
// Check collision between two spheres
fn bool checkCollisionSpheres(RLVector3 center1, float radius1, RLVector3 center2, float radius2) @cname("CheckCollisionSpheres");
// Check collision between two bounding boxes
fn bool checkCollisionBoxes(RLBoundingBox box1, RLBoundingBox box2) @cname("CheckCollisionBoxes");
// Check collision between box and sphere
fn bool checkCollisionBoxSphere(RLBoundingBox box, RLVector3 center, float radius) @cname("CheckCollisionBoxSphere");
// Get collision info between ray and sphere
fn RLRayCollision getRayCollisionSphere(RLRay ray, RLVector3 center, float radius) @cname("GetRayCollisionSphere");
// Get collision info between ray and box
fn RLRayCollision getRayCollisionBox(RLRay ray, RLBoundingBox box) @cname("GetRayCollisionBox");
// Get collision info between ray and mesh
fn RLRayCollision getRayCollisionMesh(RLRay ray, RLMesh mesh, RLMatrix transform) @cname("GetRayCollisionMesh");
// Get collision info between ray and triangle
fn RLRayCollision getRayCollisionTriangle(RLRay ray, RLVector3 p1, RLVector3 p2, RLVector3 p3) @cname("GetRayCollisionTriangle");
// Get collision info between ray and quad
fn RLRayCollision getRayCollisionQuad(RLRay ray, RLVector3 p1, RLVector3 p2, RLVector3 p3, RLVector3 p4) @cname("GetRayCollisionQuad");

//------------------------------------------------------------------------------------
// Audio Loading and Playing Functions (Module: audio)
//------------------------------------------------------------------------------------

alias AudioCallback = fn void(void* bufferdata, CUInt frames);

// Audio device management functions
// Initialize audio device and context
fn void initAudioDevice() @cname("InitAudioDevice");
// Close the audio device and context
fn void closeAudioDevice() @cname("CloseAudioDevice");
// Check if audio device has been initialized successfully
fn bool isAudioDeviceReady() @cname("IsAudioDeviceReady");
// Set master volume (listener)
fn void setMasterVolume(float volume) @cname("SetMasterVolume");
// Get master volume (listener)
fn float getMasterVolume() @cname("GetMasterVolume");

// RLWave/RLSound loading/unloading functions
// Load wave data from file
fn RLWave loadWave(ZString fileName) @cname("LoadWave");
// Load wave from memory buffer, fileType refers to extension: i.e. '.wav'
fn RLWave loadWaveFromMemory(ZString fileType, char* fileData, CInt dataSize) @cname("LoadWaveFromMemory");
// Checks if wave data is valid (data loaded and parameters)
fn bool isWaveValid(RLWave wave) @cname("IsWaveValid");
// Load sound from file
fn RLSound loadSound(ZString fileName) @cname("LoadSound");
// Load sound from wave data
fn RLSound loadSoundFromWave(RLWave wave) @cname("LoadSoundFromWave");
// Create a new sound that shares the same sample data as the source sound, does not own the sound data
fn RLSound loadSoundAlias(RLSound source) @cname("LoadSoundAlias");
//Checks if a sound is valid (data loaded and buffers initialized)
fn bool isSoundValid(RLSound sound) @cname("IsSoundValid");
// Update sound buffer with new data
fn void updateSound(RLSound sound, void* data, CInt sampleCount) @cname("UpdateSound");
// Unload wave data
fn void unloadWave(RLWave wave) @cname("UnloadWave");
// Unload sound
fn void unloadSound(RLSound sound) @cname("UnloadSound");
// Export wave data to file, returns true on success
fn bool exportWave(RLWave wave, ZString fileName) @cname("ExportWave");
// Export wave sample data to code (.h), returns true on success
fn bool exportWaveAsCode(RLWave wave, ZString fileName) @cname("ExportWaveAsCode");

// RLWave/RLSound management functions
// Play a sound
fn void playSound(RLSound sound) @cname("PlaySound");
// Stop playing a sound
fn void stopSound(RLSound sound) @cname("StopSound");
// Pause a sound
fn void pauseSound(RLSound sound) @cname("PauseSound");
// Resume a paused sound
fn void resumeSound(RLSound sound) @cname("ResumeSound");
// Get number of sounds playing in the multichannel
fn CInt getSoundsPlaying() @cname("GetSoundsPlaying");
// Check if a sound is currently playing
fn bool isSoundPlaying(RLSound sound) @cname("IsSoundPlaying");
// Set volume for a sound (1.0 is max level)
fn void setSoundVolume(RLSound sound, float volume) @cname("SetSoundVolume");
// Set pitch for a sound (1.0 is base level)
fn void setSoundPitch(RLSound sound, float pitch) @cname("SetSoundPitch");
// Set pan for a sound (0.5 is center)
fn void setSoundPan(RLSound sound, float pan) @cname("SetSoundPan");
// Copy a wave to a new wave
fn RLWave waveCopy(RLWave wave) @cname("WaveCopy");
// Crop a wave to defined samples range
fn void waveCrop(RLWave* wave, CInt initFrame, CInt finalFrame) @cname("WaveCrop");
// Convert wave data to desired format
fn void waveFormat(RLWave* wave, CInt sampleRate, CInt sampleSize, CInt channels) @cname("WaveFormat");
// Load samples data from wave as a 32bit float data array
fn float* loadWaveSamples(RLWave wave) @cname("LoadWaveSamples");
// Unload samples data loaded with LoadWaveSamples()
fn void unloadWaveSamples(float* samples) @cname("UnloadWaveSamples");

// RLMusic management functions
// Checks if a music stream is valid (context and buffers initialized)
fn bool isMusicValid(RLMusic music) @cname("IsMusicValid");
// Load music stream from file
fn RLMusic loadMusicStream(ZString fileName) @cname("LoadMusicStream");
// Load music stream from data
fn RLMusic loadMusicStreamFromMemory(ZString fileType, char* data, CInt dataSize) @cname("LoadMusicStreamFromMemory");
// Unload music stream
fn void unloadMusicStream(RLMusic music) @cname("UnloadMusicStream");
// Start music playing
fn void playMusicStream(RLMusic music) @cname("PlayMusicStream");
// Check if music is playing
fn bool isMusicStreamPlaying(RLMusic music) @cname("IsMusicStreamPlaying");
// Updates buffers for music streaming
fn void updateMusicStream(RLMusic music) @cname("UpdateMusicStream");
// Stop music playing
fn void stopMusicStream(RLMusic music) @cname("StopMusicStream");
// Pause music playing
fn void pauseMusicStream(RLMusic music) @cname("PauseMusicStream");
// Resume playing paused music
fn void resumeMusicStream(RLMusic music) @cname("ResumeMusicStream");
// Seek music to a position (in seconds)
fn void seekMusicStream(RLMusic music, float position) @cname("SeekMusicStream");
// Set volume for music (1.0 is max level)
fn void setMusicVolume(RLMusic music, float volume) @cname("SetMusicVolume");
// Set pitch for a music (1.0 is base level)
fn void setMusicPitch(RLMusic music, float pitch) @cname("SetMusicPitch");
// Set pan for a music (0.5 is center)
fn void setMusicPan(RLMusic music, float pan) @cname("SetMusicPan");
// Get music time length (in seconds)
fn float getMusicTimeLength(RLMusic music) @cname("GetMusicTimeLength");
// Get current music time played (in seconds)
fn float getMusicTimePlayed(RLMusic music) @cname("GetMusicTimePlayed");

// RLAudioStream management functions
// Load audio stream (to stream raw audio pcm data)
fn RLAudioStream loadAudioStream(CUInt sampleRate, CUInt sampleSize, CUInt channels) @cname("LoadAudioStream");
// Checks if an audio stream is valid (buffers initialized)
fn bool isAudioStreamValid(RLAudioStream stream) @cname("IsAudioStreamValid");
// Unload audio stream and free memory
fn void unloadAudioStream(RLAudioStream stream) @cname("UnloadAudioStream");
// Update audio stream buffers with data
fn void updateAudioStream(RLAudioStream stream, void* data, CInt frameCount) @cname("UpdateAudioStream");
// Check if any audio stream buffers requires refill
fn bool isAudioStreamProcessed(RLAudioStream stream) @cname("IsAudioStreamProcessed");
// Play audio stream
fn void playAudioStream(RLAudioStream stream) @cname("PlayAudioStream");
// Pause audio stream
fn void pauseAudioStream(RLAudioStream stream) @cname("PauseAudioStream");
// Resume audio stream
fn void resumeAudioStream(RLAudioStream stream) @cname("ResumeAudioStream");
// Check if audio stream is playing
fn bool isAudioStreamPlaying(RLAudioStream stream) @cname("IsAudioStreamPlaying");
// Stop audio stream
fn void stopAudioStream(RLAudioStream stream) @cname("StopAudioStream");
// Set volume for audio stream (1.0 is max level)
fn void setAudioStreamVolume(RLAudioStream stream, float volume) @cname("SetAudioStreamVolume");
// Set pitch for audio stream (1.0 is base level)
fn void setAudioStreamPitch(RLAudioStream stream, float pitch) @cname("SetAudioStreamPitch");
// Set pan for audio stream (0.5 is centered)
fn void setAudioStreamPan(RLAudioStream stream, float pan) @cname("SetAudioStreamPan");
// Default size for new audio streams
fn void setAudioStreamBufferSizeDefault(CInt size) @cname("SetAudioStreamBufferSizeDefault");
// Audio thread callback to request new data
fn void setAudioStreamCallback(RLAudioStream stream, AudioCallback processor) @cname("SetAudioStreamCallback");

// Attach audio stream processor to stream, receives the samples as 'float'
fn void attachAudioStreamProcessor(RLAudioStream stream, AudioCallback processor) @cname("AttachAudioStreamProcessor");
// Detach audio stream processor from stream
fn void detachAudioStreamProcessor(RLAudioStream stream, AudioCallback processor) @cname("DetachAudioStreamProcessor");

//  Attach audio stream processor to the entire audio pipeline, receives the samples as 'float'
fn void attachAudioMixedProcessor(AudioCallback processor) @cname("AttachAudioMixedProcessor");
// Detach audio stream processor from the entire audio pipeline
fn void detachAudioMixedProcessor(AudioCallback processor) @cname("DetachAudioMixedProcessor");


//----------------------------------------------------------------------------------
// Additional Raylib.c3 Mode helper macros
//----------------------------------------------------------------------------------

/**
 * Setup canvas (framebuffer) to start drawing, then calls [block].
 * Drawing will end after [block] has finished.
 */
macro void @drawing(;@body)
{
  beginDrawing();
  defer endDrawing();
  @body();
}

/**
 * Setup 2D mode with custom camera to start 2D Mode, then calls [block].
 * Mode2D will end after [block] has finished.
 */
macro void @mode2D(RLCamera2D camera ;@body)
{
  beginMode2D(camera);
  defer endMode2D();
  @body();
}

/**
 * Setup 3D mode with custom camera to start 2D Mode, then calls [block].
 * Mode2D will end after [block] has finished.
 */
macro void @mode3D(RLCamera3D camera ;@body)
{
  beginMode3D(camera);
  defer endMode3D();
  @body();
}

/**
 * Setup texture mode to draw to render texture, then calls [block].
 * texture mode will end after [block] has finished.
 */
macro void @textureMode(RLRenderTexture2D texture ;@body)
{
  beginTextureMode(texture);
  defer endTextureMode();
  @body();
}


/**
 * Setup custom shqder mode then calls [block].
 * shader mode will end after [block] has finished.
 */
macro void @shaderMode(RLShader shader ;@body)
{
  beginShaderMode(shader);
  defer endShaderMode();
  @body();
}

/**
 * Setup blending mode, then calls [block].
 * blend mode will end after [block] has finished.
 */
macro void @blendMode(RLBlendMode mode ;@body)
{
    setBlendMode(mode); // WARNING(HM) don't forget to set blend factors before this
    beginBlendMode(mode);
    defer endBlendMode();
    @body();
}

/**
 * Setup scissor mode then calls [block].
 * scissor mode will end after [block] has finished.
 */
macro void @scissorMode(CInt x, CInt y, CInt width, CInt height ;@body)
{
  beginScissorMode(x, y, width, height);
  defer endScissorMode();
  @body();
}

/**
 * Setup stereo rendering mode, then calls [block].
 * stereo rendering mode will end after [block] has finished.
 */
macro void @vrMode(RLVrStereoConfig config ;@body)
{
  beginVrStereoMode(config);
  defer endVrStereoMode();
  @body();
}

//----------------------------------------------------------------------------------
// Enumerators Definition
//----------------------------------------------------------------------------------
// System/Window config flags
// NOTE: Every bit registers one state (use it with bit masks)
// By default all flags are set to 0

typedef RLConfigFlag = inline CUInt;

const RLConfigFlag FLAG_VSYNC_HINT         = 0x00000040;   // Set to try enabling V-Sync on GPU
const RLConfigFlag FLAG_FULLSCREEN_MODE    = 0x00000002;   // Set to run program in fullscreen
const RLConfigFlag FLAG_WINDOW_RESIZABLE   = 0x00000004;   // Set to allow resizable window
const RLConfigFlag FLAG_WINDOW_UNDECORATED = 0x00000008;   // Set to disable window decoration (frame and buttons)
const RLConfigFlag FLAG_WINDOW_HIDDEN      = 0x00000080;   // Set to hide window
const RLConfigFlag FLAG_WINDOW_MINIMIZED   = 0x00000200;   // Set to minimize window (iconify)
const RLConfigFlag FLAG_WINDOW_MAXIMIZED   = 0x00000400;   // Set to maximize window (expanded to monitor)
const RLConfigFlag FLAG_WINDOW_UNFOCUSED   = 0x00000800;   // Set to window non focused
const RLConfigFlag FLAG_WINDOW_TOPMOST     = 0x00001000;   // Set to window always on top
const RLConfigFlag FLAG_WINDOW_ALWAYS_RUN  = 0x00000100;   // Set to allow windows running while minimized
const RLConfigFlag FLAG_WINDOW_TRANSPARENT = 0x00000010;   // Set to allow transparent framebuffer
const RLConfigFlag FLAG_WINDOW_HIGHDPI     = 0x00002000;   // Set to support HighDPI
const RLConfigFlag FLAG_WINDOW_MOUSE_PASSTHROUGH = 0x00004000; // Set to support mouse passthrough, only supported when FLAG_WINDOW_UNDECORATED
const RLConfigFlag FLAG_BORDERLESS_WINDOWED_MODE = 0x00008000; // Set to run program in borderless windowed mod
const RLConfigFlag FLAG_MSAA_4X_HINT       = 0x00000020;   // Set to try enabling MSAA 4X
const RLConfigFlag FLAG_INTERLACED_HINT    = 0x00010000;   // Set to try enabling interlaced video format (for V3D)

// Keyboard keys (US keyboard layout)
// NOTE: Use GetKeyPressed() to allow redefining
// required keys for alternative layouts

typedef RLKeyboardKey = CInt;

const RLKeyboardKey KEY_NULL            = 0;        // Key: NULL; used for no key pressed
// Alphanumeric keys
const RLKeyboardKey KEY_APOSTROPHE      = 39;       // Key: '
const RLKeyboardKey KEY_COMMA           = 44;       // Key: ;
const RLKeyboardKey KEY_MINUS           = 45;       // Key: -
const RLKeyboardKey KEY_PERIOD          = 46;       // Key: .
const RLKeyboardKey KEY_SLASH           = 47;       // Key: /
const RLKeyboardKey KEY_ZERO            = 48;       // Key: 0
const RLKeyboardKey KEY_ONE             = 49;       // Key: 1
const RLKeyboardKey KEY_TWO             = 50;       // Key: 2
const RLKeyboardKey KEY_THREE           = 51;       // Key: 3
const RLKeyboardKey KEY_FOUR            = 52;       // Key: 4
const RLKeyboardKey KEY_FIVE            = 53;       // Key: 5
const RLKeyboardKey KEY_SIX             = 54;       // Key: 6
const RLKeyboardKey KEY_SEVEN           = 55;       // Key: 7
const RLKeyboardKey KEY_EIGHT           = 56;       // Key: 8
const RLKeyboardKey KEY_NINE            = 57;       // Key: 9
const RLKeyboardKey KEY_SEMICOLON       = 59;       // Key: ;
const RLKeyboardKey KEY_EQUAL           = 61;       // Key: =
const RLKeyboardKey KEY_A               = 65;       // Key: A | a
const RLKeyboardKey KEY_B               = 66;       // Key: B | b
const RLKeyboardKey KEY_C               = 67;       // Key: C | c
const RLKeyboardKey KEY_D               = 68;       // Key: D | d
const RLKeyboardKey KEY_E               = 69;       // Key: E | e
const RLKeyboardKey KEY_F               = 70;       // Key: F | f
const RLKeyboardKey KEY_G               = 71;       // Key: G | g
const RLKeyboardKey KEY_H               = 72;       // Key: H | h
const RLKeyboardKey KEY_I               = 73;       // Key: I | i
const RLKeyboardKey KEY_J               = 74;       // Key: J | j
const RLKeyboardKey KEY_K               = 75;       // Key: K | k
const RLKeyboardKey KEY_L               = 76;       // Key: L | l
const RLKeyboardKey KEY_M               = 77;       // Key: M | m
const RLKeyboardKey KEY_N               = 78;       // Key: N | n
const RLKeyboardKey KEY_O               = 79;       // Key: O | o
const RLKeyboardKey KEY_P               = 80;       // Key: P | p
const RLKeyboardKey KEY_Q               = 81;       // Key: Q | q
const RLKeyboardKey KEY_R               = 82;       // Key: R | r
const RLKeyboardKey KEY_S               = 83;       // Key: S | s
const RLKeyboardKey KEY_T               = 84;       // Key: T | t
const RLKeyboardKey KEY_U               = 85;       // Key: U | u
const RLKeyboardKey KEY_V               = 86;       // Key: V | v
const RLKeyboardKey KEY_W               = 87;       // Key: W | w
const RLKeyboardKey KEY_X               = 88;       // Key: X | x
const RLKeyboardKey KEY_Y               = 89;       // Key: Y | y
const RLKeyboardKey KEY_Z               = 90;       // Key: Z | z
const RLKeyboardKey KEY_LEFT_BRACKET    = 91;       // Key: [
const RLKeyboardKey KEY_BACKSLASH       = 92;       // Key: '\'
const RLKeyboardKey KEY_RIGHT_BRACKET   = 93;       // Key: ]
const RLKeyboardKey KEY_GRAVE           = 96;       // Key: `
// Function keys
const RLKeyboardKey KEY_SPACE           = 32;       // Key: Space
const RLKeyboardKey KEY_ESCAPE          = 256;      // Key: Esc
const RLKeyboardKey KEY_ENTER           = 257;      // Key: Enter
const RLKeyboardKey KEY_TAB             = 258;      // Key: Tab
const RLKeyboardKey KEY_BACKSPACE       = 259;      // Key: Backspace
const RLKeyboardKey KEY_INSERT          = 260;      // Key: Ins
const RLKeyboardKey KEY_DELETE          = 261;      // Key: Del
const RLKeyboardKey KEY_RIGHT           = 262;      // Key: Cursor right
const RLKeyboardKey KEY_LEFT            = 263;      // Key: Cursor left
const RLKeyboardKey KEY_DOWN            = 264;      // Key: Cursor down
const RLKeyboardKey KEY_UP              = 265;      // Key: Cursor up
const RLKeyboardKey KEY_PAGE_UP         = 266;      // Key: Page up
const RLKeyboardKey KEY_PAGE_DOWN       = 267;      // Key: Page down
const RLKeyboardKey KEY_HOME            = 268;      // Key: Home
const RLKeyboardKey KEY_END             = 269;      // Key: End
const RLKeyboardKey KEY_CAPS_LOCK       = 280;      // Key: Caps lock
const RLKeyboardKey KEY_SCROLL_LOCK     = 281;      // Key: Scroll down
const RLKeyboardKey KEY_NUM_LOCK        = 282;      // Key: Num lock
const RLKeyboardKey KEY_PRINT_SCREEN    = 283;      // Key: Print screen
const RLKeyboardKey KEY_PAUSE           = 284;      // Key: Pause
const RLKeyboardKey KEY_F1              = 290;      // Key: F1
const RLKeyboardKey KEY_F2              = 291;      // Key: F2
const RLKeyboardKey KEY_F3              = 292;      // Key: F3
const RLKeyboardKey KEY_F4              = 293;      // Key: F4
const RLKeyboardKey KEY_F5              = 294;      // Key: F5
const RLKeyboardKey KEY_F6              = 295;      // Key: F6
const RLKeyboardKey KEY_F7              = 296;      // Key: F7
const RLKeyboardKey KEY_F8              = 297;      // Key: F8
const RLKeyboardKey KEY_F9              = 298;      // Key: F9
const RLKeyboardKey KEY_F10             = 299;      // Key: F10
const RLKeyboardKey KEY_F11             = 300;      // Key: F11
const RLKeyboardKey KEY_F12             = 301;      // Key: F12
const RLKeyboardKey KEY_LEFT_SHIFT      = 340;      // Key: Shift left
const RLKeyboardKey KEY_LEFT_CONTROL    = 341;      // Key: Control left
const RLKeyboardKey KEY_LEFT_ALT        = 342;      // Key: Alt left
const RLKeyboardKey KEY_LEFT_SUPER      = 343;      // Key: Super left
const RLKeyboardKey KEY_RIGHT_SHIFT     = 344;      // Key: Shift right
const RLKeyboardKey KEY_RIGHT_CONTROL   = 345;      // Key: Control right
const RLKeyboardKey KEY_RIGHT_ALT       = 346;      // Key: Alt right
const RLKeyboardKey KEY_RIGHT_SUPER     = 347;      // Key: Super right
const RLKeyboardKey KEY_KB_MENU         = 348;      // Key: KB menu
// Keypad keys
const RLKeyboardKey KEY_KP_0            = 320;      // Key: Keypad 0
const RLKeyboardKey KEY_KP_1            = 321;      // Key: Keypad 1
const RLKeyboardKey KEY_KP_2            = 322;      // Key: Keypad 2
const RLKeyboardKey KEY_KP_3            = 323;      // Key: Keypad 3
const RLKeyboardKey KEY_KP_4            = 324;      // Key: Keypad 4
const RLKeyboardKey KEY_KP_5            = 325;      // Key: Keypad 5
const RLKeyboardKey KEY_KP_6            = 326;      // Key: Keypad 6
const RLKeyboardKey KEY_KP_7            = 327;      // Key: Keypad 7
const RLKeyboardKey KEY_KP_8            = 328;      // Key: Keypad 8
const RLKeyboardKey KEY_KP_9            = 329;      // Key: Keypad 9
const RLKeyboardKey KEY_KP_DECIMAL      = 330;      // Key: Keypad .
const RLKeyboardKey KEY_KP_DIVIDE       = 331;      // Key: Keypad /
const RLKeyboardKey KEY_KP_MULTIPLY     = 332;      // Key: Keypad *
const RLKeyboardKey KEY_KP_SUBTRACT     = 333;      // Key: Keypad -
const RLKeyboardKey KEY_KP_ADD          = 334;      // Key: Keypad +
const RLKeyboardKey KEY_KP_ENTER        = 335;      // Key: Keypad Enter
const RLKeyboardKey KEY_KP_EQUAL        = 336;      // Key: Keypad =
// Android key buttons
const RLKeyboardKey KEY_BACK            = 4;        // Key: Android back button
const RLKeyboardKey KEY_MENU            = 82;       // Key: Android menu button
const RLKeyboardKey KEY_VOLUME_UP       = 24;       // Key: Android volume up button
const RLKeyboardKey KEY_VOLUME_DOWN     = 25;       // Key: Android volume down button

typedef RLGesture = CInt;
// RLGesture
// NOTE: It could be used as flags to enable only some gestures
const RLGesture GESTURE_NONE        = 0;      // No gesture
const RLGesture GESTURE_TAP         = 1;        // Tap gesture
const RLGesture GESTURE_DOUBLETAP   = 2;        // Double tap gesture
const RLGesture GESTURE_HOLD        = 4;        // Hold gesture
const RLGesture GESTURE_DRAG        = 8;        // Drag gesture
const RLGesture GESTURE_SWIPE_RIGHT = 16;       // Swipe right gesture
const RLGesture GESTURE_SWIPE_LEFT  = 32;       // Swipe left gesture
const RLGesture GESTURE_SWIPE_UP    = 64;       // Swipe up gesture
const RLGesture GESTURE_SWIPE_DOWN  = 128;      // Swipe down gesture
const RLGesture GESTURE_PINCH_IN    = 256;      // Pinch in gesture
const RLGesture GESTURE_PINCH_OUT   = 512;      // Pinch out gesture

// NOTE(HM) right now, rlgl module is somewhat broken 
// some funcs don't seem to work and others crash the application, 
// so when using this care most be taken, not sure if should be used at all... 
module thirdparty::raylib5::rl::rlgl; // rlgl.h

import thirdparty::raylib5::rl;

typedef FramebufferAttachType = int;

const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL0 = 0;       // Framebuffer attachment type: color 0
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL1 = 1;       // Framebuffer attachment type: color 1
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL2 = 2;       // Framebuffer attachment type: color 2
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL3 = 3;       // Framebuffer attachment type: color 3
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL4 = 4;       // Framebuffer attachment type: color 4
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL5 = 5;       // Framebuffer attachment type: color 5
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL6 = 6;       // Framebuffer attachment type: color 6
const FramebufferAttachType RL_ATTACHMENT_COLOR_CHANNEL7 = 7;       // Framebuffer attachment type: color 7
const FramebufferAttachType RL_ATTACHMENT_DEPTH = 100;              // Framebuffer attachment type: depth
const FramebufferAttachType RL_ATTACHMENT_STENCIL = 200;            // Framebuffer attachment type: stencil

typedef FramebufferAttachTextureType = int;

const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_X = 0;   // Framebuffer texture attachment type: cubemap, +X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_X = 1;   // Framebuffer texture attachment type: cubemap, -X side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Y = 2;   // Framebuffer texture attachment type: cubemap, +Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Y = 3;   // Framebuffer texture attachment type: cubemap, -Y side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_POSITIVE_Z = 4;   // Framebuffer texture attachment type: cubemap, +Z side
const FramebufferAttachTextureType RL_ATTACHMENT_CUBEMAP_NEGATIVE_Z = 5;   // Framebuffer texture attachment type: cubemap, -Z side
const FramebufferAttachTextureType RL_ATTACHMENT_TEXTURE2D = 100;          // Framebuffer texture attachment type: texture2d
const FramebufferAttachTextureType RL_ATTACHMENT_RENDERBUFFER = 200;       // Framebuffer texture attachment type: renderbuffer

const RL_LINES     = 0x0001;    // GL_LINES
const RL_TRIANGLES = 0x0004;    // GL_TRIANGLES
const RL_QUADS     = 0x0007;    // GL_QUADS


//------------------------------------------------------------------------------------
// Functions Declaration - RLMatrix operations
//------------------------------------------------------------------------------------
fn void matrixMode(CInt mode) @cname("rlMatrixMode");       // Choose the current matrix to be transformed
fn void pushMatrix() @cname("rlPushMatrix");                // Push the current matrix to stack
fn void popMatrix() @cname("rlPopMatrix");                  // Pop latest inserted matrix from stack
fn void loadIdentity() @cname("rlLoadIdentity");                        // Reset current matrix to identity matrix
fn void translatef(float x, float y, float z) @cname("rlTranslatef");     // Multiply the current matrix by a translation matrix
fn void rotatef(float angle, float x, float y, float z) @cname("rlRotatef"); // Multiply the current matrix by a rotation matrix
fn void scalef(float x, float y, float z) @cname("rlScalef");         // Multiply the current matrix by a scaling matrix
fn void multMatrixf(float *matf) @cname("rlMultMatrixf");            // Multiply the current matrix by another matrix
fn void frustum(double left, double right, double bottom, double top, double znear, double zfar) @cname("rlFrustum"); // set frustum area
fn void ortho(double left, double right, double bottom, double top, double znear, double zfar) @cname("rlOrtho");    // set to ortographic projection
fn void viewport(CInt x, CInt y, CInt width, CInt height) @cname("rlViewport"); // Set the viewport area
fn void setClipPlanes(double nearPlane, double farPlane) @cname("rlSetClipPlanes");
fn double getCullDistanceNear() @cname("rlGetCullDistanceNear"); // Get cull plane distance near
fn double getCullDistanceFar()  @cname("rlGetCullDistanceFar"); // Get cull plane distance far

//------------------------------------------------------------------------------------
// Functions Declaration - Vertex level operations
//------------------------------------------------------------------------------------
fn void begin(CInt mode) @cname("rlBegin");     // Initialize drawing mode (how to organize vertex)
fn void end() @cname("rlEnd");                 // Finish vertex providing
fn void vertex2i(CInt x, CInt y) @cname("rlVertex2i");                    // Define one vertex (position) - 2 CInt
fn void vertex2f(float x, float y) @cname("rlVertex2f");                // Define one vertex (position) - 2 float
fn void vertex3f(float x, float y, float z) @cname("rlVertex3f");       // Define one vertex (position) - 3 float
fn void texCoord2f(float x, float y) @cname("rlTexCoord2f");              // Define one vertex (texture coordinate) - 2 float
fn void normal3f(float x, float y, float z) @cname("rlNormal3f");       // Define one vertex (normal) - 3 float
fn void color4ub(char r, char g, char b, char a) @cname("rlColor4ub"); // Define one vertex (color) - 4 byte
fn void color3f(float x, float y, float z) @cname("rlColor3f");        // Define one vertex (color) - 3 float
fn void color4f(float x, float y, float z, float w) @cname("rlColor4f"); // Define one vertex (color) - 4 float

macro @primitive($type;@body) {
    begin($type);
    defer end();
    @body();
}

macro @lines(;@body) {
    begin(RL_LINES);
    defer end();
    @body();
}

macro @tris(;@body) {
    begin(RL_TRIANGLES);
    defer end();
    @body();
}

macro @quads(;@body) {
    begin(RL_QUADS);
    defer end();
    @body();
}

// example
/*
rlgl::@quads() 
{
    rlgl::color4ub(0, 255, 0, 255);
    rlgl::vertex2f(1, 0);
    rlgl::color4ub(0, 255, 0, 255);
    rlgl::vertex2f(0, 0);
    rlgl::color4ub(0, 255, 0, 255);
    rlgl::vertex2f(0, 1);
    rlgl::color4ub(0, 255, 0, 255);
    rlgl::vertex2f(1, 1);
};
*/

//------------------------------------------------------------------------------------
// Functions Declaration - OpenGL style functions (common to 1.1, 3.3+, ES2)
// NOTE: This functions are used to completely abstract raylib code from OpenGL layer,
// some of them are direct wrappers over OpenGL calls, some others are custom
//------------------------------------------------------------------------------------

// Vertex buffers state
fn bool enableVertexArray(CUInt vaoId) @cname("rlEnableVertexArray");     // Enable vertex array (VAO, if supported)
fn void disableVertexArray() @cname("rlDisableVertexArray");                  // Disable vertex array (VAO, if supported)
fn void enableVertexBuffer(CUInt id) @cname("rlEnableVertexBuffer");       // Enable vertex buffer (VBO)
fn void disableVertexBuffer() @cname("rlDisableVertexBuffer");                 // Disable vertex buffer (VBO)
fn void enableVertexBufferElement(CUInt id) @cname("rlEnableVertexBufferElement"); // Enable vertex buffer element (VBO element)
fn void disableVertexBufferElement() @cname("rlDisableVertexBufferElement");          // Disable vertex buffer element (VBO element)
fn void enableVertexAttribute(CUInt index) @cname("rlEnableVertexAttribute"); // Enable vertex attribute index
fn void disableVertexAttribute(CUInt index) @cname("rlDisableVertexAttribute"); // Disable vertex attribute index
fn void enableStatePointer(RLShdrAttrbDatTyp vertexAttribType, void *buffer) @cname("rlEnableStatePointer"); // Enable attribute state pointer
fn void disableStatePointer(RLShdrAttrbDatTyp vertexAttribType) @cname("rlDisableStatePointer"); // Disable attribute state pointer

// Textures state
fn void activeTextureSlot(CInt slot) @cname("rlActiveTextureSlot");  // Select and active a texture slot
fn void enableTexture(CUInt id) @cname("rlEnableTexture");      // Enable texture
fn void disableTexture() @cname("rlDisableTexture");               // Disable texture
fn void enableTextureCubemap(CUInt id) @cname("rlEnableTextureCubemap");     // Enable texture cubemap
fn void disableTextureCubemap() @cname("rlDisableTextureCubemap");           // Disable texture cubemap
fn void textureParameters(CUInt id, CInt param, CInt value) @cname("rlTextureParameters"); // Set texture parameters (filter, wrap)
fn void cubemapParameters(CUInt id, CInt param, CInt value) @cname("rlCubemapParameters"); // Set cubemap parameters (filter, wrap)

// RLShader state
fn void enableShader(CUInt id) @cname("rlEnableShader"); // Enable shader program
fn void disableShader() @cname("rlDisableShader"); // Disable shader program

// Framebuffer state
fn void enableFramebuffer(CUInt id) @cname("rlEnableFramebuffer");        // Enable render texture (fbo)
fn void disableFramebuffer() @cname("rlDisableFramebuffer");                  // Disable render texture (fbo), return to default framebuffer
fn CUInt getActiveFramebuffer() @cname("rlGetActiveFramebuffer");        // Get the currently active render texture (fbo), 0 for default framebuffer
fn void activeDrawBuffers(CInt count) @cname("rlActiveDrawBuffers");              // Activate multiple draw color buffers
fn void blitFramebuffer(CInt srcX, CInt srcY, CInt srcWidth, CInt srcHeight, CInt dstX, CInt dstY, CInt dstWidth, CInt dstHeight, CInt bufferMask) @cname("rlBlitFramebuffer"); // Blit active framebuffer to main framebuffer
fn void bindFramebuffer(CUInt target, CUInt framebuffer) @cname("rlBindFramebuffer"); // Bind framebuffer (FBO)

// General render state
fn void enableColorBlend() @cname("rlEnableColorBlend");                    // Enable color blending
fn void disableColorBlend() @cname("rlDisableColorBlend");                   // Disable color blending
fn void enableDepthTest() @cname("rlEnableDepthTest");                     // Enable depth test
fn void disableDepthTest() @cname("rlDisableDepthTest");                    // Disable depth test
fn void enableDepthMask() @cname("rlEnableDepthMask");                     // Enable depth write
fn void disableDepthMask() @cname("rlDisableDepthMask");                    // Disable depth write
fn void enableBackfaceCulling() @cname("rlEnableBackfaceCulling");               // Enable backface culling
fn void disableBackfaceCulling() @cname("rlDisableBackfaceCulling");              // Disable backface culling
fn void colorMask(bool r, bool g, bool b, bool a) @cname("rlColorMask"); // RLColor mask control
fn void setCullFace(CInt mode) @cname("rlSetCullFace");                     // Set face culling mode
fn void enableScissorTest() @cname("rlEnableScissorTest");                   // Enable scissor test
fn void disableScissorTest() @cname("rlDisableScissorTest");                  // Disable scissor test
fn void scissor(CInt x, CInt y, CInt width, CInt height) @cname("rlScissor"); // Scissor test
fn void enablePointMode() @cname("rlEnablePointMode");                     // Enable point mode
fn void disablePointMode() @cname("rlDisablePointMode");                    // Disable point mode
fn void setPointSize(float size) @cname("rlSetPointSize");                  // Set the point drawing size
fn float getPointSize() @cname("rlGetPointSize");                       // Get the point drawing size
fn void enableWireMode() @cname("rlEnableWireMode");                      // Enable wire mode
fn void disableWireMode() @cname("rlDisableWireMode");                     // Disable wire mode
fn void setLineWidth(float width) @cname("rlSetLineWidth");                 // Set the line drawing width
fn float getLineWidth() @cname("rlGetLineWidth");                       // Get the line drawing width
fn void enableSmoothLines() @cname("rlEnableSmoothLines");                   // Enable line aliasing
fn void disableSmoothLines() @cname("rlDisableSmoothLines");                  // Disable line aliasing
fn void enableStereoRender() @cname("rlEnableStereoRender");                  // Enable stereo rendering
fn void disableStereoRender() @cname("rlDisableStereoRender");                 // Disable stereo rendering
fn bool isStereoRenderEnabled() @cname("rlIsStereoRenderEnabled");               // Check if stereo render is enabled

fn void clearColor(char r, char g, char b, char a) @cname("rlClearColor"); // Clear color buffer with color
fn void clearScreenBuffers() @cname("rlClearScreenBuffers");                  // Clear used screen buffers (color and depth)
fn void checkErrors() @cname("rlCheckErrors");                         // Check and log OpenGL error codes
fn void setBlendMode(RLBlendMode mode) @cname("rlSetBlendMode");                    // Set blending mode
fn void setBlendFactors(CInt glSrcFactor, CInt glDstFactor, CInt glEquation) @cname("rlSetBlendFactors"); // Set blending mode factor and equation (using OpenGL factors)
fn void setBlendFactorsSeparate(CInt glSrcRGB, CInt glDstRGB, CInt glSrcAlpha, CInt glDstAlpha, CInt glEqRGB, CInt glEqAlpha) @cname("rlSetBlendFactorsSeparate"); // Set blending mode factors and equations separately (using OpenGL factors)


//------------------------------------------------------------------------------------
// Functions Declaration - rlgl functionality
//------------------------------------------------------------------------------------
// rlgl initialization functions
fn void init(CInt width, CInt height) @cname("rlglInit");             // Initialize rlgl (buffers, shaders, textures, states)
fn void close() @cname("rlglClose");                             // De-initialize rlgl (buffers, shaders, textures)
fn void loadExtensions(void *loader) @cname("rlLoadExtensions");              // Load OpenGL extensions (loader function required)
fn void *getProcAddress(ZString procName) @cname("rlGetProcAddress");     // Get OpenGL procedure address
fn CInt getVersion() @cname("rlGetVersion");                           // Get current OpenGL version
fn void setFramebufferWidth(CInt width) @cname("rlSetFramebufferWidth");            // Set current framebuffer width
fn CInt getFramebufferWidth() @cname("rlGetFramebufferWidth");                  // Get default framebuffer width
fn void setFramebufferHeight(CInt height) @cname("rlSetFramebufferHeight");          // Set current framebuffer height
fn CInt getFramebufferHeight() @cname("rlGetFramebufferHeight");                 // Get default framebuffer height

fn CUInt getTextureIdDefault() @cname("rlGetTextureIdDefault");         // Get default texture id
fn CUInt getShaderIdDefault() @cname("rlGetShaderIdDefault");          // Get default shader id
fn CInt *getShaderLocsDefault() @cname("");                // Get default shader locations

// Render batch management
// NOTE: rlgl provides a default render batch to behave like OpenGL 1.1 immediate mode
// but this render batch API is exposed in case of custom batches are required
fn void setTexture(CUInt id) @cname("rlSetTexture");               // Set current texture for render batch and check buffers limits

module thirdparty::raylib5::rl::rlcam;

import thirdparty::raylib5::rl;
// rcamera.h
// Moves the camera in its forward direction
fn void moveForward(RLCamera *camera, float distance, bool moveInWorldPlane) @cname("CameraMoveForward");
// Moves the camera target in its current right direction
fn void moveRight(RLCamera *camera, float distance, bool moveInWorldPlane) @cname("CameraMoveRight");
// Moves the camera position closer/farther to/from the camera target
fn void moveToTarget(RLCamera *camera, float delta) @cname("CameraMoveToTarget");
// Moves the camera in its up direction
fn void moveUp(RLCamera *camera, float distance) @cname("CameraMoveUp");
// Rotates the camera around its right vector, pitch is "looking up and down"
//  - lockView prevents camera overrotation (aka "somersaults")
//  - rotateAroundTarget defines if rotation is around target or around its position
//  - rotateUp rotates the up direction as well (typically only usefull in CAMERA_FREE)
// NOTE: angle must be provided in radians
fn void pitch(RLCamera *camera, float angle, bool lockView, bool rotateAroundTarget, bool rotateUp) @cname("CameraPitch");
// Rotates the camera around its forward vector
// Roll is "turning your head sideways to the left or right"
// Note: angle must be provided in radians
fn void roll(RLCamera *camera, float angle) @cname("CameraRoll");
// Rotates the camera around its up vector
// Yaw is "looking left and right"
// If rotateAroundTarget is false, the camera rotates around its position
// Note: angle must be provided in radians
fn void yaw(RLCamera *camera, float angle, bool rotateAroundTarget) @cname("CameraYaw");
