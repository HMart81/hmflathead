/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/

// NOTE(HM) Most vector math on this module should probably be deprecated...
// RLVector2 now uses C3 built in simd vector math for example...
module thirdparty::raylib5::rmath;

import thirdparty::raylib5::rl;

// region raymath
fn float clamp(float value, float min, float max) @cname("Clamp");
// Calculate linear interpolation between two floats
fn float lerp(float start, float end, float amount) @cname("Lerp");
// Normalize input value within input range
fn float normalize(float value, float start, float end) @cname("Lerp");
// Remap input value within input range to output range
fn float remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd) @cname("Remap");
// Wrap input value from min to max
fn float wrap(float value, float min, float max) @cname("Wrap");
// Check whether two given floats are almost equal
fn int floatsAreEqual(float x, float y) @cname("FloatEquals");

//----------------------------------------------------------------------------------
// region Module Functions Definition - RLVector2 math
//----------------------------------------------------------------------------------

const VECTOR2_ZERO = (RLVector2){ 0.0f, 0.0f };
const VECTOR2_ONE  = (RLVector2){ 1.0f, 1.0f };

// raymath.h
// Add two vectors (v1 + v2)
fn RLVector2 vector2Add(RLVector2 v1, RLVector2 v2) @deprecated @cname("Vector2Add");
// Add vector and float value
fn RLVector2 vector2AddValue(RLVector2 v, float add) @cname("Vector2AddValue");
// Calculate the signed angle from v1 to v2, relative to the origin (0, 0)
// NOTE: Coordinate system convention: positive X right, positive Y down,
// positive angles appear clockwise, and negative angles appear counterclockwise
fn float vector2Angle(RLVector2 v1, RLVector2 v2) @cname("Vector2Angle");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn RLVector2 vector2Clamp(RLVector2 v, RLVector2 min, RLVector2 max) @cname("Vector2Clamp");
// Clamp the magnitude of the vector between two min and max values
fn RLVector2 vector2ClampValue(RLVector2 v, float min, float max) @cname("Vector2ClampValue");
// Calculate two vectors cross product
fn float vector2CrossProduct(RLVector2 v1, RLVector2 v2) @cname("Vector2CrossProduct");
// Calculate distance between two vectors
fn float vector2Distance(RLVector2 v1, RLVector2 v2) @cname("Vector2Distance");
// Calculate square distance between two vectors
fn float vector2DistanceSqr(RLVector2 v1, RLVector2 v2) @cname("Vector2DistanceSqr");
// Divide vector by vector
fn RLVector2 vector2Divide(RLVector2 v1, RLVector2 v2) @deprecated @cname("Vector2Divide");
// Calculate two vectors dot product
fn float vector2DotProduct(RLVector2 v1, RLVector2 v2) @cname("Vector2DotProduct");
// Check whether two given vectors are almost equal
fn int vector2Equals(RLVector2 p, RLVector2 q) @deprecated @cname("Vector2Equals");
// Invert the given vector
fn RLVector2 vector2Invert(RLVector2 v) @cname("Vector2Invert");
// Calculate vector length
fn float vector2Length(RLVector2 v) @cname("Vector2Length");
// Calculate vector square length
fn float vector2LengthSqr(RLVector2 v) @cname("Vector2LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector2 vector2Lerp(RLVector2 v1, RLVector2 v2, float amount) @cname("Vector2Lerp");
// Calculate angle defined by a two vectors line
// NOTE: Parameters need to be normalized
// Current implementation should be aligned with glm::angle
fn float vector2LineAngle(RLVector2 start, RLVector2 end) @cname("Vector2LineAngle");
// Get max value for each pair of components
fn RLVector2 vector2Max(RLVector2 v1, RLVector2 v2) @cname("Vector2Max");
// Get min value for each pair of components
fn RLVector2 vector2Min(RLVector2 v1, RLVector2 v2) @cname("Vector2Min");
// Move Vector towards target
fn RLVector2 vector2MoveTowards(RLVector2 v, RLVector2 target, float maxDistance) @cname("Vector2MoveTowards");
// Multiply vector by vector
fn RLVector2 vector2Multiply(RLVector2 v1, RLVector2 v2) @deprecated @cname("Vector2Multiply");
// Negate vector
fn RLVector2 vector2Negate(RLVector2 v) @cname("Vector2Negate");
// Normalize provided vector
fn RLVector2 vector2Normalize(RLVector2 v) @cname("Vector2Normalize");
// Vector with components value 1.0f
fn RLVector2 vector2One() @cname("Vector2One");
// Calculate reflected vector to normal
fn RLVector2 vector2Reflect(RLVector2 v, RLVector2 normal) @cname("Vector2Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn RLVector2 vector2Refract(RLVector2 v, RLVector2 n, float r) @cname("Vector2Refract");
// Rotate vector by angle
fn RLVector2 vector2Rotate(RLVector2 v, float angle) @cname("Vector2Rotate");
// Scale vector (multiply by value)
fn RLVector2 vector2Scale(RLVector2 v, float scale) @cname("Vector2Scale");
// Subtract two vectors (v1 - v2)
fn RLVector2 vector2Subtract(RLVector2 v1, RLVector2 v2) @deprecated @cname("Vector2Subtract");
// Subtract vector by float value
fn RLVector2 vector2SubtractValue(RLVector2 v, float sub) @cname("Vector2SubtractValue");
// Transforms a RLVector2 by a given RLMatrix
fn RLVector2 vector2Transform(RLVector2 v, RLMatrix mat) @cname("Vector2Transform");
// Vector with components value 0.0f
fn RLVector2 vector2Zero() @cname("Vector2Zero");

// Add two vectors
fn RLVector3 vector3Add(RLVector3 v1, RLVector3 v2) @deprecated @cname("Vector3Add");
// Add vector and float value
fn RLVector3 vector3AddValue(RLVector3 v, float add) @cname("Vector3AddValue");
// Calculate angle between two vectors
fn float vector3Angle(RLVector3 v1, RLVector3 v2) @cname("Vector3Angle");
// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
// NOTE: Assumes P is on the plane of the triangle
fn RLVector3 vector3Barycenter(RLVector3 p, RLVector3 a, RLVector3 b, RLVector3 c) @cname("Vector3Barycenter");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn RLVector3 vector3Clamp(RLVector3 v, RLVector3 min, RLVector3 max) @cname("Vector3Clamp");
// Clamp the magnitude of the vector between two values
fn RLVector3 vector3ClampValue(RLVector3 v, float min, float max) @cname("Vector3ClampValue");
// Calculate two vectors cross product
fn RLVector3 vector3CrossProduct(RLVector3 v1, RLVector3 v2) @cname("Vector3CrossProduct");
// Calculate cubic hermite interpolation between two vectors and their tangents
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn RLVector3 vector3CubicHermite(RLVector3 v1, RLVector3 tangent1, RLVector3 v2, RLVector3 tangent2, float amount) @cname("Vector3CubicHermite");
// Calculate square distance between two vectors
fn float vector3Distance(RLVector3 v1, RLVector3 v2) @cname("Vector3Distance");
// Calculate square distance between two vectors
fn float vector3DistanceSqr(RLVector3 v1, RLVector3 v2) @cname("Vector3DistanceSqr");
// Divide vector by vector
fn RLVector3 vector3Divide(RLVector3 v1, RLVector3 v2) @cname("Vector3Divide");
// Calculate two vectors dot product
fn float vector3DotProduct(RLVector3 v1, RLVector3 v2) @cname("Vector3DotProduct");
// Check whether two given vectors are almost equal
fn int vector3Equals(RLVector3 p, RLVector3 q) @deprecated @cname("Vector3Equals");
// Invert the given vector
fn RLVector3 vector3Invert(RLVector3 v) @cname("Vector3Invert");
// Calculate vector length
fn float vector3Length(RLVector3 v) @cname("Vector3Length");
// Calculate vector square length
fn float vector3LengthSqr(RLVector3 v) @cname("Vector3LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector3 vector3Lerp(RLVector3 v1, RLVector3 v2, float amount) @cname("Vector3Lerp");
// Get max value for each pair of components
fn RLVector3 vector3Max(RLVector3 v1, RLVector3 v2) @cname("Vector3Max");
// Get min value for each pair of components
fn RLVector3 vector3Min(RLVector3 v1, RLVector3 v2) @cname("Vector3Min");
// Move Vector towards target
fn RLVector3 vector3MoveTowards(RLVector3 v, RLVector3 target, float maxDistance) @cname("Vector3MoveTowards");
// Multiply vector by vector
fn RLVector3 vector3Multiply(RLVector3 v1, RLVector3 v2) @deprecated @cname("Vector3Multiply");
// Negate provided vector (invert direction)
fn RLVector3 vector3Negate(RLVector3 v) @cname("Vector3Negate");
// Normalize provided vector
fn RLVector3 vector3Normalize(RLVector3 v) @cname("Vector3Normalize");
// Vector with components value 1.0f
fn RLVector3 vector3One() @cname("Vector3One");
// Orthonormalize provided vectors
// Makes vectors normalized and orthogonal to each other
// Gram-Schmidt function implementation
fn void vector3OrthoNormalize(RLVector3 *v1, RLVector3 *v2) @cname("Vector3OrthoNormalize");
// Calculate one vector perpendicular vector
fn RLVector3 vector3Perpendicular(RLVector3 v) @cname("Vector3Perpendicular");
//Calculate the projection of the vector v1 on to v2
fn RLVector3 vector3Project(RLVector3 v1, RLVector3 v2) @cname("Vector3Project");
// Calculate reflected vector to normal
fn RLVector3 vector3Reflect(RLVector3 v, RLVector3 normal) @cname("Vector3Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn RLVector3 vector3Refract(RLVector3 v, RLVector3 n, float r) @cname("Vector3Refract");
//Calculate the rejection of the vector v1 on to v2
fn RLVector3 vector3Reject(RLVector3 v1, RLVector3 v2) @cname("Vector3Reject");
// Rotates a vector around an axis
fn RLVector3 vector3RotateByAxisAngle(RLVector3 v, RLVector3 axis, float angle) @cname("Vector3RotateByAxisAngle");
// RLTransform a vector by quaternion rotation
fn RLVector3 vector3RotateByQuaternion(RLVector3 v, RLQuaternion q) @cname("Vector3RotateByQuaternion");
// Multiply vector by scalar
fn RLVector3 vector3Scale(RLVector3 v, float scalar) @cname("Vector3Scale");
// Subtract two vectors
fn RLVector3 vector3Subtract(RLVector3 v1, RLVector3 v2) @deprecated @cname("Vector3Subtract");
// Subtract vector by float value
fn RLVector3 vector3SubtractValue(RLVector3 v, float sub) @cname("Vector3SubtractValue");

// Get RLVector3 as float array
// fn float3 vector3ToFloatV(RLVector3 v) @cname("Vector3ToFloatV"); // ? float3 == float[<3>]

// Transforms a RLVector3 by a given RLMatrix
fn RLVector3 vector3Transform(RLVector3 v, RLMatrix mat) @cname("Vector3Transform");
// Projects a RLVector3 from screen space into object space
// NOTE: We are avoiding calling other raymath functions despite available
fn RLVector3 vector3Unproject(RLVector3 source, RLMatrix projection, RLMatrix view) @cname("Vector3Unproject");
// Vector with components value 0.0f
fn RLVector3 vector3Zero() @cname("Vector3Zero");

fn RLVector4 vector4Add(RLVector4 v1, RLVector4 v2) @cname("Vector4Add");
fn RLVector4 vector4AddValue(RLVector4 v, float add) @cname("Vector4AddValue");
// Calculate distance between two vectors
fn float vector4Distance(RLVector4 v1, RLVector4 v2) @cname("Vector4Distance");
// Calculate square distance between two vectors
fn float vector4DistanceSqr(RLVector4 v1, RLVector4 v2) @cname("Vector4DistanceSqr");
// Divide vector by vector
fn RLVector4 vector4Divide(RLVector4 v1, RLVector4 v2) @cname("Vector4Divide");
fn float vector4DotProduct(RLVector4 v1, RLVector4 v2) @cname("Vector4DotProduct");
// Check whether two given vectors are almost equal
fn int vector4Equals(RLVector4 p, RLVector4 q) @cname("Vector4Equals");
// Invert the given vector
fn RLVector4 vector4Invert(RLVector4 v) @cname("Vector4Invert");
fn float vector4Length(RLVector4 v) @cname("Vector4Length");
fn float vector4LengthSqr(RLVector4 v) @cname("Vector4LengthSqr");
// Calculate linear interpolation between two vectors
fn RLVector4 vector4Lerp(RLVector4 v1, RLVector4 v2, float amount) @cname("Vector4Lerp");
// Get max value for each pair of components
fn RLVector4 vector4Max(RLVector4 v1, RLVector4 v2) @cname("Vector4Max");
// Get min value for each pair of components
fn RLVector4 vector4Min(RLVector4 v1, RLVector4 v2) @cname("Vector4Min");
// Move Vector towards target
fn RLVector4 vector4MoveTowards(RLVector4 v, RLVector4 target, float maxDistance) @cname("Vector4MoveTowards");
// Multiply vector by vector
fn RLVector4 vector4Multiply(RLVector4 v1, RLVector4 v2) @cname("Vector4Multiply");
// Negate vector
fn RLVector4 vector4Negate(RLVector4 v) @cname("Vector4Negate");
// Normalize provided vector
fn RLVector4 vector4Normalize(RLVector4 v) @cname("Vector4Normalize");
fn RLVector4 vector4One() @cname("Vector4One");
fn RLVector4 vector4Scale(RLVector4 v, float scale) @cname("Vector4Scale");
fn RLVector4 vector4Subtract(RLVector4 v1, RLVector4 v2) @cname("Vector4Subtract");
fn RLVector4 vector4SubtractValue(RLVector4 v, float add) @cname("Vector4SubtractValue");
fn RLVector4 vector4Zero() @cname("Vector4Zero");

// Add two matrices
fn RLMatrix matrixAdd(RLMatrix left, RLMatrix right) @cname("MatrixAdd");
// Decompose a transformation matrix into its rotational, translational and scaling components
fn void matrixDecompose(RLMatrix mat, RLVector3 *translation, RLQuaternion *rotation, RLVector3 *scale) @cname("MatrixDecompose");
// Compute matrix determinant
fn float matrixDeterminant(RLMatrix mat) @cname("MatrixDeterminant");
// Get perspective projection matrix
fn RLMatrix matrixFrustum(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixFrustum");
// Get identity matrix
fn RLMatrix matrixIdentity() @cname("MatrixIdentity");
// Invert provided matrix
fn  RLMatrix matrixInvert(RLMatrix mat) @cname("MatrixInvert");
// Get camera look-at matrix (view matrix)
fn RLMatrix matrixLookAt(RLVector3 eye, RLVector3 target, RLVector3 up) @cname("MatrixLookAt");
// Get two matrix multiplication
// NOTE: When multiplying matrices... the order matters!
fn RLMatrix matrixMultiply(RLMatrix left, RLMatrix right) @cname("MatrixMultiply");
// Get orthographic projection matrix
fn RLMatrix matrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixOrtho");
// Get perspective projection matrix
// NOTE: Fovy angle must be provided in radians
fn RLMatrix matrixPerspective(double fovY, double aspect, double nearPlane, double farPlane) @cname("MatrixPerspective");
// Create rotation matrix from axis and angle
// NOTE: Angle should be provided in radians
fn RLMatrix matrixRotate(RLVector3 axis, float angle) @cname("MatrixRotate");
// Get x-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrixRotateX(float angle) @cname("MatrixRotateX");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrixRotateXYZ(RLVector3 angle) @cname("MatrixRotateXYZ");
// Get y-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrixRotateY(float angle) @cname("MatrixRotateY");
// Get z-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrixRotateZ(float angle) @cname("MatrixRotateZ");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn RLMatrix matrixRotateZYX(RLVector3 angle) @cname("MatrixRotateZYX");
// Get scaling matrix
fn RLMatrix matrixScale(float x, float y, float z) @cname("MatrixScale");
// Subtract two matrices (left - right)
fn RLMatrix matrixSubtract(RLMatrix left, RLMatrix right) @cname("MatrixSubtract");

// Get float array of matrix data
// fn float16 matrixToFloatV(RLMatrix mat) @cname("MatrixToFloatV"); // float16 == float[<16>] ??

// Get the trace of the matrix (sum of the values along the diagonal)
fn float matrixTrace(RLMatrix mat) @cname("MatrixTrace");
// Get translation matrix
fn  RLMatrix matrixTranslate(float x, float y, float z) @cname("MatrixTranslate");
// Transposes provided matrix
fn RLMatrix matrixTranspose(RLMatrix mat) @cname("MatrixTranspose");

// Add two quaternions
fn RLQuaternion quaternionAdd(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionAdd");
// Add quaternion and float value
fn RLQuaternion quaternionAddValue(RLQuaternion q, float add) @cname("QuaternionAddValue");
// Calculate quaternion cubic spline interpolation using Cubic Hermite Spline algorithm
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn RLQuaternion quaternionCubicHermiteSpline(RLQuaternion q1, RLQuaternion outTangent1, RLQuaternion q2, RLQuaternion inTangent2, float t) @cname("QuaternionCubicHermiteSpline");
// Divide two quaternions
fn RLQuaternion quaternionDivide(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionDivide");
// Check whether two given quaternions are almost equal
fn int quaternionEquals(RLQuaternion p, RLQuaternion q) @cname("QuaternionEquals");
// Get rotation quaternion for an angle and axis
// NOTE: Angle must be provided in radians
fn RLQuaternion quaternionFromAxisAngle(RLVector3 axis, float angle) @cname("QuaternionFromAxisAngle");
// Get the quaternion equivalent to Euler angles
// NOTE: Rotation order is ZYX
fn RLQuaternion quaternionFromEuler(float pitch, float yaw, float roll) @cname("QuaternionFromEuler");
// Get a quaternion for a given rotation matrix
fn RLQuaternion quaternionFromMatrix(RLMatrix mat) @cname("QuaternionFromMatrix");
// Calculate quaternion based on the rotation from one vector to another
fn RLQuaternion quaternionFromVector3ToVector3(RLVector3 from, RLVector3 to) @cname("QuaternionFromVector3ToVector3");
// Get identity quaternion
fn RLQuaternion quaternionIdentity() @cname("QuaternionIdentity");
// Invert provided quaternion
fn RLQuaternion quaternionInvert(RLQuaternion q) @cname("QuaternionInvert");
// Computes the length of a quaternion
fn float quaternionLength(RLQuaternion q) @cname("QuaternionLength");
// Calculate linear interpolation between two quaternions
fn RLQuaternion quaternionLerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionLerp");
// Calculate two quaternion multiplication
fn RLQuaternion quaternionMultiply(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionMultiply");
// Calculate slerp-optimized interpolation between two quaternions
fn RLQuaternion quaternionNlerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionNlerp");
// Normalize provided quaternion
fn RLQuaternion quaternionNormalize(RLQuaternion q) @cname("QuaternionNormalize");
// Scale quaternion by float value
fn RLQuaternion quaternionScale(RLQuaternion q, float mul) @cname("QuaternionScale");
// Calculates spherical linear interpolation between two quaternions
fn RLQuaternion quaternionSlerp(RLQuaternion q1, RLQuaternion q2, float amount) @cname("QuaternionSlerp");
// Subtract two quaternions
fn RLQuaternion quaternionSubtract(RLQuaternion q1, RLQuaternion q2) @cname("QuaternionSubtract");
// Subtract quaternion and float value
fn RLQuaternion quaternionSubtractValue(RLQuaternion q, float sub) @cname("QuaternionSubtractValue");
// Get the rotation angle and axis for a given quaternion
fn void quaternionToAxisAngle(RLQuaternion q, RLVector3 *outAxis, float *outAngle) @cname("QuaternionToAxisAngle");
// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
// NOTE: Angles are returned in a RLVector3 struct in radians
fn RLVector3 quaternionToEuler(RLQuaternion q) @cname("QuaternionToEuler");
// Get a matrix for a given quaternion
fn RLMatrix quaternionToMatrix(RLQuaternion q) @cname("QuaternionToMatrix");
// RLTransform a quaternion given a transformation matrix
fn RLQuaternion quaternionTransform(RLQuaternion q, RLMatrix mat) @cname("QuaternionTransform");
// end_region raymath
