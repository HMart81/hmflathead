/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/

// NOTE(HM) Most vector math on this module should probably be deprecated...
// Vector2 now uses C3 built in simd vector math for example...
module thirdparty::raylib5::rmath;

import thirdparty::raylib5::rl;

// region raymath
fn float clamp(float value, float min, float max) @cname("Clamp");
// Calculate linear interpolation between two floats
fn float lerp(float start, float end, float amount) @cname("Lerp");
// Normalize input value within input range
fn float normalize(float value, float start, float end) @cname("Lerp");
// Remap input value within input range to output range
fn float remap(float value, float inputStart, float inputEnd, float outputStart, float outputEnd) @cname("Remap");
// Wrap input value from min to max
fn float wrap(float value, float min, float max) @cname("Wrap");
// Check whether two given floats are almost equal
fn int floatsAreEqual(float x, float y) @cname("FloatEquals");

//----------------------------------------------------------------------------------
// region Module Functions Definition - Vector2 math
//----------------------------------------------------------------------------------

const VECTOR2_ZERO = (Vector2){ 0.0f, 0.0f };
const VECTOR2_ONE  = (Vector2){ 1.0f, 1.0f };

// raymath.h
// Add two vectors (v1 + v2)
fn Vector2 vector2Add(Vector2 v1, Vector2 v2) @deprecated @cname("Vector2Add");
// Add vector and float value
fn Vector2 vector2AddValue(Vector2 v, float add) @cname("Vector2AddValue");
// Calculate the signed angle from v1 to v2, relative to the origin (0, 0)
// NOTE: Coordinate system convention: positive X right, positive Y down,
// positive angles appear clockwise, and negative angles appear counterclockwise
fn float vector2Angle(Vector2 v1, Vector2 v2) @cname("Vector2Angle");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn Vector2 vector2Clamp(Vector2 v, Vector2 min, Vector2 max) @cname("Vector2Clamp");
// Clamp the magnitude of the vector between two min and max values
fn Vector2 vector2ClampValue(Vector2 v, float min, float max) @cname("Vector2ClampValue");
// Calculate two vectors cross product
fn float vector2CrossProduct(Vector2 v1, Vector2 v2) @cname("Vector2CrossProduct");
// Calculate distance between two vectors
fn float vector2Distance(Vector2 v1, Vector2 v2) @cname("Vector2Distance");
// Calculate square distance between two vectors
fn float vector2DistanceSqr(Vector2 v1, Vector2 v2) @cname("Vector2DistanceSqr");
// Divide vector by vector
fn Vector2 vector2Divide(Vector2 v1, Vector2 v2) @deprecated @cname("Vector2Divide");
// Calculate two vectors dot product
fn float vector2DotProduct(Vector2 v1, Vector2 v2) @cname("Vector2DotProduct");
// Check whether two given vectors are almost equal
fn int vector2Equals(Vector2 p, Vector2 q) @deprecated @cname("Vector2Equals");
// Invert the given vector
fn Vector2 vector2Invert(Vector2 v) @cname("Vector2Invert");
// Calculate vector length
fn float vector2Length(Vector2 v) @cname("Vector2Length");
// Calculate vector square length
fn float vector2LengthSqr(Vector2 v) @cname("Vector2LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector2 vector2Lerp(Vector2 v1, Vector2 v2, float amount) @cname("Vector2Lerp");
// Calculate angle defined by a two vectors line
// NOTE: Parameters need to be normalized
// Current implementation should be aligned with glm::angle
fn float vector2LineAngle(Vector2 start, Vector2 end) @cname("Vector2LineAngle");
// Get max value for each pair of components
fn Vector2 vector2Max(Vector2 v1, Vector2 v2) @cname("Vector2Max");
// Get min value for each pair of components
fn Vector2 vector2Min(Vector2 v1, Vector2 v2) @cname("Vector2Min");
// Move Vector towards target
fn Vector2 vector2MoveTowards(Vector2 v, Vector2 target, float maxDistance) @cname("Vector2MoveTowards");
// Multiply vector by vector
fn Vector2 vector2Multiply(Vector2 v1, Vector2 v2) @deprecated @cname("Vector2Multiply");
// Negate vector
fn Vector2 vector2Negate(Vector2 v) @cname("Vector2Negate");
// Normalize provided vector
fn Vector2 vector2Normalize(Vector2 v) @cname("Vector2Normalize");
// Vector with components value 1.0f
fn Vector2 vector2One() @cname("Vector2One");
// Calculate reflected vector to normal
fn Vector2 vector2Reflect(Vector2 v, Vector2 normal) @cname("Vector2Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn Vector2 vector2Refract(Vector2 v, Vector2 n, float r) @cname("Vector2Refract");
// Rotate vector by angle
fn Vector2 vector2Rotate(Vector2 v, float angle) @cname("Vector2Rotate");
// Scale vector (multiply by value)
fn Vector2 vector2Scale(Vector2 v, float scale) @cname("Vector2Scale");
// Subtract two vectors (v1 - v2)
fn Vector2 vector2Subtract(Vector2 v1, Vector2 v2) @deprecated @cname("Vector2Subtract");
// Subtract vector by float value
fn Vector2 vector2SubtractValue(Vector2 v, float sub) @cname("Vector2SubtractValue");
// Transforms a Vector2 by a given Matrix
fn Vector2 vector2Transform(Vector2 v, Matrix mat) @cname("Vector2Transform");
// Vector with components value 0.0f
fn Vector2 vector2Zero() @cname("Vector2Zero");

// Add two vectors
fn Vector3 vector3Add(Vector3 v1, Vector3 v2) @deprecated @cname("Vector3Add");
// Add vector and float value
fn Vector3 vector3AddValue(Vector3 v, float add) @cname("Vector3AddValue");
// Calculate angle between two vectors
fn float vector3Angle(Vector3 v1, Vector3 v2) @cname("Vector3Angle");
// Compute barycenter coordinates (u, v, w) for point p with respect to triangle (a, b, c)
// NOTE: Assumes P is on the plane of the triangle
fn Vector3 vector3Barycenter(Vector3 p, Vector3 a, Vector3 b, Vector3 c) @cname("Vector3Barycenter");
// Clamp the components of the vector between
// min and max values specified by the given vectors
fn Vector3 vector3Clamp(Vector3 v, Vector3 min, Vector3 max) @cname("Vector3Clamp");
// Clamp the magnitude of the vector between two values
fn Vector3 vector3ClampValue(Vector3 v, float min, float max) @cname("Vector3ClampValue");
// Calculate two vectors cross product
fn Vector3 vector3CrossProduct(Vector3 v1, Vector3 v2) @cname("Vector3CrossProduct");
// Calculate cubic hermite interpolation between two vectors and their tangents
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn Vector3 vector3CubicHermite(Vector3 v1, Vector3 tangent1, Vector3 v2, Vector3 tangent2, float amount) @cname("Vector3CubicHermite");
// Calculate square distance between two vectors
fn float vector3Distance(Vector3 v1, Vector3 v2) @cname("Vector3Distance");
// Calculate square distance between two vectors
fn float vector3DistanceSqr(Vector3 v1, Vector3 v2) @cname("Vector3DistanceSqr");
// Divide vector by vector
fn Vector3 vector3Divide(Vector3 v1, Vector3 v2) @cname("Vector3Divide");
// Calculate two vectors dot product
fn float vector3DotProduct(Vector3 v1, Vector3 v2) @cname("Vector3DotProduct");
// Check whether two given vectors are almost equal
fn int vector3Equals(Vector3 p, Vector3 q) @deprecated @cname("Vector3Equals");
// Invert the given vector
fn Vector3 vector3Invert(Vector3 v) @cname("Vector3Invert");
// Calculate vector length
fn float vector3Length(Vector3 v) @cname("Vector3Length");
// Calculate vector square length
fn float vector3LengthSqr(Vector3 v) @cname("Vector3LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector3 vector3Lerp(Vector3 v1, Vector3 v2, float amount) @cname("Vector3Lerp");
// Get max value for each pair of components
fn Vector3 vector3Max(Vector3 v1, Vector3 v2) @cname("Vector3Max");
// Get min value for each pair of components
fn Vector3 vector3Min(Vector3 v1, Vector3 v2) @cname("Vector3Min");
// Move Vector towards target
fn Vector3 vector3MoveTowards(Vector3 v, Vector3 target, float maxDistance) @cname("Vector3MoveTowards");
// Multiply vector by vector
fn Vector3 vector3Multiply(Vector3 v1, Vector3 v2) @deprecated @cname("Vector3Multiply");
// Negate provided vector (invert direction)
fn Vector3 vector3Negate(Vector3 v) @cname("Vector3Negate");
// Normalize provided vector
fn Vector3 vector3Normalize(Vector3 v) @cname("Vector3Normalize");
// Vector with components value 1.0f
fn Vector3 vector3One() @cname("Vector3One");
// Orthonormalize provided vectors
// Makes vectors normalized and orthogonal to each other
// Gram-Schmidt function implementation
fn void vector3OrthoNormalize(Vector3 *v1, Vector3 *v2) @cname("Vector3OrthoNormalize");
// Calculate one vector perpendicular vector
fn Vector3 vector3Perpendicular(Vector3 v) @cname("Vector3Perpendicular");
//Calculate the projection of the vector v1 on to v2
fn Vector3 vector3Project(Vector3 v1, Vector3 v2) @cname("Vector3Project");
// Calculate reflected vector to normal
fn Vector3 vector3Reflect(Vector3 v, Vector3 normal) @cname("Vector3Reflect");
// Compute the direction of a refracted ray
// v: normalized direction of the incoming ray
// n: normalized normal vector of the interface of two optical media
// r: ratio of the refractive index of the medium from where the ray comes
//    to the refractive index of the medium on the other side of the surface
fn Vector3 vector3Refract(Vector3 v, Vector3 n, float r) @cname("Vector3Refract");
//Calculate the rejection of the vector v1 on to v2
fn Vector3 vector3Reject(Vector3 v1, Vector3 v2) @cname("Vector3Reject");
// Rotates a vector around an axis
fn Vector3 vector3RotateByAxisAngle(Vector3 v, Vector3 axis, float angle) @cname("Vector3RotateByAxisAngle");
// Transform a vector by quaternion rotation
fn Vector3 vector3RotateByQuaternion(Vector3 v, Quaternion q) @cname("Vector3RotateByQuaternion");
// Multiply vector by scalar
fn Vector3 vector3Scale(Vector3 v, float scalar) @cname("Vector3Scale");
// Subtract two vectors
fn Vector3 vector3Subtract(Vector3 v1, Vector3 v2) @deprecated @cname("Vector3Subtract");
// Subtract vector by float value
fn Vector3 vector3SubtractValue(Vector3 v, float sub) @cname("Vector3SubtractValue");

// Get Vector3 as float array
// fn float3 vector3ToFloatV(Vector3 v) @cname("Vector3ToFloatV"); // ? float3 == float[<3>]

// Transforms a Vector3 by a given Matrix
fn Vector3 vector3Transform(Vector3 v, Matrix mat) @cname("Vector3Transform");
// Projects a Vector3 from screen space into object space
// NOTE: We are avoiding calling other raymath functions despite available
fn Vector3 vector3Unproject(Vector3 source, Matrix projection, Matrix view) @cname("Vector3Unproject");
// Vector with components value 0.0f
fn Vector3 vector3Zero() @cname("Vector3Zero");

fn Vector4 vector4Add(Vector4 v1, Vector4 v2) @cname("Vector4Add");
fn Vector4 vector4AddValue(Vector4 v, float add) @cname("Vector4AddValue");
// Calculate distance between two vectors
fn float vector4Distance(Vector4 v1, Vector4 v2) @cname("Vector4Distance");
// Calculate square distance between two vectors
fn float vector4DistanceSqr(Vector4 v1, Vector4 v2) @cname("Vector4DistanceSqr");
// Divide vector by vector
fn Vector4 vector4Divide(Vector4 v1, Vector4 v2) @cname("Vector4Divide");
fn float vector4DotProduct(Vector4 v1, Vector4 v2) @cname("Vector4DotProduct");
// Check whether two given vectors are almost equal
fn int vector4Equals(Vector4 p, Vector4 q) @cname("Vector4Equals");
// Invert the given vector
fn Vector4 vector4Invert(Vector4 v) @cname("Vector4Invert");
fn float vector4Length(Vector4 v) @cname("Vector4Length");
fn float vector4LengthSqr(Vector4 v) @cname("Vector4LengthSqr");
// Calculate linear interpolation between two vectors
fn Vector4 vector4Lerp(Vector4 v1, Vector4 v2, float amount) @cname("Vector4Lerp");
// Get max value for each pair of components
fn Vector4 vector4Max(Vector4 v1, Vector4 v2) @cname("Vector4Max");
// Get min value for each pair of components
fn Vector4 vector4Min(Vector4 v1, Vector4 v2) @cname("Vector4Min");
// Move Vector towards target
fn Vector4 vector4MoveTowards(Vector4 v, Vector4 target, float maxDistance) @cname("Vector4MoveTowards");
// Multiply vector by vector
fn Vector4 vector4Multiply(Vector4 v1, Vector4 v2) @cname("Vector4Multiply");
// Negate vector
fn Vector4 vector4Negate(Vector4 v) @cname("Vector4Negate");
// Normalize provided vector
fn Vector4 vector4Normalize(Vector4 v) @cname("Vector4Normalize");
fn Vector4 vector4One() @cname("Vector4One");
fn Vector4 vector4Scale(Vector4 v, float scale) @cname("Vector4Scale");
fn Vector4 vector4Subtract(Vector4 v1, Vector4 v2) @cname("Vector4Subtract");
fn Vector4 vector4SubtractValue(Vector4 v, float add) @cname("Vector4SubtractValue");
fn Vector4 vector4Zero() @cname("Vector4Zero");

// Add two matrices
fn Matrix matrixAdd(Matrix left, Matrix right) @cname("MatrixAdd");
// Decompose a transformation matrix into its rotational, translational and scaling components
fn void matrixDecompose(Matrix mat, Vector3 *translation, Quaternion *rotation, Vector3 *scale) @cname("MatrixDecompose");
// Compute matrix determinant
fn float matrixDeterminant(Matrix mat) @cname("MatrixDeterminant");
// Get perspective projection matrix
fn Matrix matrixFrustum(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixFrustum");
// Get identity matrix
fn Matrix matrixIdentity() @cname("MatrixIdentity");
// Invert provided matrix
fn  Matrix matrixInvert(Matrix mat) @cname("MatrixInvert");
// Get camera look-at matrix (view matrix)
fn Matrix matrixLookAt(Vector3 eye, Vector3 target, Vector3 up) @cname("MatrixLookAt");
// Get two matrix multiplication
// NOTE: When multiplying matrices... the order matters!
fn Matrix matrixMultiply(Matrix left, Matrix right) @cname("MatrixMultiply");
// Get orthographic projection matrix
fn Matrix matrixOrtho(double left, double right, double bottom, double top, double nearPlane, double farPlane) @cname("MatrixOrtho");
// Get perspective projection matrix
// NOTE: Fovy angle must be provided in radians
fn Matrix matrixPerspective(double fovY, double aspect, double nearPlane, double farPlane) @cname("MatrixPerspective");
// Create rotation matrix from axis and angle
// NOTE: Angle should be provided in radians
fn Matrix matrixRotate(Vector3 axis, float angle) @cname("MatrixRotate");
// Get x-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateX(float angle) @cname("MatrixRotateX");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateXYZ(Vector3 angle) @cname("MatrixRotateXYZ");
// Get y-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateY(float angle) @cname("MatrixRotateY");
// Get z-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateZ(float angle) @cname("MatrixRotateZ");
// Get zyx-rotation matrix
// NOTE: Angle must be provided in radians
fn Matrix matrixRotateZYX(Vector3 angle) @cname("MatrixRotateZYX");
// Get scaling matrix
fn Matrix matrixScale(float x, float y, float z) @cname("MatrixScale");
// Subtract two matrices (left - right)
fn Matrix matrixSubtract(Matrix left, Matrix right) @cname("MatrixSubtract");

// Get float array of matrix data
// fn float16 matrixToFloatV(Matrix mat) @cname("MatrixToFloatV"); // float16 == float[<16>] ??

// Get the trace of the matrix (sum of the values along the diagonal)
fn float matrixTrace(Matrix mat) @cname("MatrixTrace");
// Get translation matrix
fn  Matrix matrixTranslate(float x, float y, float z) @cname("MatrixTranslate");
// Transposes provided matrix
fn Matrix matrixTranspose(Matrix mat) @cname("MatrixTranspose");

// Add two quaternions
fn Quaternion quaternionAdd(Quaternion q1, Quaternion q2) @cname("QuaternionAdd");
// Add quaternion and float value
fn Quaternion quaternionAddValue(Quaternion q, float add) @cname("QuaternionAddValue");
// Calculate quaternion cubic spline interpolation using Cubic Hermite Spline algorithm
// as described in the GLTF 2.0 specification: https://registry.khronos.org/glTF/specs/2.0/glTF-2.0.html#interpolation-cubic
fn Quaternion quaternionCubicHermiteSpline(Quaternion q1, Quaternion outTangent1, Quaternion q2, Quaternion inTangent2, float t) @cname("QuaternionCubicHermiteSpline");
// Divide two quaternions
fn Quaternion quaternionDivide(Quaternion q1, Quaternion q2) @cname("QuaternionDivide");
// Check whether two given quaternions are almost equal
fn int quaternionEquals(Quaternion p, Quaternion q) @cname("QuaternionEquals");
// Get rotation quaternion for an angle and axis
// NOTE: Angle must be provided in radians
fn Quaternion quaternionFromAxisAngle(Vector3 axis, float angle) @cname("QuaternionFromAxisAngle");
// Get the quaternion equivalent to Euler angles
// NOTE: Rotation order is ZYX
fn Quaternion quaternionFromEuler(float pitch, float yaw, float roll) @cname("QuaternionFromEuler");
// Get a quaternion for a given rotation matrix
fn Quaternion quaternionFromMatrix(Matrix mat) @cname("QuaternionFromMatrix");
// Calculate quaternion based on the rotation from one vector to another
fn Quaternion quaternionFromVector3ToVector3(Vector3 from, Vector3 to) @cname("QuaternionFromVector3ToVector3");
// Get identity quaternion
fn Quaternion quaternionIdentity() @cname("QuaternionIdentity");
// Invert provided quaternion
fn Quaternion quaternionInvert(Quaternion q) @cname("QuaternionInvert");
// Computes the length of a quaternion
fn float quaternionLength(Quaternion q) @cname("QuaternionLength");
// Calculate linear interpolation between two quaternions
fn Quaternion quaternionLerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionLerp");
// Calculate two quaternion multiplication
fn Quaternion quaternionMultiply(Quaternion q1, Quaternion q2) @cname("QuaternionMultiply");
// Calculate slerp-optimized interpolation between two quaternions
fn Quaternion quaternionNlerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionNlerp");
// Normalize provided quaternion
fn Quaternion quaternionNormalize(Quaternion q) @cname("QuaternionNormalize");
// Scale quaternion by float value
fn Quaternion quaternionScale(Quaternion q, float mul) @cname("QuaternionScale");
// Calculates spherical linear interpolation between two quaternions
fn Quaternion quaternionSlerp(Quaternion q1, Quaternion q2, float amount) @cname("QuaternionSlerp");
// Subtract two quaternions
fn Quaternion quaternionSubtract(Quaternion q1, Quaternion q2) @cname("QuaternionSubtract");
// Subtract quaternion and float value
fn Quaternion quaternionSubtractValue(Quaternion q, float sub) @cname("QuaternionSubtractValue");
// Get the rotation angle and axis for a given quaternion
fn void quaternionToAxisAngle(Quaternion q, Vector3 *outAxis, float *outAngle) @cname("QuaternionToAxisAngle");
// Get the Euler angles equivalent to quaternion (roll, pitch, yaw)
// NOTE: Angles are returned in a Vector3 struct in radians
fn Vector3 quaternionToEuler(Quaternion q) @cname("QuaternionToEuler");
// Get a matrix for a given quaternion
fn Matrix quaternionToMatrix(Quaternion q) @cname("QuaternionToMatrix");
// Transform a quaternion given a transformation matrix
fn Quaternion quaternionTransform(Quaternion q, Matrix mat) @cname("QuaternionTransform");
// end_region raymath
