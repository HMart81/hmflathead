/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/

// WARNING: This file is a work in progress and may not be fully functional yet.
// Unfinished was not able to get the bindings working properly, so I am leaving it here for now.

/***************************************************************
* This are C3 bindings for the micro lua script language (5.3). 
* To know more about it, see: http://lua-users.org/wiki/SimpleLuaApiExample
*
* NOTE(HM): 
*   structs in this file, passed by pointer, can be just alias to a void* (opaque pointer) and be done with it! 
*   The reality is, you don't need to know the full data-layout for most of them to use this... 
*   (but don't try storing the structs by value after that...)
****************************************************************/

module thirdparty::scripting::lua @if($feature(LUA_ENABLE));

import std::io;
import engine::logging::log;
import libc;

//import buffer @public;

const VERSION_MAJOR   = "5";
const VERSION_MINOR   = "4";
const VERSION_RELEASE = "8";

const VERSION_NUM = 504;
const VERSION_RELEASE_NUM =	(VERSION_NUM * 100 + 8);
macro version() => VERSION_NUM;

// A human-friendly string representation of the version.
const VERSION_STR =	"Lua " +++ VERSION_MAJOR +++ "." +++ VERSION_MINOR;
const RELEASE =	VERSION_STR +++ "." +++ VERSION_RELEASE;
const COPYRIGHT =	RELEASE +++ "  Copyright (C) 1994-2025 Lua.org, PUC-Rio";
const AUTHORS =	"R. Ierusalimschy, L. H. de Figueiredo, W. Celes";

/* mark for precompiled code ('<esc>Lua') */
const SIGNATURE =	"\x1bLua";

/* option for multiple returns in 'lua_pcall' and 'lua_call' */
const MULTI_RET =	-1;

const EXTRASPACE = (void*).sizeof; // space for userdata in LuaState

const I_MAXSTACK = 1000000;
/*
** Pseudo-indices
** (-I_MAXSTACK is the minimum valid index; we keep some free empty
** space after that to help overflow detection)
*/
const REGISTRY_INDEX =	(-I_MAXSTACK - 1000);
macro @upvalueindex($i)	=> (REGISTRY_INDEX - ($i));


//============================= LUA STACK INDICES =============================================
// Stack indices start at 1 or -1, 0 means an empty stack.
// NOTE(HM): 
// when using negative indices, -1 is the top element aka last pushed element.
// when using positive indices, 1 is the bottom element aka first pushed element.
const LUASTACK_EMPTY  =  0; // empty stack
const LUASTACK_TOP    = -1; // top of the stack
const LUASTACK_RETURN = LUASTACK_TOP; // function return value slot
// Because a stack in the real world, is usually last-in-first-out (LIFO),
// we will do indexing using negative indices, from top to bottom, 
// where top is the last pushed element:
// WARNING: 
// This is different from Lua's own API, where positive indices are used,
// starting from 1 at the bottom of the stack (first pushed element).
// And also be mindfull that online examples and tutorials may use positive indices.
const LUASTACK_IDX1   = -1; // first/top element in the stack argument slot
const LUASTACK_IDX2   = -2;
const LUASTACK_IDX3   = -3;
const LUASTACK_IDX4   = -4;
const LUASTACK_IDX5   = -5;
const LUASTACK_IDX6   = -6;
//============================= LUA STACK INDICES =============================================

macro stackIDXToSTR(idx) {
  switch (idx) {
    case LUASTACK_EMPTY : return "EMPTY";
    case LUASTACK_TOP   : return "TOP/RETURN/IDX1";
    case LUASTACK_IDX2  : return "IDX2";
    case LUASTACK_IDX3  : return "IDX3";
    case LUASTACK_IDX4  : return "IDX4";
    case LUASTACK_IDX5  : return "IDX5";
    case LUASTACK_IDX6  : return "IDX6";
    default: return "???";
  }
}

/* thread status */
const OK        = 0;
const YIELD     = 1;
const ERRRUN    = 2;
const ERRSYNTAX = 3;
const ERRMEM    = 4;
const ERRERR    = 5;

macro statusName(status) {
  switch (status) {
    case OK       : return "OK";
    case YIELD    : return "YIELD";
    case ERRRUN   : return "ERRRUN";
    case ERRSYNTAX: return "ERRSYNTAX";
    case ERRMEM   : return "ERRMEM";
    case ERRERR   : return "ERRERR";
    default: return "???";
  }
}
  


typedef LUAState = inline void;

const TYPE_NONE          = -1;
const TYPE_NIL           = 0;
const TYPE_BOOLEAN       = 1;
const TYPE_LIGHTUSERDATA = 2; // A light userdata represents a pointer, a void*.
const TYPE_NUMBER        = 3;
const TYPE_STRING        = 4;
const TYPE_TABLE         = 5;
const TYPE_FUNCTION      = 6;
const TYPE_USERDATA      = 7; // custom C3 types to be used/managed in Lua
const TYPE_THREAD        = 8;
const NUM_TYPES          = 9;

macro typeTostr(t) 
{
  switch (t) {
    case TYPE_NONE         : return "NONE"; 
    case TYPE_NIL          : return "NIL"; 
    case TYPE_BOOLEAN      : return "BOOLEAN"; 
    case TYPE_LIGHTUSERDATA: return "LIGHTUSERDATA"; 
    case TYPE_NUMBER       : return "NUMBER"; 
    case TYPE_STRING       : return "STRING"; 
    case TYPE_TABLE        : return "TABLE"; 
    case TYPE_FUNCTION     : return "FUNCTION"; 
    case TYPE_USERDATA     : return "USERDATA"; 
    case TYPE_THREAD       : return "THREAD"; 
    default: return "???";
  }
}

/* minimum Lua stack available to a C function */
const MINSTACK = 20;


/* predefined values in the registry */
const RIDX_MAINTHREAD	= 1;
const RIDX_GLOBALS = 2;
const RIDX_LAST	= RIDX_GLOBALS;

/* type of numbers in Lua */
alias Number = double;

/* type for integer functions */
alias Integer = long; // 64-bit two-complement signed integer

/* unsigned integer type */
alias Unsigned = ulong; // 64-bit unsigned integer type

/* type for continuation-function contexts */
alias KContext = Integer;


// generic type for when getting stack values
alias TValue = int; // also known as lua_Object or lua_TValue in modern lua

// Userdata represent C values in Lua. 
// A light userdata represents a pointer, a void*. 
// It is a value (like a number): you do not create it, it has no individual metatable, and it is not collected (as it was never created). A light userdata is equal to "any" light userdata with the same C address.
alias UData = void*;

/*
** Type for C functions registered with Lua
*/
alias CFunction = fn int(LUAState *state);

/*
** Type for continuation functions
*/
alias KFunction = fn int(LUAState *state, int status, KContext ctx);

/*
** Type for functions that read/write blocks when loading/dumping Lua chunks
*/
alias LUAReader = fn ZString (LUAState *state, void *ud, usz *sz);

alias LUAWriter = fn int (LUAState *state, void *p, usz sz, void *ud);

/*
** Type for memory-allocation functions
*/
alias Alloc_callback = fn void*(void* ud, void* ptr, usz osize, usz nsize);



extern fn int LUAState.rawequal(&self, int idx1, int idx2) @cname("lua_rawequal");
extern fn int LUAState.compare(&self, int idx1, int idx2, int op) @cname("lua_compare");


/*
** {==============================================================
** some useful macros
** ===============================================================
*/

macro getextraspace(l) =>	((void *)((char *)(l) - EXTRASPACE));

macro LUAState.pop(&self, n) => self.settop(-n-1);

/*
macro lua_newtable(L)		lua_createtable(L, 0, 0)
*/

macro LUAState.register(&self, n, f) { self.pushcfunction(f); self.setglobal(n); }

macro LUAState.pushcfunction(&self, f) => self.pushcclosure(f, 0);

macro LUAState.isfunction(&self,n) =>	(self.type(n) == TYPE_FUNCTION);
macro LUAState.istable(&self,n)	=> (self.type(n) == TYPE_TABLE);

// checks whether the value is a UDATA (void*).
macro LUAState.islightuserdata(&self,n)	=> (self.type(n) == TYPE_LIGHTUSERDATA);
//
macro LUAState.isnil(&self,n)		=> (self.type(n) == TYPE_NIL);
macro LUAState.isboolean(&self,n)	=> (self.type(n) == TYPE_BOOLEAN);
macro LUAState.isthread(&self,n)	=> (self.type(n) == TYPE_THREAD);
macro LUAState.isnone(&self,n)		=> (self.type(n) == TYPE_NONE);
macro LUAState.isnoneornil(&self,n)	=> (self.type(n) <= 0);

//This macro is equivalent to lua_pushstring, but should be used only when s is a literal string. (Lua may optimize this case.)
macro LUAState.pushliteral(&self, s = "") =>	self.pushstring(s.zstr_tcopy());
//
macro LUAState.remove(&self, idx)	{ self.rotate(idx, LUASTACK_TOP); self.pop(1); }
macro LUAState.insert(&self, idx)	=> self.rotate(idx, 1);

/*
macro lua_pushglobaltable(L)  \
	((void)lua_rawgeti(L, LUA_REGISTRYINDEX, LUA_RIDX_GLOBALS))

*/
/* }============================================================== */
macro LUAState.replace(&self, idx) { self.copy(-1, idx); self.pop(1); }


/*
** state manipulation
*/
extern fn  LUAState* newstate() @cname("luaL_newstate");
extern fn  LUAState* newstateExt(Alloc_callback f, void* ud) @cname("lua_newstate");
extern fn  void   LUAState.close(&self) @cname("lua_close");
extern fn  LUAState* LUAState.newthread(&self) @cname("lua_newthread");
extern fn  int    LUAState.closethread(&self, LUAState* from) @cname("lua_closethread");
//extern fn  int        (lua_resetthread) (lua_State *L);  /* Deprecated! */

extern fn  CFunction LUAState.atpanic(&self, CFunction panicf) @cname("lua_atpanic");

macro createVirtualMachine(LUAState** state) 
{
  (*state) = newstate();
  assert(*state != null, "Failed to create new local Lua stack/VM.");
  // init the lua libraries (math, string, table, etc) for this state
  (*state).openlibs();
}

macro closeVirtualMachine(LUAState** state) 
{
  if(*state) { (*state).close(); (*state) = null; } 
}

/*
** Usage:
** LUAState* state;
** localStack(state) {
**    // push stuff into the stack here using 'state'
**    state.pushnumber(42);
**    state.pushnumber(69);
**    state.pushnumber(420);

**    // do stuff with the stack here
**    Number x = state.tonumber(2); // get the second element (69)
**    log::info(CONSOLE, "The second element in the stack is: %s", x);
**    // etc...
** }; // 'state' or stack is automatically closed and cleared here

    Stack visualization:
    +------------------+
    | 420 -> 3 || -1   |
    |  69 -> 2 || -2   |
    |  42 -> 1 || -3   |
    +------------------+
*/
// A macro to create a local Lua stack/VM that is automatically closed at the end of the scope.
macro @localStack(LUAState** state; @body) {
  createVirtualMachine(state);
  defer closeVirtualMachine(state);
  @body();
}

extern fn int LUAState.version(&self) @cname("lua_version");

extern fn void LUAState.openlibs(&self) @cname("luaL_openlibs");

extern fn int LUAState.loadfilex(&self, ZString filename, ZString mode) @local @cname("luaL_loadfilex");

// WARNING(HM):
// loadfile loads the file's contents as a chunk but DOES NOT EXECUTE IT, 
//  if load is sucessfull, it returns a function on the lua stack that can be called later. 
//  This allows for more flexibility with loadfile, as you can call the loaded function- 
//  multiple times without reloading the file.
// But again, it will NOT run any of the lua code or initialize its contents,
//  meaning no variables are assigned or functions are run.
// To run the loaded script code, you need to call pcall() after this.
// And then after you can inspect the stack for any variables or functions defined in the script.
macro LUAState.@loadfile(&self, #f) =>	self.loadfilex(#f.zstr_tcopy(), null);

extern fn int LUAState.loadstring(&self, ZString s) @cname("luaL_loadstring");

macro LUAState.dofile(&self, f) => (self.@loadfile(f) || self.pcall(0, MULTI_RET, 0));
macro LUAState.dostring(&self, s) => (self.loadstring(s.zstr_tcopy()) || self.pcall(0, MULTRET, 0));

/*
** 'load' and 'call' functions (load and run Lua code)
*/
extern fn void LUAState.callk(&self, int nargs, int nresults,
                           KContext ctx, KFunction k) @cname("lua_callk");
macro LUAState.call(&self,n,r) => self.callk(n, r, 0, null);

extern fn int LUAState.pcallk(&self, int nargs, int nresults, int errfunc,
                            KContext ctx, KFunction k) @cname("lua_pcallk");
macro LUAState.pcall(&self,n,r,f)	=> self.pcallk(n, r, f, 0, null);

extern fn int LUAState.load(&self, LUAReader reader, void *dt,
                          ZString chunkname, ZString mode) @cname("lua_load");

extern fn int LUAState.dump(&self, LUAWriter writer, void *data, int strip) @cname("lua_dump");



/*
** basic stack manipulation
*/
extern fn int  LUAState.absindex(&self, int idx) @cname("lua_absindex");
extern fn int  LUAState.gettop(&self) @cname("lua_gettop");
extern fn void LUAState.settop(&self, int idx) @cname("lua_settop");
extern fn void LUAState.pushvalue(&self, int idx) @cname("lua_pushvalue");
extern fn void LUAState.rotate(&self, int idx, int n) @cname("lua_rotate");
extern fn void LUAState.copy(&self, int fromidx, int toidx) @cname("lua_copy");
extern fn int  LUAState.checkstack(&self, int n) @cname("lua_checkstack");

extern fn void LUAState.xmove(LUAState *from, LUAState *to, int n) @cname("lua_xmove");

/*
** access functions (stack -> C)
*/

extern fn int LUAState.isnumber(&self , int idx) @cname("lua_isnumber");
extern fn int LUAState.isstring(&self , int idx) @cname("lua_isstring");
extern fn int LUAState.iscfunction(&self , int idx) @cname("lua_iscfunction");
extern fn int LUAState.isinteger(&self , int idx) @cname("lua_isinteger");
extern fn int LUAState.isuserdata(&self , int idx) @cname("lua_isuserdata");
extern fn int LUAState.type(&self, int idx) @cname("lua_type");
extern fn ZString LUAState.typename(&self , int tp) @cname("lua_typename");

extern fn Number LUAState.tonumber(&self , int idx, int *isnum = null) @cname("lua_tonumberx");
extern fn Integer LUAState.tointeger(&self , int idx, int *isnum = null) @cname("lua_tointegerx");
extern fn int LUAState.toboolean(&self , int idx) @cname("lua_toboolean");
extern fn ZString LUAState.tostring(&self , int idx, usz *len = null) @cname("lua_tolstring");
extern fn Unsigned LUAState.rawlen(&self , int idx) @cname("lua_rawlen");
extern fn CFunction LUAState.tocfunction(&self , int idx) @cname("lua_tocfunction");
extern fn void* LUAState.touserdata(&self , int idx) @cname("lua_touserdata");
extern fn LUAState* LUAState.tothread(&self , int idx) @cname("lua_tothread");
extern fn void* LUAState.topointer(&self , int idx) @cname("lua_topointer");

/*
** push functions (C -> stack)
*/
extern fn void    LUAState.pushnil(&self) @cname("lua_pushnil");
extern fn void    LUAState.pushnumber(&self, Number n) @cname("lua_pushnumber");
extern fn void    LUAState.pushinteger(&self, Integer n) @cname("lua_pushinteger");
extern fn ZString LUAState.pushlstring(&self, ZString s, usz len) @cname("lua_pushlstring");
extern fn ZString LUAState.pushstring(&self, ZString s) @cname("lua_pushstring");
extern fn ZString LUAState.pushvfstring(&self, ZString fmt, /*va_list*/void* argp) @cname("lua_pushvfstring");
extern fn ZString LUAState.pushfstring(&self, ZString fmt, ...) @cname("lua_pushfstring");
extern fn void    LUAState.pushcclosure(&self, CFunction func, int n) @cname("lua_pushcclosure");
extern fn void    LUAState.pushboolean(&self, int b) @cname("lua_pushboolean");
extern fn void    LUAState.pushlightuserdata(&self, void* p) @cname("lua_pushlightuserdata");
extern fn int     LUAState.pushthread(&self) @cname("lua_pushthread");


/*
** get functions (Lua -> stack)  Pushes onto the stack the value
*/
extern fn TValue LUAState.getglobal(&self, ZString name) @cname("lua_getglobal");
extern fn int LUAState.gettable(&self, int idx) @cname("lua_gettable");
extern fn int LUAState.getfield(&self, int idx, ZString k) @cname("lua_getfield");
extern fn int LUAState.geti(&self, int idx, Integer n) @cname("lua_geti");
extern fn int LUAState.rawget(&self, int idx) @cname("lua_rawget");
extern fn int LUAState.rawgeti(&self, int idx, Integer n) @cname("lua_rawgeti");
extern fn int LUAState.rawgetp(&self, int idx, void *p) @cname("lua_rawgetp");

extern fn void  LUAState.createtable(&self, int narr, int nrec) @cname("lua_createtable");
extern fn void* LUAState.newuserdatauv(&self, usz sz, int nuvalue) @cname("lua_newuserdatauv");
extern fn int   LUAState.getmetatable(&self, int objindex) @cname("lua_getmetatable");
extern fn int  LUAState.getiuservalue(&self, int idx, int n) @cname("lua_getiuservalue");


/*
** set functions (stack -> Lua)
*/
extern fn void  LUAState.setglobal(&self, ZString name) @cname("lua_setglobal");
extern fn void  LUAState.settable(&self, int idx) @cname("lua_settable");
extern fn void  LUAState.setfield(&self, int idx, ZString k) @cname("lua_setfield");
extern fn void  LUAState.seti(&self, int idx, Integer n) @cname("lua_seti");
extern fn void  LUAState.rawset(&self, int idx) @cname("lua_rawset");
extern fn void  LUAState.rawseti(&self, int idx, Integer n) @cname("lua_rawseti");
extern fn void  LUAState.rawsetp(&self, int idx, void *p) @cname("lua_rawsetp");
extern fn int   LUAState.setmetatable(&self, int objindex) @cname("lua_setmetatable");
extern fn int   LUAState.setiuservalue(&self, int idx, int n) @cname("lua_setiuservalue");


/*
** miscellaneous functions
*/

extern fn int LUAState.error(&self) @cname("lua_error");
extern fn int   LUAState.next(&self, int idx) @cname("lua_next");
extern fn void  LUAState.concat(&self, int n) @cname("lua_concat");
extern fn void  LUAState.len(&self, int idx) @cname("lua_len");
extern fn usz   LUAState.stringtonumber(&self, ZString s) @cname("lua_stringtonumber");

extern fn Alloc_callback LUAState.getallocf(&self, void **ud) @cname("lua_getallocf");
extern fn void      LUAState.setallocf(&self, Alloc_callback f, void *ud) @cname("lua_setallocf");

extern fn void LUAState.toclose(&self, int idx) @cname("lua_toclose");
extern fn void LUAState.closeslot(&self, int idx) @cname("lua_closeslot");

extern fn int LUAState.getstack(&self, int level, LUADebug *ar) @cname("lua_getstack");
extern fn int LUAState.getinfo(&self, ZString what, LUADebug *ar) @cname("lua_getinfo");
extern fn ZString LUAState.getlocal(&self, LUADebug *ar, int n) @cname("lua_getlocal");
extern fn ZString LUAState.setlocal(&self, LUADebug *ar, int n) @cname("lua_setlocal");
extern fn ZString LUAState.getupvalue(&self, int funcindex, int n) @cname("lua_getupvalue");
extern fn ZString LUAState.setupvalue(&self, int funcindex, int n) @cname("lua_setupvalue");
/*
LUA_API void *(lua_upvalueid) (lua_State *L, int fidx, int n);
LUA_API void  (lua_upvaluejoin) (lua_State *L, int fidx1, int n1,
                                               int fidx2, int n2);

LUA_API void (lua_sethook) (lua_State *L, lua_Hook func, int mask, int count);
LUA_API lua_Hook (lua_gethook) (lua_State *L);
LUA_API int (lua_gethookmask) (lua_State *L);
LUA_API int (lua_gethookcount) (lua_State *L);

LUA_API int (lua_setcstacklimit) (lua_State *L, unsigned int limit);
*/

// Debug API
// The 'what' string may have the following characters:
// 'n': fill in the name and namewhat fields
// 'S': fill in the source, short_src, linedefined, lastlinedefined, and what fields
// 'l': fill in the currentline field
// 'u': fill in the nups, nparams, isvararg, and istailcall fields
// 't': fill in the istailcall field
// 'L': fill in the activelines field (where applicable)
// 'f': push onto the stack the function that is running at the given level
const LUA_IDSIZE = 60;
alias CallInfo @local = void;
struct LUADebug
{
  int event;
  ZString name;	/* (n) */
  ZString namewhat;	/* (n) 'global', 'local', 'field', 'method' */
  ZString what;	/* (S) 'Lua', 'C', 'main', 'tail' */
  ZString source;	/* (S) */
  usz srclen;	/* (S) */
  int currentline;	/* (l) */
  int linedefined;	/* (S) */
  int lastlinedefined;	/* (S) */
  char nups;	/* (u) number of upvalues */
  char nparams;/* (u) number of parameters */
  ichar isvararg;        /* (u) */
  ichar istailcall;	/* (t) */
  ushort ftransfer;   /* (r) index of first value transferred */
  ushort ntransfer;   /* (r) number of transferred values */
  ichar[LUA_IDSIZE] short_src; /* (S) */
  /* private part */
  CallInfo *i_ci;  /* active function */
}