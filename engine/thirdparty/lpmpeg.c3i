/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/
// Usage:: plmpeg library c3 bindings for MPEG1 video and MP2 audio playback.
// @incomplete

module thirdparty::plmpeg::plm; //@if($feature(LPMPEG_ENABLE));

import std::io;
import thirdparty::plmpeg::plm::buffer @public;

alias PLM_t = void*;
alias Uint8_t = char;

// Demuxed MPEG PS packet
// The type maps directly to the various MPEG-PES start codes. PTS is the
// presentation time stamp of the packet in seconds. Note that not all packets
// have a PTS value, indicated by PLM_PACKET_INVALID_TS.
const PLM_PACKET_INVALID_TS = -1;

struct PLMpacket 
{
	int type;
	double pts;
	usz length;
	Uint8_t *data;
}

// Decoded Video Plane 
// The byte length of the data is width * height. Note that different planes
// have different sizes: the Luma plane (Y) is double the size of each of 
// the two Chroma planes (Cr, Cb) - i.e. 4 times the byte length.
// Also note that the size of the plane does *not* denote the size of the 
// displayed frame. The sizes of planes are always rounded up to the nearest
// macroblock (16px).

struct PLMplane
{
	uint width;
	uint height;
	Uint8_t *data;
}

// Decoded Video Frame
// width and height denote the desired display size of the frame. This may be
// different from the internal size of the 3 planes.

struct PLMframe
{
	double time;
	uint width;
	uint height;
	PLMplane y;
	PLMplane cr;
	PLMplane cb;
}

// Callback function type for decoded video frames used by the high-level
// plm_* interface

alias VideoDecodeCallback = fn void (PLM_t self, PLMframe *frame, void *user);

// Decoded Audio Samples
// Samples are stored as normalized (-1, 1) float either interleaved, or if
// PLM_AUDIO_SEPARATE_CHANNELS is defined, in two separate arrays.
// The `count` is always PLM_AUDIO_SAMPLES_PER_FRAME and just there for
// convenience.

const PLM_AUDIO_SAMPLES_PER_FRAME @private = 1152;
const PLM_AUDIO_SEPARATE_CHANNELS = true;

struct PLMsamples
{
	double time;
	uint count;
	float[PLM_AUDIO_SAMPLES_PER_FRAME] left @if(PLM_AUDIO_SEPARATE_CHANNELS == true);
	float[PLM_AUDIO_SAMPLES_PER_FRAME] right @if(PLM_AUDIO_SEPARATE_CHANNELS == true);
	float[PLM_AUDIO_SAMPLES_PER_FRAME * 2] interleaved @if(PLM_AUDIO_SEPARATE_CHANNELS != true);
}

// Callback function type for decoded audio samples used by the high-level
// plm_* interface

alias AudioDecodeCallback = fn void (PLM_t self, PLMsamples *samples, void *user);

// Callback function for Buffer when it needs more data

alias BufferLoadCallback = fn void (Buffer *self, void *user);


// Callback function for Buffer when it needs to seek

alias BufferSeekCallback = fn void (Buffer *self, usz offset, void *user);


// Callback function for Buffer when it needs to tell the position

alias BufferTellCallback = fn usz (Buffer *self, void *user);

// API

// Create a plmpeg instance with a filename. Returns NULL if the file could not
// be opened.

fn PLM_t* create_with_filename(ZString filename) @cname("plm_create_with_filename");


// Create a plmpeg instance with a file handle. Pass TRUE to close_when_done to
// let plmpeg call fclose() on the handle when plm_destroy() is called.

fn PLM_t* create_with_file(File *fh, int close_when_done) @cname("plm_create_with_file");

// Create a plmpeg instance with a pointer to memory as source. This assumes the
// whole file is in memory. The memory is not copied. Pass TRUE to 
// free_when_done to let plmpeg call free() on the pointer when plm_destroy() 
// is called.

fn PLM_t* create_with_memory(Uint8_t *bytes, usz length, int free_when_done) @cname("plm_create_with_memory");

// Create a plmpeg instance with a plm_buffer as source. Pass TRUE to
// destroy_when_done to let plmpeg call plm_buffer_destroy() on the buffer when
// plm_destroy() is called.

fn PLM_t* create_with_buffer(Buffer *buffer, int destroy_when_done) @cname("plm_create_with_buffer");

// Destroy a plmpeg instance and free all data.

fn void PLM_t.destroy(PLM_t self) @cname("plm_destroy");

// Get whether we have headers on all available streams and we can report the 
// number of video/audio streams, video dimensions, framerate and audio 
// samplerate.
// This returns FALSE if the file is not an MPEG-PS file or - when not using a
// file as source - when not enough data is available yet.

fn int PLM_t.has_headers(PLM_t self) @cname("plm_has_headers");


// Probe the MPEG-PS data to find the actual number of video and audio streams
// within the buffer. For certain files (e.g. VideoCD) this can be more accurate
// than just reading the number of streams from the headers.
// This should only be used when the underlying plm_buffer is seekable, i.e. for 
// files, fixed memory buffers or _for_appending buffers. If used with dynamic
// memory buffers it will skip decoding the probesize!
// The necessary probesize is dependent on the files you expect to read. Usually
// a few hundred KB should be enough to find all streams.
// Use plm_get_num_{audio|video}_streams() afterwards to get the number of 
// streams in the file.
// Returns TRUE if any streams were found within the probesize.

fn int PLM_t.probe(PLM_t self, usz probesize) @cname("plm_probe");

// Get or set whether video decoding is enabled. Default TRUE.

fn int PLM_t.get_video_enabled(PLM_t self) @cname("plm_get_video_enabled");
fn void PLM_t.set_video_enabled(PLM_t self, int enabled) @cname("plm_set_video_enabled");


// Get the number of video streams (0--1) reported in the system header.

fn int PLM_t.get_num_video_streams(PLM_t self) @cname("plm_get_num_video_streams");


// Get the display width/height of the video stream.

fn int PLM_t.get_width(PLM_t self) @cname("plm_get_width");
fn int PLM_t.get_height(PLM_t self) @cname("plm_get_height");
fn double PLM_t.get_pixel_aspect_ratio(PLM_t self) @cname("plm_get_pixel_aspect_ratio");


// Get the framerate of the video stream in frames per second.

fn double PLM_t.get_framerate(PLM_t self) @cname("plm_get_framerate");


// Get or set whether audio decoding is enabled. Default TRUE.

fn int PLM_t.get_audio_enabled(PLM_t self) @cname("plm_get_audio_enabled");
fn void PLM_t.set_audio_enabled(PLM_t self, int enabled) @cname("plm_set_audio_enabled");


// Get the number of audio streams (0--4) reported in the system header.

fn int PLM_t.get_num_audio_streams(PLM_t self) @cname("plm_get_num_audio_streams");


// Set the desired audio stream (0--3). Default 0.

fn void PLM_t.set_audio_stream(PLM_t self, int stream_index) @cname("plm_set_audio_stream");


// Get the samplerate of the audio stream in samples per second.

fn int PLM_t.get_samplerate(PLM_t self) @cname("plm_get_samplerate");


// Get or set the audio lead time in seconds - the time in which audio samples
// are decoded in advance (or behind) the video decode time. Typically this
// should be set to the duration of the buffer of the audio API that you use
// for output. E.g. for SDL2: (SDL_AudioSpec.samples / samplerate)

fn double PLM_t.get_audio_lead_time(PLM_t self) @cname("plm_get_audio_lead_time");
fn void PLM_t.set_audio_lead_time(PLM_t self, double lead_time) @cname("plm_set_audio_lead_time");


// Get the current internal time in seconds.

fn double PLM_t.get_time(PLM_t self) @cname("plm_get_time");


// Get the video duration of the underlying source in seconds.

fn double PLM_t.get_duration(PLM_t self) @cname("plm_get_duration");


// Rewind all buffers back to the beginning.

fn void PLM_t.rewind(PLM_t self) @cname("plm_rewind");


// Get or set looping. Default FALSE.

fn int PLM_t.get_loop(PLM_t self) @cname("plm_get_loop");
fn void PLM_t.set_loop(PLM_t self, int loop) @cname("plm_set_loop");


// Get whether the file has ended. If looping is enabled, this will always
// return FALSE.

fn int PLM_t.has_ended(PLM_t self) @cname("plm_has_ended");

// Set the callback for decoded video frames used with plm_decode(). If no 
// callback is set, video data will be ignored and not be decoded. The *user
// Parameter will be passed to your callback.

fn void set_video_decode_callback(PLM_t player, VideoDecodeCallback fp, void *user) @cname("plm_set_video_decode_callback");


// Set the callback for decoded audio samples used with plm_decode(). If no 
// callback is set, audio data will be ignored and not be decoded. The *user
// Parameter will be passed to your callback.

fn void set_audio_decode_callback(PLM_t player, AudioDecodeCallback fp, void *user) @cname("plm_set_audio_decode_callback");


// Advance the internal timer by seconds and decode video/audio up to this time.
// This will call the video_decode_callback and audio_decode_callback any number
// of times. A frame-skip is not implemented, i.e. everything up to current time
// will be decoded.

fn void PLM_t.decode(PLM_t self, double seconds) @cname("plm_decode");


// Decode and return one video frame. Returns NULL if no frame could be decoded
// (either because the source ended or data is corrupt). If you only want to 
// decode video, you should disable audio via plm_set_audio_enabled().
// The returned PLMframe is valid until the next call to plm_decode_video() 
// or until plm_destroy() is called.

fn PLMframe* PLM_t.decode_video(PLM_t self) @cname("plm_decode_video");


// Decode and return one audio frame. Returns NULL if no frame could be decoded
// (either because the source ended or data is corrupt). If you only want to 
// decode audio, you should disable video via plm_set_video_enabled().
// The returned PLMsamples is valid until the next call to plm_decode_audio()
// or until plm_destroy() is called.

fn PLMsamples* PLM_t.decode_audio(PLM_t self) @cname("plm_decode_audio");

// Seek to the specified time, clamped between 0 -- duration. This can only be 
// used when the underlying plm_buffer is seekable, i.e. for files, fixed 
// memory buffers or _for_appending buffers. 
// If seek_exact is TRUE this will seek to the exact time, otherwise it will 
// seek to the last intra frame just before the desired time. Exact seeking can 
// be slow, because all frames up to the seeked one have to be decoded on top of
// the previous intra frame.
// If seeking succeeds, this function will call the video_decode_callback 
// exactly once with the target frame. If audio is enabled, it will also call
// the audio_decode_callback any number of times, until the audio_lead_time is
// satisfied.
// Returns TRUE if seeking succeeded or FALSE if no frame could be found.

fn int PLM_t.seek(PLM_t self, double time, int seek_exact) @cname("plm_seek");


// Similar to plm_seek(), but will not call the video_decode_callback,
// audio_decode_callback or make any attempts to sync audio.
// Returns the found frame or NULL if no frame could be found.

fn PLMframe* PLM_t.seek_frame(PLM_t self, double time, int seek_exact) @cname("plm_seek_frame");

// -----------------------------------------------------------------------------
// TODO see https://github.com/phoboslab/pl_mpeg/blob/master/pl_mpeg.h#L468 
// plm_buffer public API
// Provides the data source for all other plm_* interfaces

module thirdparty::plmpeg::plm::buffer;

import std::io;

enum BFMode : const inline int
{
	FILE,
	FIXED_MEM,
	RING,
	APPEND
}

struct Buffer
{
	usz bit_index;
	usz capacity;
	usz length;
	usz total_size;
	int discard_read_bytes;
	int has_ended;
	int free_when_done;

	int close_when_done @if(!$defined(PLM_NO_STDIO));
	File *fh @if(!$defined(PLM_NO_STDIO));

	BufferLoadCallback load_callback;
	BufferSeekCallback seek_callback;
	BufferTellCallback tell_callback;
	void *load_callback_user_data;
	Uint8_t *bytes;
	BFMode mode;
}

// The default size for buffers created from files or by the high-level API

const PLM_BUFFER_DEFAULT_SIZE = (128 * 1024);

// Create a buffer instance with a filename. Returns NULL if the file could not
// be opened.

fn Buffer *create_with_filename(ZString filename) @cname("plm_buffer_create_with_filename") @if(!$defined(PLM_NO_STDIO));


// Create a buffer instance with a file handle. Pass TRUE to close_when_done
// to let plmpeg call fclose() on the handle when plm_destroy() is called.

fn Buffer *create_with_file(File *fh, int close_when_done) @cname("plm_buffer_create_with_file") @if(!$defined(PLM_NO_STDIO));


// Create a buffer instance with custom callbacks for loading, seeking and
// telling the position. This behaves like a file handle, but with user-defined
// callbacks, useful for file handles that don't use the standard FILE API.
// Setting the length and closing/freeing has to be done manually.

fn Buffer *create_with_callbacks(
	BufferLoadCallback load_callback,
	BufferSeekCallback seek_callback,
	BufferTellCallback tell_callback,
	usz length,
	void *user
) @cname("plm_buffer_create_with_callbacks");


// Create a buffer instance with a pointer to memory as source. This assumes
// the whole file is in memory. The bytes are not copied. Pass 1 to 
// free_when_done to let plmpeg call free() on the pointer when plm_destroy() 
// is called.

fn Buffer *create_with_memory(Uint8_t *bytes, usz length, int free_when_done) @cname("plm_buffer_create_with_memory");


// Create an empty buffer with an initial capacity. The buffer will grow
// as needed. Data that has already been read, will be discarded.

fn Buffer *create_with_capacity(usz capacity) @cname("plm_buffer_create_with_capacity");


// Create an empty buffer with an initial capacity. The buffer will grow
// as needed. Decoded data will *not* be discarded. This can be used when
// loading a file over the network, without needing to throttle the download. 
// It also allows for seeking in the already loaded data.

fn Buffer *plm_buffer_create_for_appending(usz initial_capacity) @cname("plm_buffer_create_for_appending");


// Destroy a buffer instance and free all data

fn void Buffer.destroy(Buffer *self) @cname("plm_buffer_destroy");


// Copy data into the buffer. If the data to be written is larger than the 
// available space, the buffer will realloc() with a larger capacity. 
// Returns the number of bytes written. This will always be the same as the
// passed in length, except when the buffer was created _with_memory() for
// which _write() is forbidden.

fn usz Buffer.write(Buffer *self, Uint8_t *bytes, usz length) @cname("plm_buffer_write");


// Mark the current byte length as the end of this buffer and signal that no 
// more data is expected to be written to it. This function should be called
// just after the last plm_buffer_write().
// For _with_capacity buffers, this is cleared on a plm_buffer_rewind().

fn void Buffer.signal_end(Buffer *self) @cname("plm_buffer_signal_end");


// Set a callback that is called whenever the buffer needs more data

fn void Buffer.set_load_callback(Buffer *self, BufferLoadCallback fp, void *user) @cname("plm_buffer_set_load_callback");


// Rewind the buffer back to the beginning. When loading from a file handle,
// this also seeks to the beginning of the file.

fn void Buffer.rewind(Buffer *self) @cname("plm_buffer_rewind");


// Get the total size. For files, this returns the file size. For all other 
// types it returns the number of bytes currently in the buffer.

fn usz Buffer.get_size(Buffer *self) @cname("plm_buffer_get_size");


// Get the number of remaining (yet unread) bytes in the buffer. This can be
// useful to throttle writing.

fn usz Buffer.get_remaining(Buffer *self) @cname("plm_buffer_get_remaining");


// Get whether the read position of the buffer is at the end and no more data 
// is expected.

fn int Buffer.ended(Buffer *self) @cname("plm_buffer_has_ended");


module thirdparty::plmpeg::plm::video;
// -----------------------------------------------------------------------------
// plm_video public API
// Decode MPEG1 Video ("mpeg1") data into raw YCrCb frames

import thirdparty::plmpeg::plm;
import thirdparty::plmpeg::plm::buffer @public;

struct PLMvideoMotion {
	int full_px;
	int is_set;
	int r_size;
	int h;
	int v;
}

struct PLMvideo {
	double framerate;
	double pixel_aspect_ratio;
	double time;
	int frames_decoded;
	int width;
	int height;
	int mb_width;
	int mb_height;
	int mb_size;

	int luma_width;
	int luma_height;

	int chroma_width;
	int chroma_height;

	int start_code;
	int picture_type;

	PLMvideoMotion motion_forward;
	PLMvideoMotion motion_backward;

	int has_sequence_header;

	int quantizer_scale;
	int slice_begin;
	int macroblock_address;

	int mb_row;
	int mb_col;

	int macroblock_type;
	int macroblock_intra;

	int[3] dc_predictor;

	Buffer *buffer;
	int destroy_buffer_when_done;

	PLMframe frame_current;
	PLMframe frame_forward;
	PLMframe frame_backward;

	Uint8_t *frames_data;

	int[64] block_data;
	Uint8_t[64] intra_quant_matrix;
	Uint8_t[64] non_intra_quant_matrix;

	int has_reference_frame;
	int assume_no_b_frames;
}

fn int PLMvideo.decode_sequence_header(PLMvideo *self) @cname("plm_video_decode_sequence_header");
fn void PLMvideo.init_frame(PLMvideo *self, PLMframe *frame, Uint8_t *base) @cname("plm_video_init_frame");
fn void PLMvideo.decode_picture(PLMvideo *self) @cname("plm_video_decode_picture");
fn void PLMvideo.decode_slice(PLMvideo *self, int slice) @cname("plm_video_decode_slice");
fn void PLMvideo.decode_macroblock(PLMvideo *self) @cname("plm_video_decode_macroblock");
fn void PLMvideo.decode_motion_vectors(PLMvideo *self) @cname("plm_video_decode_motion_vectors");
fn int PLMvideo.decode_motion_vector(PLMvideo *self, int r_size, int motion) @cname("plm_video_decode_motion_vector");
fn void PLMvideo.predict_macroblock(PLMvideo *self) @cname("plm_video_predict_macroblock");
fn void PLMvideo.copy_macroblock(PLMvideo *self, PLMframe *s, int motion_h, int motion_v) @cname("plm_video_copy_macroblock");
fn void PLMvideo.interpolate_macroblock(PLMvideo *self, PLMframe *s, int motion_h, int motion_v) @cname("plm_video_interpolate_macroblock");
fn void PLMvideo.process_macroblock(PLMvideo *self, Uint8_t *s, Uint8_t *d, int mh, int mb, int bs, int interp) @cname("plm_video_process_macroblock");
fn void PLMvideo.decode_block(PLMvideo *self, int block) @cname("plm_video_decode_block");
fn void PLMvideo.idct(PLMvideo *self, int *block) @cname("plm_video_idct");

// Create a video decoder with a plm_buffer as source.

fn PLMvideo *create_with_buffer(Buffer *buffer, int destroy_when_done) @cname("plm_video_create_with_buffer");


// Destroy a video decoder and free all data.

fn void PLMvideo.destroy(PLMvideo *self) @cname("plm_video_destroy");


// Get whether a sequence header was found and we can accurately report on
// dimensions and framerate.

fn int PLMvideo.has_header(PLMvideo *self) @cname("plm_video_has_header");


// Get the framerate in frames per second.

fn double PLMvideo.get_framerate(PLMvideo *self) @cname("plm_video_get_framerate");
fn double PLMvideo.get_pixel_aspect_ratio(PLMvideo *self) @cname("plm_video_get_pixel_aspect_ratio");


// Get the display width/height.

fn int PLMvideo.get_width(PLMvideo *self) @cname("plm_video_get_width");
fn int PLMvideo.get_height(PLMvideo *self) @cname("plm_video_get_height");


// Set "no delay" mode. When enabled, the decoder assumes that the video does
// *not* contain any B-Frames. This is useful for reducing lag when streaming.
// The default is FALSE.

fn void PLMvideo.set_no_delay(PLMvideo *self, int no_delay) @cname("plm_video_set_no_delay");


// Get the current internal time in seconds.

fn double PLMvideo.get_time(PLMvideo *self) @cname("plm_video_get_time");


// Set the current internal time in seconds. This is only useful when you
// manipulate the underlying video buffer and want to enforce a correct
// timestamps.

fn void PLMvideo.set_time(PLMvideo *self, double time) @cname("plm_video_set_time");


// Rewind the internal buffer. See plm_buffer_rewind().

fn void PLMvideo.rewind(PLMvideo *self) @cname("plm_video_rewind");


// Get whether the file has ended. This will be cleared on rewind.

fn int PLMvideo.has_ended(PLMvideo *self) @cname("plm_video_has_ended");


// Decode and return one frame of video and advance the internal time by 
// 1/framerate seconds. The returned frame_t is valid until the next call of
// PLMvideo.decode() or until the video decoder is destroyed.

fn PLMframe *PLMvideo.decode(PLMvideo *self) @cname("plm_video_decode");


// Convert the YCrCb data of a frame into interleaved R G B data. The stride
// specifies the width in bytes of the destination buffer. I.e. the number of
// bytes from one line to the next. The stride must be at least 
// (frame->width * bytes_per_pixel). The buffer pointed to by *dest must have a
// size of at least (stride * frame->height).
// Note that the alpha component of the dest buffer is always left untouched.

fn void PLMframe.to_rgb(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_rgb");
fn void PLMframe.to_bgr(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_bgr");
fn void PLMframe.to_rgba(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_rgba");
fn void PLMframe.to_bgra(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_bgra");
fn void PLMframe.to_argb(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_argb");
fn void PLMframe.to_abgr(PLMframe *frame, Uint8_t *dest, int stride) @cname("plm_frame_to_abgr");


// -----------------------------------------------------------------------------
// plm_audio public API
// Decode MPEG-1 Audio Layer II ("mp2") data into raw samples
module thirdparty::plmpeg::plm::audio;

import thirdparty::plmpeg::plm;
import thirdparty::plmpeg::plm::buffer @public;

struct PLMquantizer_spec 
{
	ushort levels;
	char group;
	char bits;
}

struct PLMaudio
{
	double time;
	int samples_decoded;
	int samplerate_index;
	int bitrate_index;
	int version;
	int layer;
	int mode;
	int bound;
	int v_pos;
	int next_frame_data_size;
	int has_header;
	
	Buffer *buffer;
	int destroy_buffer_when_done;

	PLMquantizer_spec*[32][2] allocation;
	Uint8_t[32][2] scale_factor_info;
	int[3][32][2] scale_factor;
	int[3][32][2] sample;

	PLMsamples samples;
	float[1024] d;
	float[1024][2] v;
	float[32] u;
}

// Create an audio decoder with a plm_buffer as source.

fn PLMaudio *create_with_buffer(Buffer *buffer, int destroy_when_done) @cname("plm_audio_create_with_buffer");


// Destroy an audio decoder and free all data.

fn void PLMaudio.destroy(PLMaudio *self) @cname("plm_audio_destroy");


// Get whether a frame header was found and we can accurately report on
// samplerate.

fn int PLMaudio.header_exists(PLMaudio *self) @cname("plm_audio_has_header");


// Get the samplerate in samples per second.

fn int PLMaudio.get_samplerate(PLMaudio *self) @cname("plm_audio_get_samplerate");


// Get the current internal time in seconds.

fn double PLMaudio.get_time(PLMaudio *self) @cname("plm_audio_get_time");


// Set the current internal time in seconds. This is only useful when you
// manipulate the underlying video buffer and want to enforce a correct
// timestamps.

fn void PLMaudio.set_time(PLMaudio *self, double time) @cname("plm_audio_set_time");


// Rewind the internal buffer. See plm_buffer_rewind().

fn void PLMaudio.rewind(PLMaudio *self) @cname("plm_audio_rewind");


// Get whether the file has ended. This will be cleared on rewind.

fn int PLMaudio.has_ended(PLMaudio *self) @cname("plm_audio_has_ended");


// Decode and return one "frame" of audio and advance the internal time by 
// (PLM_AUDIO_SAMPLES_PER_FRAME/samplerate) seconds. The returned samples_t 
// is valid until the next call of plm_audio_decode() or until the audio
// decoder is destroyed.

fn PLMsamples *PLMaudio.decode(PLMaudio *self) @cname("plm_audio_decode");