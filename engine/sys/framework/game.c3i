/************************************ LICENSE *******************************************
# hmflathead GPL Source Code
# Copyright (C) 2025 Hilario Martins.
# 
# This file is part of the hmflathead GPL Source Code ("hmflathead Source Code")
# 
# hmflathead Source Code is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# hmflathead Source Code is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with hmflathead Source Code.  If not, see <http://www.gnu.org/licenses/>.
# 
# In addition, the hmflathead Source Code is also subject to certain additional terms. 
# You should have received a copy of these additional terms immediately following the terms and conditions of the GNU General Public License 
# which accompanied the hmflathead Source Code.  If not, please request a copy in writing from me at the address below.
# 
# If you have questions concerning this license or the applicable additional terms, you may contact in writing 
# Hilario Martins, Rua de Sanguinhedo 1010 4850-545 Vieira Do Minho Portugal.
# 
*********************************************************************************************************************************************/

/*
module engine::sys::framework::game;

import std::io;
import engine::logging::log;
import std::collections::list;

/*
===============================================================================

	Public game interface with methods to run the game.

===============================================================================
*/

const MAX_STRING_CHARS = 1024;

struct GameReturn {
	char[MAX_STRING_CHARS]	sessionCommand;	// "map", "disconnect", "victory", etc
	int	 consistencyHash;					// used to check for network game divergence
	int	 health;
	int	 heartRate;
	int	 stamina;
	int	 combat;
	bool syncNextGameFrame;					// used when cinematics are skipped to prevent session from simulating several game frames to
											// keep the game time in sync with real time
}

enum ESCAction {
	IGNORE,	// do nothing
	MAIN,	// start main menu GUI
	GUI		// set an explicit GUI
}

interface IGame
{
    // Initialize the game for the first time.
    fn void? onStart(String[] args);
    fn void update(double deltaTime);
    fn void render();
    // Shut down the entire game.
    fn void shutdown();
    // Loads a map and spawns all the entities.
    fn void	initFromNewMap(String mapName, /*idRenderWorld *renderWorld, idSoundWorld *soundWorld,*/ bool isServer, bool isClient, int randseed );

    // Shut down the current map.
    fn void	mapShutdown();

    // Saves the current game state to a savegame file.
    fn void	saveGame( SaveFile* saveGameFile );

    // Loads a map from a savegame file.
    fn bool	initFromSaveGame( String mapName, /*idRenderWorld *renderWorld, idSoundWorld *soundWorld,*/ SaveFile* saveGameFile );

    // The session calls this before moving the single player game to a new level.
    // TODO create a dictionary class based/inspired on idDict
    //fn idDict &		GetPersistentPlayerInfo( int clientNum );

    // The session calls this right before a new level is loaded.
    //fn void				SetPersistentPlayerInfo( int clientNum, const idDict &playerInfo ) = 0;

    // Caches media referenced from in key/value pairs in the given dictionary.
    //fn void	cacheDictionaryMedia( idDict *dict );

    // Spawns the player entity to be used by the client.
    fn void	spawnPlayer( int clientNum );

    // Runs a game frame, may return a session command for level changing, etc
    fn GameReturn runFrame();

    // Makes rendering and sound system calls to display for a given clientNum.
    fn bool	draw(int clientNum = 0);

    // Let the game do it's own UI when ESCAPE is used
    // TODO change Desktop name to UserInterface
    fn ESCAction handleESC( Desktop** gui );

    // get the games menu if appropriate ( multiplayer )
    // TODO change Desktop name to UserInterface
    fn Desktop* startMenu();

    // When the game is running it's own UI fullscreen, GUI commands are passed through here
    // return NULL once the fullscreen UI mode should stop, or "main" to go to main menu
    fn String handleGuiCommands( String menuCommand );

    // main menu commands not caught in the engine are passed here
    // TODO change Desktop name to UserInterface
    fn void	handleMainMenuCommands( String menuCommand, Desktop* gui );

    fn void	getMapLoadingGUI( char[ MAX_STRING_CHARS ] gui );
}